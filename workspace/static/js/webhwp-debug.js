// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	'use strict';

	var resolve, getRequire, wmRequire, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]}
	  , envRequire = typeof require === 'function' ? require : null;

	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullPath, state, id) {
		var name, dir, exports, module, fn, found, ext;
		path = path.split('/');
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null)  {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
				id = id.slice(0, id.lastIndexOf('/'));
			} else {
				tree.push(scope);
				scope = scope[dir];
				id += '/' + dir;
			}
			if (!scope) throw notFoundError(fullPath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				id += '/' + name;
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullPath, 1, id);
			}
			return resolve(scope, tree, 'index', fullPath, 2, id);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullPath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports, id: id + '/' + name };
		fn.call(exports, exports, module, getRequire(scope, tree, id));
		return module.exports;
	};
	wmRequire = function (scope, tree, fullPath, id) {
		var name, path = fullPath, t = fullPath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = '/';
			tree = [];
		} else if (t !== '.') {
			name = path.indexOf('@') === 0 ? path.split('/', 2).join("/") : path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = name;
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullPath, state, id);
	};
	getRequire = function (scope, tree, id) {
		var localRequire = function (path) {
			return wmRequire(scope, [].concat(tree), path, id);
		};
		if (envRequire) localRequire.fromParentEnvironment = envRequire;
		return localRequire
	};
	return getRequire(modules, [], '');
})
({
	"per": {
		":mainpath:": "per.js",
		"per.js": function (exports, module, require) {
			
			(function(exportFunction) {
			
			    function toFunc(valOrFunc, bindThis) {
			        if (typeof valOrFunc !== 'function') {
			            return Array.isArray(valOrFunc)
			                ? function(emit) {
			                    return valOrFunc.some(emit);
			                } : function(emit) {
			                    return emit(valOrFunc);
			                };
			        }
			        if (bindThis) {
			            return function(emit, value) {
			                valOrFunc.call(bindThis, emit, value);
			            }
			        }
			        return valOrFunc;
			    }
			
			    function Per(valOrFunc, bindThis) {
			        this.forEach = toFunc(valOrFunc, bindThis);
			    }
			
			    function blank(emit, value) {
			        emit(value);
			    }
			
			    function create(valOrFunc, bindThis) {
			        if (arguments.length === 0) {
			            return new Per(blank);
			        }
			        if (valOrFunc && valOrFunc instanceof Per) {
			            return valOrFunc;
			        }
			        return new Per(valOrFunc, bindThis)
			    }
			
			    Per.prototype.per = function(valOrFunc, bindThis) {
			        var first = this.forEach;
			        var second = toFunc(valOrFunc && valOrFunc.forEach || valOrFunc, bindThis);
			        return create(function(emit, value) {
			            return first(function(firstVal) {
			                return second(emit, firstVal);
			            }, value);
			        });
			    };
			
			    function lambda(expression) {
			        return typeof expression === 'string'
			            ? new Function('x', 'return ' + expression)
			            : expression;
			    }
			
			    Per.prototype.map = function(mapFunc) {
			        mapFunc = lambda(mapFunc);
			        return this.per(function(emit, value) {
			            return emit(mapFunc(value));
			        });
			    };
			
			    Per.prototype.filter = function(predicate) {
			        predicate = lambda(predicate);
			        return this.per(function(emit, value) {
			            if (predicate(value)) {
			                return emit(value);
			            }
			        });
			    };
			
			    Per.prototype.concat = function(second, secondThis) {        
			        if (second instanceof Per) {
			            second = second.forEach;
			        } else {
			            second = toFunc(second, secondThis);
			        }
			        var first = this.forEach;
			        return create(function(emit, value) {
			            first(emit, value);
			            second(emit, value);			
			        });
			    };
			
			    Per.prototype.skip = function(count) {
			        return this.per(function(emit, value) {
			            if (count > 0) {
			                count--;
			                return false;
			            }
			            return emit(value);
			        });
			    };
			
			    Per.prototype.take = function(count) {
			        return this.per(function(emit, value) {
			            if (count <= 0) {
			                return true;
			            }
			            count--;
			            return emit(value);
			        });
			    };
			
			    Per.prototype.listen = function(untilFunc) {
			        return this.per(function(emit, value) {
			            if (untilFunc(value)) {
			                return true;
			            }
			            return emit(value);
			        });
			    };
			
			    Per.prototype.flatten = function() {
			        return this.per(function(emit, array) {
			            return !Array.isArray(array)
			                ? emit(array)
			                : array.some(function(value) {
			                    return emit(value);
			                });
			        });
			    };
			
			    Per.prototype.reduce = function(reducer, seed) {
			        var result = seed, started = arguments.length == 2;
			        return this.per(function(emit, value) {
			            result = started ? reducer(result, value) : value;
			            emit(result);
			            started = true;
			        });
			    };
			
			    Per.prototype.multicast = function(destinations) {
			        if (arguments.length !== 1) {
			            destinations = Array.prototype.slice.call(arguments, 0);
			        }
			        destinations = destinations.map(function(destination) {
			            return typeof destination === 'function' ? destination :
			                   destination instanceof Per ? destination.forEach :
			                   ignore;
			        });
			        return this.listen(function(value) {
			            var quit = true;
			            destinations.forEach(function(destination) {
			                if (!destination(ignore, value)) {
			                    quit = false;
			                }
			            });
			            return quit;
			        });
			    };
			
			    function optionalLimit(limit) {
			        return typeof limit != 'number' ? Number.MAX_VALUE : limit;
			    }
			
			    /*  A passive observer - gathers results into the specified array, but
			        otherwise has no effect on the stream of values
			     */
			    Per.prototype.into = function(ar, limit) {
			        if (!Array.isArray(ar)) {
			            throw new Error("into expects an array");
			        }
			        limit = optionalLimit(limit);
			        return this.listen(function(value) {
			            if (limit <= 0) {
			                return true;
			            }
			            ar.push(value);
			            limit--;
			        });
			    };
			
			    function setOrCall(obj, name) {
			        var prop = obj[name];
			        if (typeof prop === 'function') {
			            return prop;
			        }
			        return function(val) {
			            obj[name] = val;
			        }
			    }
			
			    /*  Tracks first, last and count for the values as they go past,
			        up to an optional limit (see 'first' and 'last' methods).
			     */
			    Per.prototype.monitor = function(data) {
			        var n = 0;
			        var count = setOrCall(data, 'count'),
			            first = setOrCall(data, 'first'),
			            last = setOrCall(data, 'last'),
			            limit = data.limit;
			        if (typeof limit != 'number') {
			            limit = Number.MAX_VALUE;
			        }
			        if (limit < 1) {
			            return this;
			        }
			        return this.listen(function(value) {
			            if (n === 0) {
			                first(value);
			            }
			            n++;
			            count(n);
			            last(value);
			            if (n >= limit) {
			                return true;
			            }
			        });
			    };
			
			    /*  Send a value into the pipeline without caring what emerges
			        (only useful if you set up monitors and/or intos, or
			        similar stateful observers).
			     */
			    function ignore() { }
			    Per.prototype.submit = function(value) {
			        return this.forEach(ignore, value);
			    };
			
			    Per.prototype.all = function() {
			        var results = [];
			        this.into(results).submit();
			        return results;
			    };
			
			    Per.prototype.first = function() {
			        var results = { limit: 1 };
			        this.monitor(results).submit();
			        return results.count > 0 ? results.first : (void 0);
			    };
			
			    Per.prototype.last = function() {
			        var results = {};
			        this.monitor(results).submit();
			        return results.count > 0 ? results.last : (void 0);
			    };
			
			    function truthy(value) { return !!value; }
			    Per.prototype.truthy = function() { return this.filter(truthy); };
			
			    function min(l, r) { return Math.min(l, r); }
			    Per.prototype.min = function() { return this.reduce(min, Number.MAX_VALUE); };
			
			    function max(l, r) { return Math.max(l, r); }
			    Per.prototype.max = function() { return this.reduce(max, Number.MIN_VALUE); };
			
			    function sum(l, r) { return l + r }
			    Per.prototype.sum = function() { return this.reduce(sum, 0); };
			
			    function and(l, r) { return !!(l && r) }
			    Per.prototype.and = function() { return this.reduce(and, true); };
			
			    function or(l, r) { return !!(l || r) }
			    Per.prototype.or = function() { return this.reduce(or, false); };
			
			    function not(v) { return !v }
			    Per.prototype.not = function() { return this.map(not); };
			
			    create.pulse = function(ms) {
			        var counter = 0;
			        return create(function(emit) {
			            function step() {
			                if (emit(counter++) !== true) {
			                    setTimeout(step, ms);
			                }
			            }
			            step();
			        });
			    };
			
			    exportFunction(create);
			
			})(function(per) {
			    if (typeof exports === 'undefined') {
			        this['per'] = per;
			    } else {
			        module.exports = per;
			    }
			});
		}
	},
	"webhwp": {
		"workspace": {
			"src": {
				"bundle": {
					"base.js": function (exports, module, require) {
						/* import "../common/base/hp_SE2M_Menubar.js";
						//import "../common/base/hp_SE2M_Toolbar.js";
						import "../fundamental/editing/hp_SE_EditingAreaManager.js";
						import "../fundamental/editing/hp_SE_EditingArea.js";
						import "../fundamental/base/hp_SE2M_ExecCommand.js";
						import "../util/hp_Utils.js";
						import "../util/hp_StringConverterManager.js";
						import "../util/hp_SE2M_Utils.js"; */

						require("../common/base/hp_SE2M_Menubar.js");
						//require("../common/base/hp_SE2M_Toolbar.js");
						require("../fundamental/editing/hp_SE_EditingAreaManager.js");
						require("../fundamental/editing/hp_SE_EditingArea.js");
						require("../fundamental/base/hp_SE2M_ExecCommand.js");
						require("../util/hp_Utils.js");
						require("../util/hp_StringConverterManager.js");
						require("../util/hp_SE2M_Utils.js");

						/* window.nSE2Version = __VERSION__ + "." + __HASH__;
						nhn.husky.SE_EditingAreaManager.version = {
							revision : __HASH__,
							type : "open",
							number : __VERSION__
						}; */
					},
					"carota.js": function (exports, module, require) {
						var node = require('../carota/node');
						var editor = require('../carota/editor');
						var doc = require('../carota/doc');
						var dom = require('../carota/dom');
						var runs = require('../carota/runs');
						var html = require('../carota/html');
						var frame = require('../carota/frame');
						var text = require('../carota/text');
						var rect = require('../carota/rect');

						var bundle = {
							node: node,
							editor: editor,
							doc: doc,
							dom: dom,
							runs: runs,
							html: html,
							frame: frame,
							text: text,
							rect: rect
						};

						module.exports = bundle;

						if (typeof window !== 'undefined' && window.document) {
							if (window.carota) {
								throw new Error('Something else is called carota!');
							}
							window.carota = bundle;
						}
					},
					"husky-range.js": function (exports, module, require) {
						/* import "../husky_framework/HuskyCore.js";
						import "../husky_framework/HuskyRange.js";
						import "../husky_framework/hp_CorePlugin.js";
						import "../husky_framework/hp_HuskyRangeManager.js"; */

						require("../husky_framework/HuskyCore.js");
						require("../husky_framework/HuskyRange.js");
						require("../husky_framework/hp_CorePlugin.js");
						require("../husky_framework/hp_HuskyRangeManager.js");
					},
					"hwp.js": function (exports, module, require) {
						var doc = require('../hwp/doc');
						var frame = require('../hwp/frame');
						var hwp = require('../hwp/hwp');

						var bundle = {
							doc: doc,
							frame: frame,
							hwp: hwp,
						};

						module.exports = bundle;

						if (typeof window !== 'undefined' && window.document) {
							if (window.hwp) {
								throw new Error('Something else is called hwp!');
							}
							window.hwp = bundle;
						}
					},
					"index.js": function (exports, module, require) {
						/* import "./husky-range";
						import "./base";
						//import "./extra";
						//import "./lazy";
						import "./carota";
						import "./hwp";
						//import "./node-hwp" */

						require("./husky-range");
						require("./base");
						require("./carota");
						require("./hwp");
					}
				},
				"carota": {
					"characters.js": function (exports, module, require) {
						var runs = require('./runs');

						var compatible = function(a, b) {
						    if (a._runs !== b._runs) {
						        throw new Error('Characters for different documents');
						    }
						};

						var prototype = {
						    equals: function(other) {
						        compatible(this, other);
						        return this._run === other._run && this._offset === other._offset;
						    },
						    cut: function(upTo) {
						        compatible(this, upTo);
						        var self = this;
						        return function(eachRun) {
						            for (var runIndex = self._run; runIndex <= upTo._run; runIndex++) {
						                var run = self._runs[runIndex];
						                if (run) {
						                    var start = (runIndex === self._run) ? self._offset : 0;
						                    var stop = (runIndex === upTo._run) ? upTo._offset : runs.getTextLength(run.text);
						                    if (start < stop) {
						                        runs.getSubText(function(piece) {
						                            var pieceRun = Object.create(run);
						                            pieceRun.text = piece;
						                            eachRun(pieceRun);
						                        }, run.text, start, stop - start);
						                    }
						                }
						            }
						        };
						    }
						};

						function character(runArray, run, offset) {
						    return Object.create(prototype, {
						        _runs: { value: runArray },
						        _run: { value: run },
						        _offset: { value: offset },
						        char: {
						            value: run >= runArray.length ? null :
						                runs.getTextChar(runArray[run].text, offset)
						        }
						    });
						}

						function firstNonEmpty(runArray, n) {
						    for (; n < runArray.length; n++) {
						        if (runs.getTextLength(runArray[n].text) != 0) {
						            return character(runArray, n, 0);
						        }
						    }
						    return character(runArray, runArray.length, 0);
						}

						module.exports = function(runArray) {
						    return function(emit) {
						        var c = firstNonEmpty(runArray, 0);
						        while (!emit(c) && (c.char !== null)) {
						            c = (c._offset + 1 < runs.getTextLength(runArray[c._run].text))
						                ? character(runArray, c._run, c._offset + 1)
						                : firstNonEmpty(runArray, c._run + 1);
						        }
						    };
						};
					},
					"codes.js": function (exports, module, require) {
						var text = require('./text');
						var frame = require('./frame');
						var node = require('./node');
						var rect = require('./rect');
						var util = require('./util');

						var inlineNodePrototype = node.derive({
						    parent: function() {
						        return this._parent;
						    },
						    draw: function(ctx) {
						        this.inline.draw(ctx,
						            this.left,
						            this.baseline,
						            this.measured.width,
						            this.measured.ascent,
						            this.measured.descent,
						            this.formatting);
						    },
						    position: function(left, baseline, bounds) {
						        this.left = left;
						        this.baseline = baseline;
						        if (bounds) {
						            this._bounds = bounds;
						        }
						    },
						    bounds: function() {
						        return this._bounds || rect(this.left, this.baseline - this.measured.ascent,
						            this.measured.width, this.measured.ascent + this.measured.descent);
						    },
						    byCoordinate: function(x, y) {
						        if (x <= this.bounds().center().x) {
						            return this;
						        }
						        return this.next();
						    }
						});

						var inlineNode = function(inline, parent, ordinal, length, formatting) {
						    if (!inline.draw || !inline.measure) {
						        throw new Error();
						    }
						    return Object.create(inlineNodePrototype, {
						        inline: { value: inline },
						        _parent: { value: parent },
						        ordinal: { value: ordinal },
						        length: { value: length },
						        formatting: { value: formatting },
						        measured: {
						            value: inline.measure(formatting)
						        }
						    });
						};

						var codes = {};

						codes.number = function(obj, number) {
						    var formattedNumber = (number + 1) + '.';
						    return {
						        measure: function(formatting) {
						            return text.measure(formattedNumber, formatting);
						        },
						        draw: function(ctx, x, y, width, ascent, descent, formatting) {
						            text.draw(ctx, formattedNumber, formatting, x, y, width, ascent, descent);
						        }
						    };
						};

						var listTerminator = function(obj) {
						    return util.derive(obj, {
						        eof: true,
						        measure: function(formatting) {
						            return { width: 18, ascent: 0, descent: 0 }; // text.measure(text.enter, formatting);
						        },
						        draw: function(ctx, x, y) {
						            // ctx.fillText(text.enter, x, y);
						        }
						    });
						};

						codes.listNext = codes.listEnd = listTerminator;

						codes.listStart = function(obj, data, allCodes) {
						    return util.derive(obj, {
						        block: function(left, top, width, ordinal, parent, formatting) {
						            var list = node.generic('list', parent, left, top),
						                itemNode,
						                itemFrame,
						                itemMarker;

						            var indent = 50, spacing = 10;

						            var startItem = function(code, formatting) {
						                itemNode = node.generic('item', list);
						                var marker = allCodes(code.marker || { $: 'number' }, list.children().length);
						                itemMarker = inlineNode(marker, itemNode, ordinal, 1, formatting);
						                itemMarker.block = true;
						                itemFrame = frame(
						                    left + indent, top, width - indent, ordinal + 1, itemNode,
						                    function(terminatorCode) {
						                        return terminatorCode.$ === 'listEnd';
						                    },
						                    itemMarker.measured.ascent
						                );
						            };

						            startItem(obj, formatting);

						            return function(inputWord) {
						                if (itemFrame) {
						                    itemFrame(function(finishedFrame) {
						                        ordinal = finishedFrame.ordinal + finishedFrame.length;
						                        var frameBounds = finishedFrame.bounds();

						                        // get first line and position marker
						                        var firstLine = finishedFrame.first();
						                        var markerLeft = left + indent - spacing - itemMarker.measured.width;
						                        var markerBounds = rect(left, top, indent, frameBounds.h);
						                        if ('baseline' in firstLine) {
						                            itemMarker.position(markerLeft, firstLine.baseline, markerBounds);
						                        } else {
						                            itemMarker.position(markerLeft, top + itemMarker.measured.ascent, markerBounds);
						                        }

						                        top = frameBounds.t + frameBounds.h;

						                        itemNode.children().push(itemMarker);
						                        itemNode.children().push(finishedFrame);
						                        itemNode.finalize();

						                        list.children().push(itemNode);
						                        itemNode = itemFrame = itemMarker = null;
						                    }, inputWord);
						                } else {
						                    ordinal++;
						                }

						                if (!itemFrame) {
						                    var i = inputWord.code();
						                    if (i) {
						                        if (i.$ == 'listEnd') {
						                            list.finalize();
						                            return list;
						                        }
						                        if (i.$ == 'listNext') {
						                            startItem(i, inputWord.codeFormatting());
						                        }
						                    }
						                }
						            };
						        }
						    });
						};

						module.exports = exports = function(obj, number, allCodes) {
						    var impl = codes[obj.$];
						    return impl && impl(obj, number, allCodes);
						};

						exports.editFilter = function(doc) {
						    var balance = 0;

						    if (!doc.words.some(function(word, i) {
						        var code = word.code();
						        if (code) {
						            switch (code.$) {
						                case 'listStart':
						                    balance++;
						                    break;
						                case 'listNext':
						                    if (balance === 0) {
						                        doc.spliceWordsWithRuns(i, 1, [util.derive(word.codeFormatting(), {
						                            text: {
						                                $: 'listStart',
						                                marker: code.marker
						                            }
						                        })]);
						                        return true;
						                    }
						                    break;
						                case 'listEnd':
						                    if (balance === 0) {
						                        doc.spliceWordsWithRuns(i, 1, []);
						                    }
						                    balance--;
						                    break;
						            }
						        }
						    })) {
						        if (balance > 0) {
						            var ending = [];
						            while (balance > 0) {
						                balance--;
						                ending.push({
						                    text: { $: 'listEnd' }
						                });
						            }
						            doc.spliceWordsWithRuns(doc.words.length - 1, 0, ending);
						        }
						    }
						};
					},
					"doc.js": function (exports, module, require) {
						var per = require('per');
						var characters = require('./characters');
						var split = require('./split');
						var word = require('./word');
						var node = require('./node');
						var runs = require('./runs');
						var range = require('./range');
						var util = require('./util');
						var frame = require('./frame');
						var codes = require('./codes');
						var rect = require('./rect');

						var makeEditCommand = function(doc, start, count, words) {
							var selStart = doc.selection.start, selEnd = doc.selection.end;
							return function(log) {
								doc._wordOrdinals = [];
								var oldWords = Array.prototype.splice.apply(doc.words, [start, count].concat(words));
								log(makeEditCommand(doc, start, words.length, oldWords));
								doc._nextSelection = { start: selStart, end: selEnd };
							};
						};

						var makeTransaction = function(perform) {
							var commands = [];
							var log = function(command) {
								commands.push(command);
								log.length = commands.length;
							};
							perform(log);

							return function(outerLog) {
								outerLog(makeTransaction(function(innerLog) {
									while (commands.length) {
										commands.pop()(innerLog);
									}
								}));
							};
						};

						var isBreaker = function(word) {
							if (word.isNewLine()) {
								return true;
							}
							var code = word.code();
							return !!(code && (code.block || code.eof));
						};

						var prototype = node.derive({
							load: function(runs, takeFocus) {
								var self = this;
								this.undo = [];
								this.redo = [];
								this._wordOrdinals = [];

								//var one = per(characters(runs)).all();
								//var two = per(characters(runs)).per(split(self.codes)).all();
								this.words = per(characters(runs)).per(split(self.codes)).map(function(w) {
									return word(w, self.codes);
								}).all();
								
								this.layout();
								this.contentChanged.fire();
								this.select(0, 0, takeFocus);
							},
							layout: function(left, top, width, height) {
								this.frame = null;
								try {
									this._left = left || 0;
									this._top = top || 0;
									this._width = width || 0;
									this.frame = per(this.words).per(frame(this._left, this._top, this._width, 0, this)).first();
								} catch (x) {
									console.error(x);
								}
								if (!this.frame) {
									console.error('A bug somewhere has produced an invalid state - rolling back');
									this.performUndo();
								} else if (this._nextSelection) {
									var next = this._nextSelection;
									delete this._nextSelection;
									this.select(next.start, next.end);
								}
							},
							range: function(start, end) {
								return range(this, start, end);
							},
							documentRange: function() {
								return this.range(0, this.frame.length - 1);
							},
							selectedRange: function() {
								return this.range(this.selection.start, this.selection.end);
							},
							save: function() {
								return this.documentRange().save();
							},
							paragraphRange: function(start, end) {
								var i;

								// find the character after the nearest breaker before start
								var startInfo = this.wordContainingOrdinal(start);
								start = 0;
								if (startInfo && !isBreaker(startInfo.word)) {
									for (i = startInfo.index; i > 0; i--) {
										if (isBreaker(this.words[i - 1])) {
											start = this.wordOrdinal(i);
											break;
										}
									}
								}

								// find the nearest breaker after end
								var endInfo = this.wordContainingOrdinal(end);
								end = this.frame.length - 1;
								if (endInfo && !isBreaker(endInfo.word)) {
									for (i = endInfo.index; i < this.words.length; i++) {
										if (isBreaker(this.words[i])) {
											end = this.wordOrdinal(i);
											break;
										}
									}
								}

								return this.range(start, end);
							},
							insert: function(text, takeFocus) {
								this.select(this.selection.end + this.selectedRange().setText(text), null, takeFocus);
							},
							modifyInsertFormatting: function(attribute, value) {
								this.nextInsertFormatting[attribute] = value;
								this.notifySelectionChanged();
							},
							applyInsertFormatting: function(text) {
								var formatting = this.nextInsertFormatting;
								var insertFormattingProperties = Object.keys(formatting);
								if (insertFormattingProperties.length) {
									text.forEach(function(run) {
										insertFormattingProperties.forEach(function(property) {
											run[property] = formatting[property];
										});
									});
								}
							},
							wordOrdinal: function(index) {
								if (index < this.words.length) {
									var cached = this._wordOrdinals.length;
									if (cached < (index + 1)) {
										var o = cached > 0 ? this._wordOrdinals[cached - 1] : 0;
										for (var n = cached; n <= index; n++) {
											this._wordOrdinals[n] = o;
											o += this.words[n].length;
										}
									}
									return this._wordOrdinals[index];
								}
							},
							wordContainingOrdinal: function(ordinal) {
								// could rewrite to be faster using binary search over this.wordOrdinal
								var result;
								var pos = 0;
								this.words.some(function(word, i) {
									if (ordinal >= pos && ordinal < (pos + word.length)) {
										result = {
											word: word,
											ordinal: pos,
											index: i,
											offset: ordinal - pos
										};
										return true;
									}
									pos += word.length;
								});
								return result;
							},
							runs: function(emit, range) {
								var startDetails = this.wordContainingOrdinal(Math.max(0, range.start)),
									endDetails = this.wordContainingOrdinal(Math.min(range.end, this.frame.length - 1));
								if (startDetails.index === endDetails.index) {
									startDetails.word.runs(emit, {
										start: startDetails.offset,
										end: endDetails.offset
									});
								} else {
									startDetails.word.runs(emit, { start: startDetails.offset });
									for (var n = startDetails.index + 1; n < endDetails.index; n++) {
										this.words[n].runs(emit);
									}
									endDetails.word.runs(emit, { end: endDetails.offset });
								}
							},
							spliceWordsWithRuns: function(wordIndex, count, runs) {
								var self = this;

								var newWords = per(characters(runs))
									.per(split(self.codes))
									.truthy()
									.map(function(w) {
										return word(w, self.codes);
									})
									.all();

								// Check if old or new content contains any fancy control codes:
								var runFilters = false;

								if ('_filtersRunning' in self) {
									self._filtersRunning++;
								} else {
									for (var n = 0; n < count; n++) {
										if (this.words[wordIndex + n].code()) {
											runFilters = true;
										}
									}
									if (!runFilters) {
										runFilters = newWords.some(function(word) {
											return !!word.code();
										});
									}
								}

								this.transaction(function(log) {
									makeEditCommand(self, wordIndex, count, newWords)(log);
									if (runFilters) {
										self._filtersRunning = 0;
										try {
											for (;;) {
												var spliceCount = self._filtersRunning;
												if (!self.editFilters.some(function(filter) {
													filter(self);
													return spliceCount !== self._filtersRunning;
												})) {
													break; // No further changes were made
												}
											}
										} finally {
											delete self._filtersRunning;
										}
									}
								});
							},
							splice: function(start, end, text) {
								if (typeof text === 'string') {
									var sample = Math.max(0, start - 1);
									var sampleRun = per({ start: sample, end: sample + 1 })
										.per(this.runs, this)
										.first();
									text = [
										sampleRun ? Object.create(sampleRun, { text: { value: text } }) : { text: text }
									];
								} else if (!Array.isArray(text)) {
									text = [{ text: text }];
								}

								this.applyInsertFormatting(text);

								var startWord = this.wordContainingOrdinal(start),
									endWord = this.wordContainingOrdinal(end);

								var prefix;
								if (start === startWord.ordinal) {
									if (startWord.index > 0 && !isBreaker(this.words[startWord.index - 1])) {
										startWord.index--;
										var previousWord = this.words[startWord.index];
										prefix = per({}).per(previousWord.runs, previousWord).all();
									} else {
										prefix = [];
									}
								} else {
									prefix = per({ end: startWord.offset })
											.per(startWord.word.runs, startWord.word)
											.all();
								}

								var suffix;
								if (end === endWord.ordinal) {
									if ((end === this.frame.length - 1) || isBreaker(endWord.word)) {
										suffix = [];
										endWord.index--;
									} else {
										suffix = per({}).per(endWord.word.runs, endWord.word).all();
									}
								} else {
									suffix = per({ start: endWord.offset })
											.per(endWord.word.runs, endWord.word)
											.all();
								}

								var oldLength = this.frame.length;

								this.spliceWordsWithRuns(startWord.index, (endWord.index - startWord.index) + 1,
									per(prefix).concat(text).concat(suffix).per(runs.consolidate()).all());

								return this.frame ? (this.frame.length - oldLength) : 0;
							},
							registerEditFilter: function(filter) {
								this.editFilters.push(filter);
							},
							width: function(width) {
								if (arguments.length === 0)
									return this._width;
								this._width = width;
								this.layout();
							},
							children: function() {
								return [this.frame];
							},
							toggleCaret: function() {
								var old = this.caretVisible;
								if (this.selection.start === this.selection.end) {
									if (this.selectionJustChanged) {
										this.selectionJustChanged = false;
									} else {
										this.caretVisible = !this.caretVisible;
									}
								}
								return this.caretVisible !== old;
							},
							getCaretCoords: function(ordinal) {
								var node = this.byOrdinal(ordinal), b;
								if (node) {
									if (node.block && ordinal > 0) {
										var nodeBefore = this.byOrdinal(ordinal - 1);
										if (nodeBefore.newLine) {
											var newLineBounds = nodeBefore.bounds();
											var lineBounds = nodeBefore.parent().parent().bounds();
											b = rect(lineBounds.l, lineBounds.b, 1, newLineBounds.h);
										} else {
											b = nodeBefore.bounds();
											b = rect(b.r, b.t, 1, b.h);
										}
									} else {
										b = node.bounds();
										if (b.h) {
											b = rect(b.l, b.t, 1, b.h);
										} else {
											b = rect(b.l, b.t, b.w, 1);
										}
									}
									return b;
								}
							},
							byCoordinate: function(x, y) {
								var ordinal = this.frame.byCoordinate(x, y).ordinal;
								var caret = this.getCaretCoords(ordinal);
								while (caret.b <= y && ordinal < (this.frame.length - 1)) {
									ordinal++;
									caret = this.getCaretCoords(ordinal);
								}
								while (caret.t >= y && ordinal > 0) {
									ordinal--;
									caret = this.getCaretCoords(ordinal);
								}
								return this.byOrdinal(ordinal);
							},
							drawSelection: function(ctx, hasFocus) {
								if (this.selection.end === this.selection.start) {
									if (this.selectionJustChanged || hasFocus && this.caretVisible) {
										var caret = this.getCaretCoords(this.selection.start);
										if (caret) {
											ctx.save();
											ctx.fillStyle = 'black';
											caret.fill(ctx);
											ctx.restore();
										}
									}
								} else {
									ctx.save();
									ctx.fillStyle = hasFocus ? 'rgba(0, 100, 200, 0.3)' : 'rgba(160, 160, 160, 0.3)';
									this.selectedRange().parts(function(part) {
										part.bounds(true).fill(ctx);
									});
									ctx.restore();
								}
							},
							notifySelectionChanged: function(takeFocus) {
								// When firing selectionChanged, we pass a function can be used
								// to obtain the formatting, as this highly likely to be needed
								var cachedFormatting = null;
								var self = this;
								var getFormatting = function() {
									if (!cachedFormatting) {
										cachedFormatting = self.selectedRange().getFormatting();
									}
									return cachedFormatting;
								};
								this.selectionChanged.fire(getFormatting, takeFocus);
							},
							select: function(ordinal, ordinalEnd, takeFocus) {
								if (!this.frame) {
									// Something has gone terribly wrong - doc.transaction will rollback soon
									return;
								}
								this.selection.start = Math.max(0, ordinal);
								this.selection.end = Math.min(
									typeof ordinalEnd === 'number' ? ordinalEnd : this.selection.start,
									this.frame.length - 1
								);
								this.selectionJustChanged = true;
								this.caretVisible = true;
								this.nextInsertFormatting = {};

								/*  NB. always fire this even if the positions stayed the same. The
									event means that the formatting of the selection has changed
									(which can happen either by moving the selection range or by
									altering the formatting)
								*/
								this.notifySelectionChanged(takeFocus);
							},
							performUndo: function(redo) {
								var fromStack = redo ? this.redo : this.undo,
									toStack = redo ? this.undo : this.redo,
									oldCommand = fromStack.pop();

								if (oldCommand) {
									oldCommand(function(newCommand) {
										toStack.push(newCommand);
									});
									this.layout();
									this.contentChanged.fire();
								}
							},
							canUndo: function(redo) {
								return redo ? !!this.redo.length : !!this.undo.length;
							},
							transaction: function(perform) {
								if (this._currentTransaction) {
									perform(this._currentTransaction);
								} else {
									var self = this;
									while (this.undo.length > 50) {
										self.undo.shift();
									}
									this.redo.length = 0;
									var changed = false;
									this.undo.push(makeTransaction(function(log) {
										self._currentTransaction = log;
										try {
											perform(log);
										} finally {
											changed = log.length > 0;
											self._currentTransaction = null;
										}
									}));
									if (changed) {
										self.layout();
										self.contentChanged.fire();
									}
								}
							},
							type: 'document'
						});

						exports = module.exports = function() {
							var doc = Object.create(prototype);
							doc._left = 0;
							doc._top = 0;
							doc._width = 0;
							doc.selection = { start: 0, end: 0 };
							doc.caretVisible = true;
							doc.customCodes = function(code, data, allCodes) {};
							doc.codes = function(code, data) {
								var instance = codes(code, data, doc.codes);
								return instance || doc.customCodes(code, data, doc.codes);
							};
							doc.selectionChanged = util.event();
							doc.contentChanged = util.event();
							doc.editFilters = [codes.editFilter];
							doc.load([]);
							return doc;
						};
					},
					"dom.js": function (exports, module, require) {
						
						exports.isAttached = function(element) {
						    var ancestor = element;
						    while(ancestor.parentNode) {
						        ancestor = ancestor.parentNode;
						    }
						    return !!ancestor.body;
						};

						exports.clear = function(element) {
						    while (element.firstChild) {
						        element.removeChild(element.firstChild);
						    }
						};

						exports.setText = function(element, text) {
						    exports.clear(element);
						    element.appendChild(document.createTextNode(text));
						};

						exports.handleEvent = function(element, name, handler) {
						    element.addEventListener(name, function(ev) {
						        if (handler(ev) === false) {
						            ev.preventDefault();
						        }
						    });
						};

						exports.handleMouseEvent = function(element, name, handler) {
						    exports.handleEvent(element, name, function(ev) {
						        var rect = element.getBoundingClientRect();
						        return handler(ev, ev.clientX - rect.left, ev.clientY - rect.top);
						    });
						};

						exports.effectiveStyle = function(element, name) {
						    return document.defaultView.getComputedStyle(element).getPropertyValue(name);
						};
					},
					"editor.js": function (exports, module, require) {
						var per = require('per');
						var carotaDoc = require('./doc');
						var dom = require('./dom');
						var rect = require('./rect');

						setInterval(function() {
						    var editors = document.querySelectorAll('.carotaEditorCanvas');

						    var ev = document.createEvent('Event');
						    ev.initEvent('carotaEditorSharedTimer', true, true);

						    // not in IE, apparently:
						    // var ev = new CustomEvent('carotaEditorSharedTimer');

						    for (var n = 0; n < editors.length; n++) {
						        editors[n].dispatchEvent(ev);
						    }
						}, 200);

						exports.create = function(element) {

						    // We need the host element to be a container:
						    if (dom.effectiveStyle(element, 'position') !== 'absolute') {
						        element.style.position = 'relative';
						    }

						    element.innerHTML =
						        '<div class="carotaSpacer">' +
						            '<canvas width="100" height="100" class="carotaEditorCanvas" style="position: absolute;"></canvas>' +
						        '</div>' +
						        '<div class="carotaTextArea" style="overflow: hidden; position: absolute; height: 0;">' +
						            '<textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" ' +
						            'style="position: absolute; padding: 0px; width: 1000px; height: 1em; ' +
						            'outline: none; font-size: 4px;"></textarea>'
						        '</div>';

						    var canvas = element.querySelector('canvas'),
						        spacer = element.querySelector('.carotaSpacer'),
						        textAreaDiv = element.querySelector('.carotaTextArea'),
						        textArea = element.querySelector('textarea'),
						        doc = carotaDoc(),
						        keyboardSelect = 0,
						        keyboardX = null, nextKeyboardX = null,
						        selectDragStart = null,
						        focusChar = null,
						        textAreaContent = '',
						        richClipboard = null,
						        plainClipboard = null;
						    
						    var toggles = {
						        66: 'bold',
						        73: 'italic',
						        85: 'underline',
						        83: 'strikeout'
						    };

						    var exhausted = function(ordinal, direction) {
						        return direction < 0 ? ordinal <= 0 : ordinal >= doc.frame.length - 1;
						    };

						    var differentLine = function(caret1, caret2) {
						        return (caret1.b <= caret2.t) ||
						               (caret2.b <= caret1.t);
						    };

						    var changeLine = function(ordinal, direction) {

						        var originalCaret = doc.getCaretCoords(ordinal), newCaret;
						        nextKeyboardX = (keyboardX !== null) ? keyboardX : originalCaret.l;

						        while (!exhausted(ordinal, direction)) {
						            ordinal += direction;
						            newCaret = doc.getCaretCoords(ordinal);
						            if (differentLine(newCaret, originalCaret)) {
						                break;
						            }
						        }

						        originalCaret = newCaret;
						        while (!exhausted(ordinal, direction)) {
						            if ((direction > 0 && newCaret.l >= nextKeyboardX) ||
						                (direction < 0 && newCaret.l <= nextKeyboardX)) {
						                break;
						            }

						            ordinal += direction;
						            newCaret = doc.getCaretCoords(ordinal);
						            if (differentLine(newCaret, originalCaret)) {
						                ordinal -= direction;
						                break;
						            }
						        }

						        return ordinal;
						    };

						    var endOfline = function(ordinal, direction) {
						        var originalCaret = doc.getCaretCoords(ordinal), newCaret;
						        while (!exhausted(ordinal, direction)) {
						            ordinal += direction;
						            newCaret = doc.getCaretCoords(ordinal);
						            if (differentLine(newCaret, originalCaret)) {
						                ordinal -= direction;
						                break;
						            }
						        }
						        return ordinal;
						    };

						    var handleKey = function(key, selecting, ctrlKey) {
						        var start = doc.selection.start,
						            end = doc.selection.end,
						            length = doc.frame.length - 1,
						            handled = false;

						        nextKeyboardX = null;

						        if (!selecting) {
						            keyboardSelect = 0;
						        } else if (!keyboardSelect) {
						            switch (key) {
						                case 37: // left arrow
						                case 38: // up - find character above
						                case 36: // start of line
						                case 33: // page up
						                    keyboardSelect = -1;
						                    break;
						                case 39: // right arrow
						                case 40: // down arrow - find character below
						                case 35: // end of line
						                case 34: // page down
						                    keyboardSelect = 1;
						                    break;
						            }
						        }

						        var ordinal = keyboardSelect === 1 ? end : start;

						        var changingCaret = false;
						        switch (key) {
						            case 37: // left arrow
						                if (!selecting && start != end) {
						                    ordinal = start;
						                } else {
						                    if (ordinal > 0) {
						                        if (ctrlKey) {
						                            var wordInfo = doc.wordContainingOrdinal(ordinal);
						                            if (wordInfo.ordinal === ordinal) {
						                                ordinal = wordInfo.index > 0 ? doc.wordOrdinal(wordInfo.index - 1) : 0;
						                            } else {
						                                ordinal = wordInfo.ordinal;
						                            }
						                        } else {
						                            ordinal--;
						                        }
						                    }
						                }
						                changingCaret = true;
						                break;
						            case 39: // right arrow
						                if (!selecting && start != end) {
						                    ordinal = end;
						                } else {
						                    if (ordinal < length) {
						                        if (ctrlKey) {
						                            var wordInfo = doc.wordContainingOrdinal(ordinal);
						                            ordinal = wordInfo.ordinal + wordInfo.word.length;
						                        } else {
						                            ordinal++;
						                        }
						                    }
						                }
						                changingCaret = true;
						                break;
						            case 40: // down arrow - find character below
						                ordinal = changeLine(ordinal, 1);
						                changingCaret = true;
						                break;
						            case 38: // up - find character above
						                ordinal = changeLine(ordinal, -1);
						                changingCaret = true;
						                break;
						            case 36: // start of line
						                ordinal = endOfline(ordinal, -1);
						                changingCaret = true;
						                break;
						            case 35: // end of line
						                ordinal = endOfline(ordinal, 1);
						                changingCaret = true;
						                break;
						            case 33: // page up
						                ordinal = 0;
						                changingCaret = true;
						                break;
						            case 34: // page down
						                ordinal = length;
						                changingCaret = true;
						                break;
						            case 8: // backspace
						                if (start === end && start > 0) {
						                    doc.range(start - 1, start).clear();
						                    focusChar = start - 1;
						                    doc.select(focusChar, focusChar);
						                    handled = true;
						                }
						                break;
						            case 46: // del
						                if (start === end && start < length) {
						                    doc.range(start, start + 1).clear();
						                    handled = true;
						                }
						                break;
						            case 90: // Z undo
						                if (ctrlKey) {
						                    handled = true;
						                    doc.performUndo();
						                }
						                break;
						            case 89: // Y undo
						                if (ctrlKey) {
						                    handled = true;
						                    doc.performUndo(true);
						                }
						                break;
						            case 65: // A select all
						                if (ctrlKey) {
						                    handled = true;
						                    doc.select(0, length);
						                }
						                break;
						            case 67: // C - copy to clipboard
						            case 88: // X - cut to clipboard
						                if (ctrlKey) {
						                    // Allow standard handling to take place as well
						                    richClipboard = doc.selectedRange().save();
						                    plainClipboard = doc.selectedRange().plainText();
						                }
						                break;
						        }

						        var toggle = toggles[key];
						        if (ctrlKey && toggle) {
						            var selRange = doc.selectedRange();
						            selRange.setFormatting(toggle, selRange.getFormatting()[toggle] !== true);
						            paint();
						            handled = true;
						        }

						        if (changingCaret) {
						            switch (keyboardSelect) {
						                case 0:
						                    start = end = ordinal;
						                    break;
						                case -1:
						                    start = ordinal;
						                    break;
						                case 1:
						                    end = ordinal;
						                    break;
						            }

						            if (start === end) {
						                keyboardSelect = 0;
						            } else {
						                if (start > end) {
						                    keyboardSelect = -keyboardSelect;
						                    var t = end;
						                    end = start;
						                    start = t;
						                }
						            }
						            focusChar = ordinal;
						            doc.select(start, end);
						            handled = true;
						        }

						        keyboardX = nextKeyboardX;
						        return handled;
						    };

						    dom.handleEvent(textArea, 'keydown', function(ev) {
						        if (handleKey(ev.keyCode, ev.shiftKey, ev.ctrlKey)) {
						            return false;
						        }
						        console.log(ev.which);
						    });

						    var verticalAlignment = 'top';
						    
						    doc.setVerticalAlignment = function(va) {
						        verticalAlignment = va;
						        paint();
						    }

						    function getVerticalOffset() {
						        var docHeight = doc.frame.bounds().h;
						        if (docHeight < element.clientHeight) { 
						            switch (verticalAlignment) {
						                case 'middle':
						                    return (element.clientHeight - docHeight) / 2;
						                case 'bottom':
						                    return element.clientHeight - docHeight;
						            }
						        }
						        return 0;
						    }

						    var paint = function() {

						        var availableWidth = element.clientWidth * 1; // adjust to 0.5 to see if we draw in the wrong places!
						        if (doc.width() !== availableWidth) {
						            doc.width(availableWidth);
						        }

						        var docHeight = doc.frame.bounds().h;

						        var dpr = Math.max(1, window.devicePixelRatio || 1);
						        
						        var logicalWidth = Math.max(doc.frame.actualWidth(), element.clientWidth),
						            logicalHeight = element.clientHeight;
						        
						        canvas.width = dpr * logicalWidth;
						        canvas.height = dpr * logicalHeight;
						        canvas.style.width = logicalWidth + 'px';
						        canvas.style.height = logicalHeight + 'px';
						        
						        canvas.style.top = element.scrollTop + 'px';
						        spacer.style.width = logicalWidth + 'px';
						        spacer.style.height = Math.max(docHeight, element.clientHeight) + 'px';

						        if (docHeight < (element.clientHeight - 50) &&
						            doc.frame.actualWidth() <= availableWidth) {
						            element.style.overflow = 'hidden';
						        } else {
						            element.style.overflow = 'auto';
						        }

						        var ctx = canvas.getContext('2d');
						        ctx.scale(dpr, dpr);

						        ctx.clearRect(0, 0, logicalWidth, logicalHeight);
						        ctx.translate(0, getVerticalOffset() - element.scrollTop);
						        
						        doc.draw(ctx, rect(0, element.scrollTop, logicalWidth, logicalHeight));
						        doc.drawSelection(ctx, selectDragStart || (document.activeElement === textArea));
						    };

						    dom.handleEvent(element, 'scroll', paint);

						    dom.handleEvent(textArea, 'input', function() {
						        var newText = textArea.value;
						        if (textAreaContent != newText) {
						            textAreaContent = '';
						            textArea.value = '';
						            if (newText === plainClipboard) {
						                newText = richClipboard;
						            }
						            doc.insert(newText);
						        }
						    });

						    var updateTextArea = function() {
						        focusChar = focusChar === null ? doc.selection.end : focusChar;
						        var endChar = doc.byOrdinal(focusChar);
						        focusChar = null;
						        if (endChar) {
						            var bounds = endChar.bounds();
						            textAreaDiv.style.left = bounds.l + 'px';
						            textAreaDiv.style.top = bounds.t + 'px';
						            textArea.focus();
						            var scrollDownBy = Math.max(0, bounds.t + bounds.h -
						                    (element.scrollTop + element.clientHeight));
						            if (scrollDownBy) {
						                element.scrollTop += scrollDownBy;
						            }
						            var scrollUpBy = Math.max(0, element.scrollTop - bounds.t);
						            if (scrollUpBy) {
						                element.scrollTop -= scrollUpBy;
						            }
						            var scrollRightBy = Math.max(0, bounds.l -
						                (element.scrollLeft + element.clientWidth));
						            if (scrollRightBy) {
						                element.scrollLeft += scrollRightBy;
						            }
						            var scrollLeftBy = Math.max(0, element.scrollLeft - bounds.l);
						            if (scrollLeftBy) {
						                element.scrollLeft -= scrollLeftBy;
						            }
						        }
						        textAreaContent = doc.selectedRange().plainText();
						        textArea.value = textAreaContent;
						        textArea.select();

						        setTimeout(function() {
						            textArea.focus();
						        }, 10);
						    };

						    doc.selectionChanged(function(getformatting, takeFocus) {
						        paint();
						        if (!selectDragStart) {
						            if (takeFocus !== false) {
						                updateTextArea();
						            }
						        }
						    });

						    function registerMouseEvent(name, handler) {
						        dom.handleMouseEvent(spacer, name, function(ev, x, y) {
						            handler(doc.byCoordinate(x, y - getVerticalOffset()));
						        });
						    }

						    registerMouseEvent('mousedown', function(node) {
						        selectDragStart = node.ordinal;
						        doc.select(node.ordinal, node.ordinal);
						        keyboardX = null;
						    });

						    registerMouseEvent('dblclick', function(node) {
						        node = node.parent();
						        if (node) {
						            doc.select(node.ordinal, node.ordinal +
						                (node.word ? node.word.text.length : node.length));
						        }
						    });

						    registerMouseEvent('mousemove', function(node) {
						        if (selectDragStart !== null) {
						            if (node) {
						                focusChar = node.ordinal;
						                if (selectDragStart > node.ordinal) {
						                    doc.select(node.ordinal, selectDragStart);
						                } else {
						                    doc.select(selectDragStart, node.ordinal);
						                }
						            }
						        }
						    });

						    registerMouseEvent('mouseup', function(node) {
						        selectDragStart = null;
						        keyboardX = null;
						        updateTextArea();
						        textArea.focus();
						    });

						    var nextCaretToggle = new Date().getTime(),
						        focused = false,
						        cachedWidth = element.clientWidth,
						        cachedHeight = element.clientHeight;

						    var update = function() {
						        var requirePaint = false;
						        var newFocused = document.activeElement === textArea;
						        if (focused !== newFocused) {
						            focused = newFocused;
						            requirePaint = true;
						        }

						        var now = new Date().getTime();
						        if (now > nextCaretToggle) {
						            nextCaretToggle = now + 500;
						            if (doc.toggleCaret()) {
						                requirePaint = true;
						            }
						        }

						        if (element.clientWidth !== cachedWidth ||
						            element.clientHeight !== cachedHeight) {
						            requirePaint = true;
						            cachedWidth =element.clientWidth;
						            cachedHeight = element.clientHeight;
						        }

						        if (requirePaint) {
						            paint();
						        }
						    };

						    dom.handleEvent(canvas, 'carotaEditorSharedTimer', update);
						    update();

						    doc.sendKey = handleKey;
						    return doc;
						};
					},
					"frame.js": function (exports, module, require) {
						var node = require('./node');
						var wrap = require('./wrap');
						var rect = require('./rect');

						var prototype = node.derive({
							bounds: function() {
								if (!this._bounds) {
									var left = 0, top = 0, right = 0, bottom = 0;
									if (this.lines.length) {
										var first = this.lines[0].bounds();
										left = first.l;
										top = first.t;
										this.lines.forEach(function(line) {
											var b = line.bounds();
											right = Math.max(right, b.l + b.w);
											bottom = Math.max(bottom, b.t + b.h);
										});
									}
									this._bounds = rect(left, top, right - left, this.height || bottom - top);
								}
								return this._bounds;
							},
							actualWidth: function() {
								if (!this._actualWidth) {
									var result = 0;
									this.lines.forEach(function(line) {
										if (typeof line.actualWidth === 'number') {
											result = Math.max(result, line.actualWidth);
										}
									});
									this._actualWidth = result;
								}
								return this._actualWidth;
							},
							children: function() {
								return this.lines;
							},
							parent: function() {
								return this._parent;
							},
							draw: function(ctx, viewPort) {
								var top = viewPort ? viewPort.t : 0;
								var bottom = viewPort ? (viewPort.t + viewPort.h) : Number.MAX_VALUE;
								this.lines.some(function(line) {
									var b = line.bounds();
									if (b.t + b.h < top) {
										return false;
									}
									if (b.t > bottom) {
										return true;
									}
									line.draw(ctx, viewPort);
								});
							},
							type: 'frame'
						});

						exports = module.exports = function(left, top, width, ordinal, parent,
															includeTerminator, initialAscent, initialDescent) {
							var lines = [];
							var frame = Object.create(prototype, {
								lines: { value: lines },
								_parent: { value: parent },
								ordinal: { value: ordinal }
							});
							var wrapper = wrap(left, top, width, ordinal, frame, includeTerminator, initialAscent, initialDescent);
							var length = 0, height = 0;
							return function(emit, word) {
								if (
									wrapper(
										function(line) {
											if (typeof line === 'number') {
												height = line;
											} else {
												length = (line.ordinal + line.length) - ordinal;
												lines.push(line);
											}
										}, word
									)
								) {
									Object.defineProperty(frame, 'length', { value: length });
									Object.defineProperty(frame, 'height', { value: height });
									emit(frame);
									return true;
								}
							};
						};
					},
					"html.js": function (exports, module, require) {
						var runs = require('./runs');
						var per = require('per');

						var tag = function(name, formattingProperty) {
						    return function(node, formatting) {
						        if (node.nodeName === name) {
						            formatting[formattingProperty] = true;
						        }
						    };
						};

						var value = function(type, styleProperty, formattingProperty, transformValue) {
						    return function(node, formatting) {
						        var val = node[type] && node[type][styleProperty];
						        if (val) {
						            if (transformValue) {
						                val = transformValue(val);
						            }
						            formatting[formattingProperty] = val;
						        }
						    };
						};

						var attrValue = function(styleProperty, formattingProperty, transformValue) {
						    return value('attributes', styleProperty, formattingProperty, transformValue);
						};

						var styleValue = function(styleProperty, formattingProperty, transformValue) {
						    return value('style', styleProperty, formattingProperty, transformValue);
						};

						var styleFlag = function(styleProperty, styleValue, formattingProperty) {
						    return function(node, formatting) {
						        if (node.style && node.style[styleProperty] === styleValue) {
						            formatting[formattingProperty] = true;
						        }
						    };
						};

						var obsoleteFontSizes = [ 6, 7, 9, 10, 12, 16, 20, 30 ];

						var aligns = { left: true, center: true, right: true, justify: true };

						var checkAlign = function(value) {
						    return aligns[value] ? value : 'left';
						};

						var fontName = function(name) {
						    var s = name.split(/\s*,\s*/g);
						    if (s.length == 0) {
						        return name;
						    }
						    name = s[0]
						    var raw = name.match(/^"(.*)"$/);
						    if (raw) {
						        return raw[1].trim();
						    }
						    raw = name.match(/^'(.*)'$/);
						    if (raw) {
						        return raw[1].trim();
						    }
						    return name;
						};

						var headings = {
						    H1: 30,
						    H2: 20,
						    H3: 16,
						    H4: 14,
						    H5: 12
						};

						var handlers = [
						    tag('B', 'bold'),
						    tag('STRONG', 'bold'),
						    tag('I', 'italic'),
						    tag('EM', 'italic'),
						    tag('U', 'underline'),
						    tag('S', 'strikeout'),
						    tag('STRIKE', 'strikeout'),
						    tag('DEL', 'strikeout'),
						    styleFlag('fontWeight', 'bold', 'bold'),
						    styleFlag('fontStyle', 'italic', 'italic'),
						    styleFlag('textDecoration', 'underline', 'underline'),
						    styleFlag('textDecoration', 'line-through', 'strikeout'),
						    styleValue('color', 'color'),
						    styleValue('fontFamily', 'font', fontName),
						    styleValue('fontSize', 'size', function(size) {
						        var m = size.match(/^([\d\.]+)pt$/);
						        return m ? parseFloat(m[1]) : 10
						    }),
						    styleValue('textAlign', 'align', checkAlign),
						    function(node, formatting) {
						        if (node.nodeName === 'SUB') {
						            formatting.script = 'sub';
						        }
						    },
						    function(node, formatting) {
						        if (node.nodeName === 'SUPER') {
						            formatting.script = 'super';
						        }
						    },
						    function(node, formatting) {
						        if (node.nodeName === 'CODE') {
						            formatting.font = 'monospace';
						        }
						    },
						    function(node, formatting) {
						        var size = headings[node.nodeName];
						        if (size) {
						            formatting.size = size;
						        }
						    },
						    attrValue('color', 'color'),
						    attrValue('face', 'font', fontName),
						    attrValue('align', 'align', checkAlign),
						    attrValue('size', 'size', function(size) {
						        return obsoleteFontSizes[size] || 10;
						    })
						];

						var newLines = [ 'BR', 'P', 'H1', 'H2', 'H3', 'H4', 'H5' ];
						var isNewLine = {};
						newLines.forEach(function(name) {
						    isNewLine[name] = true;
						});

						exports.parse = function(html, classes) {
						    var root = html;
						    if (typeof root === 'string') {
						        root = document.createElement('div');
						        root.innerHTML = html;
						    }

						    var result = [], inSpace = true;
						    var cons = per(runs.consolidate()).into(result);
						    var emit = function(text, formatting) {
						        cons.submit(Object.create(formatting, {
						            text: { value: text }
						        }));
						    };
						    var dealWithSpaces = function(text, formatting) {
						        text = text.replace(/\n+\s*/g, ' ');
						        var fullLength = text.length;
						        text = text.replace(/^\s+/, '');
						        if (inSpace) {
						            inSpace = false;
						        } else if (fullLength !== text.length) {
						            text = ' ' + text;
						        }
						        fullLength = text.length;
						        text = text.replace(/\s+$/, '');
						        if (fullLength !== text.length) {
						            inSpace = true;
						            text += ' ';
						        }
						        emit(text, formatting);
						    };

						    function recurse(node, formatting) {
						        if (node.nodeType == 3) {
						            dealWithSpaces(node.nodeValue, formatting);
						        } else {
						            formatting = Object.create(formatting);

						            var classNames = node.attributes['class'];
						            if (classNames) {
						                classNames.value.split(' ').forEach(function(cls) {
						                    cls = classes[cls];
						                    if (cls) {
						                        Object.keys(cls).forEach(function(key) {
						                            formatting[key] = cls[key];
						                        });
						                    }
						                })
						            }

						            handlers.forEach(function(handler) {
						                handler(node, formatting);
						            });
						            if (node.childNodes) {
						                for (var n = 0; n < node.childNodes.length; n++) {
						                    recurse(node.childNodes[n], formatting);
						                }
						            }
						            if (isNewLine[node.nodeName]) {
						                emit('\n', formatting);
						                inSpace = true;
						            }
						        }
						    }
						    recurse(root, {});
						    return result;
						};

					},
					"line.js": function (exports, module, require) {
						var positionedWord = require('./positionedword');
						var rect = require('./rect');
						var node = require('./node');
						var runs = require('./runs');

						/*  A Line is returned by the wrap function. It contains an array of PositionedWord objects that are
						    all on the same physical line in the wrapped text.

						     It has a width (which is actually the same for all lines returned by the same wrap). It also has
						     coordinates for baseline, ascent and descent. The ascent and descent have the maximum values of
						     the individual words' ascent and descent coordinates.

						    It has methods:

						        draw(ctx, x, y)
						                  - Draw all the words in the line applying the specified (x, y) offset.
						        bounds()
						                  - Returns a Rect for the bounding box.
						 */

						var prototype = node.derive({
						    bounds: function(minimal) {
						        if (minimal) {
						            var firstWord = this.first().bounds(),
						                lastWord = this.last().bounds();
						            return rect(
						                firstWord.l,
						                this.baseline - this.ascent,
						                (lastWord.l + lastWord.w) - firstWord.l,
						                this.ascent + this.descent);
						        }
						        return rect(this.left, this.baseline - this.ascent,
						            this.width, this.ascent + this.descent);
						    },
						    parent: function() {
						        return this.doc;
						    },
						    children: function() {
						        return this.positionedWords;
						    },
						    type: 'line'
						});

						module.exports = function(doc, left, width, baseline, ascent, descent, words, ordinal) {

						    var align = words[0].align();

						    var line = Object.create(prototype, {
						        doc: { value: doc }, // should be called frame, or else switch to using parent on all nodes
						        left: { value: left },
						        width: { value: width },
						        baseline: { value: baseline },
						        ascent: { value: ascent },
						        descent: { value: descent },
						        ordinal: { value: ordinal },
						        align: { value: align }
						    });

						    var actualWidth = 0;
						    words.forEach(function(word) {
						        actualWidth += word.width;
						    });
						    actualWidth -= words[words.length - 1].space.width;

						    var x = 0, spacing = 0;
						    if (actualWidth < width) {
						        switch (align) {
						            case 'right':
						                x = width - actualWidth;
						                break;
						            case 'center':
						                x = (width - actualWidth) / 2;
						                break;
						            case 'justify':
						                if (words.length > 1 && !words[words.length - 1].isNewLine()) {
						                    spacing = (width - actualWidth) / (words.length - 1);
						                }
						                break;
						        }
						    }

						    Object.defineProperty(line, 'positionedWords', {
						        value: words.map(function(word) {
						            var wordLeft = x;
						            x += (word.width + spacing);
						            var wordOrdinal = ordinal;
						            ordinal += (word.text.length + word.space.length);
						            return positionedWord(word, line, wordLeft, wordOrdinal, word.width + spacing);
						        })
						    });

						    Object.defineProperty(line, 'actualWidth', { value: actualWidth });
						    Object.defineProperty(line, 'length', { value: ordinal - line.ordinal });
						    return line;
						};
					},
					"node.js": function (exports, module, require) {
						var per = require('per');
						//var runs = require('./runs');
						var rect = require('./rect');
						var util = require('./util');

						exports.prototype = {
						    children: function() {
						        return [];
						    },
						    parent: function() {
						        return null;
						    },
						    first: function() {
						        return this.children()[0];
						    },
						    last: function() {
						        return this.children()[this.children().length - 1];
						    },
						    next: function() {
						        var self = this;
						        for (;;) {
						            var parent = self.parent();
						            if (!parent) {
						                return null;
						            }
						            var siblings = parent.children();
						            var next = siblings[siblings.indexOf(self) + 1];
						            if (next) {
						                for (;;)  {
						                    var first = next.first();
						                    if (!first) {
						                        break;
						                    }
						                    next = first;
						                }
						                return next;
						            }
						            self = parent;
						        }
						    },
						    previous: function() {
						        var parent = this.parent();
						        if (!parent) {
						            return null;
						        }
						        var siblings = parent.children();
						        var prev = siblings[siblings.indexOf(this) - 1];
						        if (prev) {
						            return prev;
						        }
						        var prevParent = parent.previous();
						        return !prevParent ? null : prevParent.last();
						    },
						    byOrdinal: function(index) {
						        var found = null;
						        if (this.children().some(function(child) {
						            if (index >= child.ordinal && index < child.ordinal + child.length) {
						                found = child.byOrdinal(index);
						                if (found) {
						                    return true;
						                }
						            }
						        })) {
						            return found;
						        }
						        return this;
						    },
						    byCoordinate: function(x, y) {
						        var found;
						        this.children().some(function(child) {
						            var b = child.bounds();
						            if (b.contains(x, y)) {
						                found = child.byCoordinate(x, y);
						                if (found) {
						                    return true;
						                }
						            }
						        });
						        if (!found) {
						            found = this.last();
						            while (found) {
						                var next = found.last();
						                if (!next) {
						                    break;
						                }
						                found = next;
						            }
						            var foundNext = found.next();
						            if (foundNext && foundNext.block) {
						                found = foundNext;
						            }
						        }
						        return found;
						    },
						    draw: function(ctx, viewPort) {
						        this.children().forEach(function(child) {
						            child.draw(ctx, viewPort);
						        });
						    },
						    parentOfType: function(type) {
						        var p = this.parent();
						        return p && (p.type === type ? p : p.parentOfType(type));
						    },
						    bounds: function() {
						        var l = this._left, t = this._top, r = 0, b = 0;
						        this.children().forEach(function(child) {
						            var cb = child.bounds();
						            l = Math.min(l, cb.l);
						            t = Math.min(t, cb.t);
						            r = Math.max(r, cb.l + cb.w);
						            b = Math.max(b, cb.t + cb.h);
						        });
						        return rect(l, t, r - l, b - t);
						    }
						};

						exports.derive = function(methods) {
						    return util.derive(exports.prototype, methods);
						};

						var generic = exports.derive({
						    children: function() {
						        return this._children;
						    },
						    parent: function() {
						        return this._parent;
						    },
						    finalize: function(startDecrement, lengthIncrement) {
						        var start = Number.MAX_VALUE, end = 0;
						        this._children.forEach(function(child) {
						            start = Math.min(start, child.ordinal);
						            end = Math.max(end, child.ordinal + child.length);
						        });
						        Object.defineProperty(this, 'ordinal', { value: start - (startDecrement || 0) });
						        Object.defineProperty(this, 'length', { value: (lengthIncrement || 0) + end - start });
						    }
						});

						exports.generic = function(type, parent, left, top) {
						    return Object.create(generic, {
						        type: { value: type },
						        _children: { value: [] },
						        _parent: { value: parent },
						        _left: { value: typeof left === 'number' ? left : Number.MAX_VALUE },
						        _top: { value: typeof top === 'number' ? top : Number.MAX_VALUE }
						    });
						};
					},
					"part.js": function (exports, module, require) {
						var text = require('./text');

						var defaultInline = {
						    measure: function(formatting) {
						        var text = text.measure('?', formatting);
						        return {
						            width: text.width + 4,
						            ascent: text.width + 2,
						            descent: text.width + 2
						        };
						    },
						    draw: function(ctx, x, y, width, ascent, descent) {
						        ctx.fillStyle = 'silver';
						        ctx.fillRect(x, y - ascent, width, ascent + descent);
						        ctx.strokeRect(x, y - ascent, width, ascent + descent);
						        ctx.fillStyle = 'black';
						        ctx.fillText('?', x + 2, y);
						    }
						};

						/*  A Part is a section of a word with its own run, because a Word can span the
						    boundaries between runs, so it may have several parts in its text or space
						    arrays.

						        run           - Run being measured.
						        isNewLine     - True if this part only contain a newline (\n). This will be
						                        the only Part in the Word, and this is the only way newlines
						                        ever occur.
						        width         - Width of the run
						        ascent        - Distance from baseline to top
						        descent       - Distance from baseline to bottom

						    And methods:

						        draw(ctx, x, y)
						                      - Draws the Word at x, y on the canvas context ctx. The y
						                        coordinate is assumed to be the baseline. The call
						                        prepareContext(ctx) will set the canvas up appropriately.
						 */
						var prototype = {
						    draw: function(ctx, x, y) {
						        if (typeof this.run.text === 'string') {
						            text.draw(ctx, this.run.text, this.run, x, y, this.width, this.ascent, this.descent);
						        } else if (this.code && this.code.draw) {
						            ctx.save();
						            this.code.draw(ctx, x, y, this.width, this.ascent, this.descent, this.run);
						            ctx.restore();
						        }
						    }
						};

						module.exports = function(run, codes) {

						    var m, isNewLine, code;
						    if (typeof run.text === 'string') {
						        isNewLine = (run.text.length === 1) && (run.text[0] === '\n');
						        m = text.measure(isNewLine ? text.nbsp : run.text, run);
						    } else {
						        code = codes(run.text) || defaultInline;
						        m = code.measure ? code.measure(run) : {
						            width: 0, ascent: 0, descent: 0
						        };
						    }

						    var part = Object.create(prototype, {
						        run: { value: run },
						        isNewLine: { value: isNewLine },
						        width: { value: isNewLine ? 0 : m.width },
						        ascent: { value: m.ascent },
						        descent: { value: m.descent }
						    });
						    if (code) {
						        Object.defineProperty(part, 'code', { value: code });
						    }
						    return part;
						};
					},
					"positionedword.js": function (exports, module, require) {
						var rect = require('./rect');
						var part = require('./part');
						var text = require('./text');
						var node = require('./node');
						var word = require('./word');
						var runs = require('./runs');

						var newLineWidth = function(run) {
						    return text.measure(text.enter, run).width;
						};

						var positionedChar = node.derive({
						    bounds: function() {
						        var wb = this.word.bounds();
						        var width = this.word.word.isNewLine()
						            ? newLineWidth(this.word.word.run)
						            : this.width || this.part.width;
						        return rect(wb.l + this.left, wb.t, width, wb.h);
						    },
						    parent: function() {
						        return this.word;
						    },
						    byOrdinal: function() {
						        return this;
						    },
						    byCoordinate: function(x, y) {
						        if (x <= this.bounds().center().x) {
						            return this;
						        }
						        return this.next();
						    },
						    type: 'character'
						});

						/*  A positionedWord is just a realised Word plus a reference back to the containing Line and
						    the left coordinate (x coordinate of the left edge of the word).

						    It has methods:

						        draw(ctx, x, y)
						                  - Draw the word within its containing line, applying the specified (x, y)
						                    offset.
						        bounds()
						                  - Returns a rect for the bounding box.
						 */
						var prototype = node.derive({
						    draw: function(ctx) {
						        this.word.draw(ctx, this.line.left + this.left, this.line.baseline);

						        // Handy for showing how word boundaries work
						        // var b = this.bounds();
						        // ctx.strokeRect(b.l, b.t, b.w, b.h);
						    },
						    bounds: function() {
						        return rect(
						            this.line.left + this.left,
						            this.line.baseline - this.line.ascent,
						            this.word.isNewLine() ? newLineWidth(this.word.run) : this.width,
						            this.line.ascent + this.line.descent);
						    },
						    parts: function(eachPart) {
						        this.word.text.parts.some(eachPart) ||
						        this.word.space.parts.some(eachPart);
						    },
						    realiseCharacters: function() {
						        if (!this._characters) {
						            var cache = [];
						            var x = 0, self = this, ordinal = this.ordinal,
						                codes = this.parentOfType('document').codes;
						            this.parts(function(wordPart) {
						                runs.pieceCharacters(function(char) {
						                    var charRun = Object.create(wordPart.run);
						                    charRun.text = char;
						                    var p = part(charRun, codes);
						                    cache.push(Object.create(positionedChar, {
						                        left: { value: x },
						                        part: { value: p },
						                        word: { value: self },
						                        ordinal: { value: ordinal },
						                        length: { value: 1 }
						                    }));
						                    x += p.width;
						                    ordinal++;
						                }, wordPart.run.text);
						            });
						            // Last character is artificially widened to match the length of the
						            // word taking into account (align === 'justify')
						            var lastChar = cache[cache.length - 1];
						            if (lastChar) {
						                Object.defineProperty(lastChar, 'width',
						                    { value: this.width - lastChar.left });
						                if (this.word.isNewLine() || (this.word.code() && this.word.code().eof)) {
						                    Object.defineProperty(lastChar, 'newLine', { value: true });
						                }
						            }
						            this._characters = cache;
						        }
						    },
						    children: function() {
						        this.realiseCharacters();
						        return this._characters;
						    },
						    parent: function() {
						        return this.line;
						    },
						    type: 'word'
						});

						module.exports = function(word, line, left, ordinal, width) {
						    var pword = Object.create(prototype, {
						        word: { value: word },
						        line: { value: line },
						        left: { value: left },
						        width: { value: width }, // can be different to word.width if (align == 'justify')
						        ordinal: { value: ordinal },
						        length: { value: word.text.length + word.space.length }
						    });
						    return pword;
						};
					},
					"range.js": function (exports, module, require) {
						var per = require('per');
						var runs = require('./runs');

						function Range(doc, start, end) {
						    this.doc = doc;
						    this.start = start;
						    this.end = end;
						    if (start > end) {
						        this.start = end;
						        this.end = start;
						    }
						}

						Range.prototype.parts = function(emit, list) {
						    list = list || this.doc.children();
						    var self = this;

						    list.some(function(item) {
						        if (item.ordinal + item.length <= self.start) {
						            return false;
						        }
						        if (item.ordinal >= self.end) {
						            return true;
						        }
						        if (item.ordinal >= self.start &&
						            item.ordinal + item.length <= self.end) {
						            emit(item);
						        } else {
						            self.parts(emit, item.children());
						        }
						    });
						};

						Range.prototype.clear = function() {
						    return this.setText([]);
						};

						Range.prototype.setText = function(text) {
						    return this.doc.splice(this.start, this.end, text);
						};

						Range.prototype.runs = function(emit) {
						    this.doc.runs(emit, this);
						};

						Range.prototype.plainText = function() {
						    return per(this.runs, this).map(runs.getPlainText).all().join('');
						};

						Range.prototype.save = function() {
						    return per(this.runs, this).per(runs.consolidate()).all();
						};

						Range.prototype.getFormatting = function() {
						    var range = this;
						    if (range.start === range.end) {
						        var pos = range.start;
						        // take formatting of character before, if any, because that's
						        // where plain text picks up formatting when inserted
						        if (pos > 0) {
						            pos--;
						        }
						        range.start = pos;
						        range.end = pos + 1;
						    }
						    return per(range.runs, range).reduce(runs.merge).last() || runs.defaultFormatting;
						};

						Range.prototype.setFormatting = function(attribute, value) {
						    var range = this;
						    if (attribute === 'align') {
						        // Special case: expand selection to surrounding paragraphs
						        range = range.doc.paragraphRange(range.start, range.end);
						    }
						    if (range.start === range.end) {
						        range.doc.modifyInsertFormatting(attribute, value);
						    } else {
						        var saved = range.save();
						        var template = {};
						        template[attribute] = value;
						        runs.format(saved, template);
						        range.setText(saved);
						    }
						};

						module.exports = function(doc, start, end) {
						    return new Range(doc, start, end);
						};
					},
					"rect.js": function (exports, module, require) {
						
						var prototype = {
						    contains: function(x, y) {
						        return x >= this.l && x < (this.l + this.w) &&
						            y >= this.t && y < (this.t + this.h);

						    },
						    stroke: function(ctx) {
						        ctx.strokeRect(this.l, this.t, this.w, this.h);
						    },
						    fill: function(ctx) {
						        ctx.fillRect(this.l, this.t, this.w, this.h);
						    },
						    offset: function(x, y) {
						        return rect(this.l + x, this.t + y, this.w, this.h);
						    },
						    equals: function(other) {
						        return this.l === other.l && this.t === other.t &&
						               this.w === other.w && this.h === other.h;
						    },
						    center: function() {
						        return { x: this.l + this.w/2, y: this.t + this.h/2 };
						    }
						};

						var rect = module.exports = function(l, t, w, h) {
						    return Object.create(prototype, {
						        l: { value: l },
						        t: { value: t },
						        w: { value: w },
						        h: { value: h },
						        r: { value: l + w },
						        b: { value: t + h }
						    });
						};
					},
					"runs.js": function (exports, module, require) {
						exports.formattingKeys = [ 'bold', 'italic', 'underline', 'strikeout', 'color', 'font', 'size', 'align', 'script' ];

						exports.defaultFormatting = {
						    size: 10,
						    font: 'sans-serif',
						    color: 'black',
						    bold: false,
						    italic: false,
						    underline: false,
						    strikeout: false,
						    align: 'left',
						    script: 'normal'
						};

						exports.sameFormatting = function(run1, run2) {
						    return exports.formattingKeys.every(function(key) {
						        return run1[key] === run2[key];
						    })
						};

						exports.clone = function(run) {
						    var result = { text: run.text };
						    exports.formattingKeys.forEach(function(key) {
						        var val = run[key];
						        if (val && val != exports.defaultFormatting[key]) {
						            result[key] = val;
						        }
						    });
						    return result;
						};

						exports.multipleValues = {};

						exports.merge = function(run1, run2) {
						    if (arguments.length === 1) {
						        return Array.isArray(run1) ? run1.reduce(exports.merge) : run1;
						    }
						    if (arguments.length > 2) {
						        return exports.merge(Array.prototype.slice.call(arguments, 0));
						    }
						    var merged = {};
						    exports.formattingKeys.forEach(function(key) {
						        if (key in run1 || key in run2) {
						            if (run1[key] === run2[key]) {
						                merged[key] = run1[key];
						            } else {
						                merged[key] = exports.multipleValues;
						            }
						        }
						    });
						    return merged;
						};

						exports.format = function(run, template) {
						    if (Array.isArray(run)) {
						        run.forEach(function(r) {
						            exports.format(r, template);
						        });
						    } else {
						        Object.keys(template).forEach(function(key) {
						            if (template[key] !== exports.multipleValues) {
						                run[key] = template[key];
						            }
						        });
						    }
						};

						exports.consolidate = function() {
						    var current;
						    return function(emit, run) {
						        if (!current || !exports.sameFormatting(current, run) ||
						            (typeof current.text != 'string') ||
						            (typeof run.text != 'string')) {
						            current = exports.clone(run);
						            emit(current);
						        } else {
						            current.text += run.text;
						        }
						    };
						};

						exports.getPlainText = function(run) {
						    if (typeof run.text === 'string') {
						        return run.text;
						    }
						    if (Array.isArray(run.text)) {
						        var str = [];
						        run.text.forEach(function(piece) {
						            str.push(exports.getPiecePlainText(piece));
						        });
						        return str.join('');
						    }
						    return '_';
						};

						/*  The text property of a run can be an ordinary string, or a "character object",
						 or it can be an array containing strings and "character objects".

						 A character object is not a string, but is treated as a single character.

						 We abstract over this to provide the same string-like operations regardless.
						 */
						exports.getPieceLength = function(piece) {
						    return piece.length || 1; // either a string or something like a character
						};

						exports.getPiecePlainText = function(piece) {
						    return piece.length ? piece : '_';
						};

						exports.getTextLength = function(text) {
						    if (typeof text === 'string') {
						        return text.length;
						    }
						    if (Array.isArray(text)) {
						        var length = 0;
						        text.forEach(function(piece) {
						            length += exports.getPieceLength(piece);
						        });
						        return length;
						    }
						    return 1;
						};

						exports.getSubText = function(emit, text, start, count) {
						    if (count === 0) {
						        return;
						    }
						    if (typeof text === 'string') {
						        emit(text.substr(start, count));
						        return;
						    }
						    if (Array.isArray(text)) {
						        var pos = 0;
						        text.some(function(piece) {
						            if (count <= 0) {
						                return true;
						            }
						            var pieceLength = exports.getPieceLength(piece);
						            if (pos + pieceLength > start) {
						                if (pieceLength === 1) {
						                    emit(piece);
						                    count -= 1;
						                } else {
						                    var str = piece.substr(Math.max(0, start - pos), count);
						                    emit(str);
						                    count -= str.length;
						                }
						            }
						            pos += pieceLength;
						        });
						        return;
						    }
						    emit(text);
						};

						exports.getTextChar = function(text, offset) {
						    var result;
						    exports.getSubText(function(c) { result = c }, text, offset, 1);
						    return result;
						};

						exports.pieceCharacters = function(each, piece) {
						    if (typeof piece === 'string') {
						        for (var c = 0; c < piece.length; c++) {
						            each(piece[c]);
						        }
						    } else {
						        each(piece);
						    }
						};
					},
					"split.js": function (exports, module, require) {
						/*  Creates a stateful transformer function that consumes Characters and produces "word coordinate"
							objects, which are triplets of Characters representing the first characters of:

								 start   - the word itself
								 end	 - any trailing whitespace
								 next	- the subsequent word, or end of document.

							 Newline characters are NOT whitespace. They are always emitted as separate single-character
							 words.

							If start.equals(end) then the "word" only contains whitespace and so must represent spaces
							at the start of a line. So even in this case, whitespace is always treated as "trailing
							after" a word - even if that word happens to be zero characters long!
						 */

						module.exports = function(codes) {

							var word = null, trailingSpaces = null, newLine = true;

							return function(emit, inputChar) {

								var endOfWord;
								if (inputChar.char === null) {
									endOfWord = true;
								} else {
									if (newLine) {
										endOfWord = true;
										newLine = false;
									}
									if (typeof inputChar.char === 'string') {
										switch (inputChar.char) {
											case ' ':
												if (!trailingSpaces) {
													trailingSpaces = inputChar;
												}
												break;
											case '\n':
												endOfWord = true;
												newLine = true;
												break;
											default:
												if (trailingSpaces) {
													endOfWord = true;
												}
										}
									} else {
										var code = codes(inputChar.char);
										if (code.block || code.eof) {
											endOfWord = true;
											newLine = true;
										} 
									}
								}
								if (endOfWord) {
									if (word && !word.equals(inputChar)) {
										if (emit({
											text: word,
											spaces: trailingSpaces || inputChar,
											end: inputChar
										}) === false) {
											return false;
										}
										trailingSpaces = null;
									}
									if (inputChar.char === null) {
										emit(null); // Indicate end of stream
									}

									word = inputChar;
								}
							};
						};
					},
					"text.js": function (exports, module, require) {
						var runs = require('./runs');

						/*  Returns a font CSS/Canvas string based on the settings in a run
						 */
						var getFontString = exports.getFontString = function(run) {

							var size = (run && run.size) || runs.defaultFormatting.size;

							if (run) {
								switch (run.script) {
									case 'super':
									case 'sub':
										size *= 0.8;
										break;
								}
							}

							return (run && run.italic ? 'italic ' : '') +
								   (run && run.bold ? 'bold ' : '') + ' ' +
									size + 'pt ' +
								  ((run && run.font) || runs.defaultFormatting.font);
						};

						/*  Applies the style of a run to the canvas context
						 */
						exports.applyRunStyle = function(ctx, run) {
							ctx.fillStyle = (run && run.color) || runs.defaultFormatting.color;
							ctx.font = getFontString(run);
						};

						exports.prepareContext = function(ctx) {
							ctx.textAlign = 'left';
							ctx.textBaseline = 'alphabetic';
						};

						/* Generates the value for a CSS style attribute
						 */
						exports.getRunStyle = function(run) {
							var parts = [
								'font: ', getFontString(run),
							  '; color: ', ((run && run.color) || runs.defaultFormatting.color)
							];

							if (run) {
								switch (run.script) {
									case 'super':
										parts.push('; vertical-align: super');
										break;
									case 'sub':
										parts.push('; vertical-align: sub');
										break;
								}
							}

							return parts.join('');
						};

						var nbsp = exports.nbsp = String.fromCharCode(160);
						var enter = exports.enter = nbsp; // String.fromCharCode(9166);

						/*  Returns width, height, ascent, descent in pixels for the specified text and font.
							The ascent and descent are measured from the baseline. Note that we add/remove
							all the DOM elements used for a measurement each time - this is not a significant
							part of the cost, and if we left the hidden measuring node in the DOM then it
							would affect the dimensions of the whole page.
						 */
						var measureText = exports.measureText = function(text, style) {
							var span, block, div;

							span = document.createElement('span');
							block = document.createElement('div');
							div = document.createElement('div');

							block.style.display = 'inline-block';
							block.style.width = '1px';
							block.style.height = '0';

							div.style.visibility = 'hidden';
							div.style.position = 'absolute';
							div.style.top = '0';
							div.style.left = '0';
							div.style.width = '500px';
							div.style.height = '200px';

							div.appendChild(span);
							div.appendChild(block);
							document.body.appendChild(div);
							try {
								span.setAttribute('style', style);

								span.innerHTML = '';
								span.appendChild(document.createTextNode(text.replace(/\s/g, nbsp)));

								var result = {};
								block.style.verticalAlign = 'baseline';
								result.ascent = (block.offsetTop - span.offsetTop);
								block.style.verticalAlign = 'bottom';
								result.height = (block.offsetTop - span.offsetTop);
								result.descent = result.height - result.ascent;
								result.width = span.offsetWidth;
							} finally {
								div.parentNode.removeChild(div);
								div = null;
							}
							return result;
						};

						/*  Create a function that works like measureText except it caches every result for every
							unique combination of (text, style) - that is, it memoizes measureText.

							So for example:

								var measure = cachedMeasureText();

							Then you can repeatedly do lots of separate calls to measure, e.g.:

								var m = measure('Hello, world', 'font: 12pt Arial');
								console.log(m.ascent, m.descent, m.width);

							A cache may grow without limit if the text varies a lot. However, during normal interactive
							editing the growth rate will be slow. If memory consumption becomes a problem, the cache
							can be occasionally discarded, although of course this will cause a slow down as the cache
							has to build up again (text measuring is by far the most costly operation we have to do).
						*/
						var createCachedMeasureText = exports.createCachedMeasureText = function() {
							var cache = {};
							return function(text, style) {
								var key = style + '<>!&%' + text;
								var result = cache[key];
								if (!result) {
									cache[key] = result = measureText(text, style);
								}
								return result;
							};
						};

						exports.cachedMeasureText = createCachedMeasureText();

						exports.measure = function(str, formatting) {
							return exports.cachedMeasureText(str, exports.getRunStyle(formatting));
						};

						exports.draw = function(ctx, str, formatting, left, baseline, width, ascent, descent) {
							exports.prepareContext(ctx);
							exports.applyRunStyle(ctx, formatting);
							switch (formatting.script) {
								case 'super':
									baseline -= (ascent * (1/3));
									break;
								case 'sub':
									baseline += (descent / 2);
									break;
							}
							ctx.fillText(str === '\n' ? exports.enter : str, left, baseline);
							if (formatting.underline) {
								ctx.fillRect(left, 1 + baseline, width, 1);
							}
							if (formatting.strikeout) {
								ctx.fillRect(left, 1 + baseline - (ascent/2), width, 1);
							}
						};
					},
					"util.js": function (exports, module, require) {
						exports.event = function() {
						    var handlers = [];

						    var subscribe = function(handler) {
						        handlers.push(handler);
						    };

						    subscribe.fire = function() {
						        var args = Array.prototype.slice.call(arguments, 0);
						        handlers.forEach(function(handler) {
						            handler.apply(null, args);
						        });
						    };

						    return subscribe;
						};

						exports.derive = function(prototype, methods) {
						    var properties = {};
						    Object.keys(methods).forEach(function(name) {
						        properties[name] = { value: methods[name] };
						    });
						    return Object.create(prototype, properties);
						};
					},
					"word.js": function (exports, module, require) {
						var per = require('per');
						var part = require('./part');
						var runs = require('./runs');

						/*  A Word has the following properties:

						        text      - Section (see below) for non-space portion of word.
						        space     - Section for trailing space portion of word.
						        ascent    - Ascent (distance from baseline to top) for whole word
						        descent   - Descent (distance from baseline to bottom) for whole word
						        width     - Width of the whole word (including trailing space)

						    It has methods:

						        isNewLine()
						                  - Returns true if the Word represents a newline. Newlines are
						                    always represented by separate words.

						        draw(ctx, x, y)
						                  - Draws the Word at x, y on the canvas context ctx.

						    Note: a section (i.e. text and space) is an object containing:

						        parts     - array of Parts
						        ascent    - Ascent (distance from baseline to top) for whole section
						        descent   - Descent (distance from baseline to bottom) for whole section
						        width     - Width of the whole section
						 */

						var prototype = {
						    isNewLine: function() {
						        return this.text.parts.length == 1 && this.text.parts[0].isNewLine;
						    },
						    code: function() {
						        return this.text.parts.length == 1 && this.text.parts[0].code;
						    },
						    codeFormatting: function() {
						        return this.text.parts.length == 1 && this.text.parts[0].run;
						    },
						    draw: function(ctx, x, y) {
						        per(this.text.parts).concat(this.space.parts).forEach(function(part) {
						            part.draw(ctx, x, y);
						            x += part.width;
						        });
						    },
						    plainText: function() {
						        return this.text.plainText + this.space.plainText;
						    },
						    align: function() {
						        var first = this.text.parts[0];
						        return first ? first.run.align : 'left';
						    },
						    runs: function(emit, range) {
						        var start = range && range.start || 0,
						            end = range && range.end;
						        if (typeof end !== 'number') {
						            end = Number.MAX_VALUE;
						        }
						        [this.text, this.space].forEach(function(section) {
						            section.parts.some(function(part) {
						                if (start >= end || end <= 0) {
						                    return true;
						                }
						                var run = part.run, text = run.text;
						                if (typeof text === 'string') {
						                    if (start <= 0 && end >= text.length) {
						                        emit(run);
						                    } else if (start < text.length) {
						                        var pieceRun = Object.create(run);
						                        var firstChar = Math.max(0, start);
						                        pieceRun.text = text.substr(
						                            firstChar,
						                            Math.min(text.length, end - firstChar)
						                        );
						                        emit(pieceRun);
						                    }
						                    start -= text.length;
						                    end -= text.length;
						                } else {
						                    if (start <= 0 && end >= 1) {
						                        emit(run);
						                    }
						                    start--;
						                    end--;
						                }
						            });
						        });
						    }
						};

						var section = function(runEmitter, codes) {
						    var s = {
						        parts: per(runEmitter).map(function(p) {
						            return part(p, codes);
						        }).all(),
						        ascent: 0,
						        descent: 0,
						        width: 0,
						        length: 0,
						        plainText: ''
						    };
						    s.parts.forEach(function(p) {
						        s.ascent = Math.max(s.ascent, p.ascent);
						        s.descent = Math.max(s.descent, p.descent);
						        s.width += p.width;
						        s.length += runs.getPieceLength(p.run.text);
						        s.plainText += runs.getPiecePlainText(p.run.text);
						    });
						    return s;
						};

						module.exports = function(coords, codes) {
						    var text, space;
						    if (!coords) {
						        // special end-of-document marker, mostly like a newline with no formatting
						        text = [{ text: '\n' }];
						        space = [];
						    } else {
						        text = coords.text.cut(coords.spaces);
						        space = coords.spaces.cut(coords.end);
						    }
						    text = section(text, codes);
						    space = section(space, codes);
						    var word = Object.create(prototype, {
						        text: { value: text },
						        space: { value: space },
						        ascent: { value: Math.max(text.ascent, space.ascent) },
						        descent: { value: Math.max(text.descent, space.descent) },
						        width: { value: text.width + space.width, configurable: true },
						        length: { value: text.length + space.length }
						    });
						    if (!coords) {
						        Object.defineProperty(word, 'eof', { value: true });
						    }
						    return word;
						};
					},
					"wrap.js": function (exports, module, require) {
						var line = require('./line');

						/*  A stateful transformer function that accepts words and emits lines. If the first word
						    is too wide, it will overhang; if width is zero or negative, there will be one word on
						    each line.

						    The y-coordinate is the top of the first line, not the baseline.

						    Returns a stream of line objects, each containing an array of positionedWord objects.
						 */

						module.exports = function(left, top, width, ordinal, parent,
						                          includeTerminator, initialAscent, initialDescent) {

						    var lineBuffer = [],
						        lineWidth = 0,
						        maxAscent = initialAscent || 0,
						        maxDescent = initialDescent || 0,
						        quit,
						        lastNewLineHeight = 0,
						        y = top;

						    var store = function(word, emit) {
						        lineBuffer.push(word);
						        lineWidth += word.width;
						        maxAscent = Math.max(maxAscent, word.ascent);
						        maxDescent = Math.max(maxDescent, word.descent);
						        if (word.isNewLine()) {
						            send(emit);
						            lastNewLineHeight = word.ascent + word.descent;
						        }
						    };

						    var send = function(emit) {
						        if (quit || lineBuffer.length === 0) {
						            return;
						        }
						        var l = line(parent, left, width, y + maxAscent, maxAscent, maxDescent, lineBuffer, ordinal);
						        ordinal += l.length;
						        quit = emit(l);
						        y += (maxAscent + maxDescent);
						        lineBuffer.length = 0;
						        lineWidth = maxAscent = maxDescent = 0;
						    };

						    var consumer = null;

						    return function(emit, inputWord) {
						        if (consumer) {
						            lastNewLineHeight = 0;
						            var node = consumer(inputWord);
						            if (node) {
						                consumer = null;
						                ordinal += node.length;
						                y += node.bounds().h;
						                Object.defineProperty(node, 'block', { value: true });
						                emit(node);
						            }
						        } else {
						            var code = inputWord.code();
						            if (code && code.block) {
						                if (lineBuffer.length) {
						                    send(emit);
						                } else {
						                    y += lastNewLineHeight;
						                }
						                consumer = code.block(left, y, width, ordinal, parent, inputWord.codeFormatting());
						                lastNewLineHeight = 0;
						            }
						            else if (code && code.eof || inputWord.eof) {
						                if (!code || (includeTerminator && includeTerminator(code))) {
						                    store(inputWord, emit);
						                }
						                if (!lineBuffer.length) {
						                    emit(y + lastNewLineHeight - top);
						                } else {
						                    send(emit);
						                    emit(y - top);
						                }
						                quit = true;
						            } else {
						                lastNewLineHeight = 0;
						                if (!lineBuffer.length) {
						                    store(inputWord, emit);
						                } else {
						                    if (lineWidth + inputWord.text.width > width) {
						                        send(emit);
						                    }
						                    store(inputWord, emit);
						                }
						            }
						        }
						        return quit;
						    };
						};
					}
				},
				"common": {
					"base": {
						"hp_SE2M_Menubar.js": function (exports, module, require) {
							/**
							 * @desc
							 */
							nhn.husky.SE2M_Menubar = jindo.$Class({
								name: "SE2M_Menubar",

								menubarArea: null,
								menubarTitle: null,
								menubarItem: null,

								_assignHTMLElements: function(container) {
									this.container = jindo.$(container) || document;
									this.menubarArea = jindo.$$.getSingle(".menu_bar", container);

									this.menus = jindo.$$(">[class*=menu_]", this.menubarArea);
									console.log("this.menus.length = " + this.menus.length);
									for (var i = 0; i < this.menus.length; i++) {
										if (new RegExp("menu_([^ ]+)").test(this.menus[i].className)) {
											var menuName = RegExp.$1;
											var items = jindo.$$("[class*=item_]", this.menus[i]);
											console.log("items.length = " + items.length);
											for (var j = 0; j < items.length; j++) {
												if (new RegExp("item_([^ ]+)").test(items[j].className)) {
													var itemName = RegExp.$1;
													//console.log("" + menuName+"_"+itemName);
													this.items[menuName+"_"+itemName] = items[j];
												}
											}
										}
									}
								},

								$init: function(container, options) {
									this._options = options || {};
									this.items = {};
									this._assignHTMLElements(container);
								},

								$ON_MSG_APP_READY: function() {
									
								},

								$ON_REGISTER_MENU_EVENT: function(sName, sEvent, sCmd, aParams) {
									var elButton;
									elButton = jindo.$Element(this.items[sName]);
									if (!elButton) return;
									this.oApp.registerBrowserEvent(elButton, sEvent, sCmd, aParams);
								},

							});
						}
					}
				},
				"fundamental": {
					"base": {
						"hp_SE2M_ExecCommand.js": function (exports, module, require) {
							/*
							Copyright (C) NAVER corp.  

							This library is free software; you can redistribute it and/or  
							modify it under the terms of the GNU Lesser General Public  
							License as published by the Free Software Foundation; either  
							version 2.1 of the License, or (at your option) any later version.  

							This library is distributed in the hope that it will be useful,  
							but WITHOUT ANY WARRANTY; without even the implied warranty of  
							MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  
							Lesser General Public License for more details.  

							You should have received a copy of the GNU Lesser General Public  
							License along with this library; if not, write to the Free Software  
							Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA  
							*/
							//{
							/**
							 * @fileOverview This file contains Husky plugin that takes care of the basic editor commands
							 * @name hp_SE_ExecCommand.js
							 */
							nhn.husky.SE2M_ExecCommand = jindo.$Class({
								name:"SE2M_ExecCommand",

								$init: function(elAppContainer) {
									this.$file = $("input[type=file]");
									this.$file.on("change", function() {
										//document.loadForm.submit();
									});
								},

								$BEFORE_MSG_APP_READY: function() {
								},

								$ON_MSG_APP_READY: function() {
									this.oApp.exec("REGISTER_MENU_EVENT", ["FILE_LOAD", "click", "EXECCOMMAND", ["FILE_LOAD", false, false]]);
									this.oApp.exec("REGISTER_MENU_EVENT", ["FILE_DOWNLOAD", "click", "EXECCOMMAND", ["FILE_DOWNLOAD", false, false]]);
								},

								$BEFORE_EXECCOMMAND: function(sCommand, bUserInterface, vValue, htOptions) {

								},
								
								$ON_EXECCOMMAND: function(sCommand, bUserInterface, vValue) {
									//console.log("$ON_EXECCOMMAND is called...");
									//console.log("sCommand = " + sCommand);
									switch(sCommand) {
										case "FILE_LOAD":
											this.$file.click();
											break;
										case "FILE_DOWNLOAD":

											break;
									}
								},
								
								$AFTER_EXECCOMMAND: function(sCommand, bUserInterface, vValue, htOptions) {
								},

							});
						}
					},
					"editing": {
						"hp_SE_EditingArea.js": function (exports, module, require) {
							/**
							 * @desc 
							 */
							nhn.husky.SE_EditingArea = jindo.$Class({

								name: "SE_EditingArea",

								/* RATIO: 3.78, //ratio=px/mm, mm to px ratio
								documentWidth: Math.floor(210*this.RATIO), //px
								documentHeight: Math.floor(297*this.RATIO), //px
								documentMargin: 20, //px */

								$init: function(appContainer) {
									this.appContainer = appContainer;
									this.menuBar = appContainer.querySelector("#menuBar");
									this.toolBar = appContainer.querySelector("#toolBar");
									this.statusBar = appContainer.querySelector("#statusBar");
								
									var container = this.container = appContainer.querySelector(".container"),
										document = this.document = container.querySelector(".document"),
										ruler = this.ruler = container.querySelector(".ruler"),
										editingArea = this.editingArea = document.querySelector(".editing_area");
								
									this.scrollView = document.querySelector("#scrollView");
									this.scrollViewHorizontal = document.querySelector("#scrollViewHorizontal");
									this.scrollViewVertical = document.querySelector("#scrollViewVertical");
									this.editCanvas = editingArea.querySelector("#editCanvas");
									
									//this.doc = carota.doc();
									this.doc = hwp.doc();

									//주요 상수값들 및 변수 선언
									this.RATIO = 3.78; //ratio=px/mm; mm to px ratio
									this.documentWidth = Math.floor(210*this.RATIO); //px
									this.documentHeight = Math.floor(297*this.RATIO); //px
									this.documentMargin = 20; //px

									this.paddingTop = Math.floor(20*this.RATIO);
									this.paddingBottom = Math.floor(15*this.RATIO);
									this.paddingLeft = Math.floor(30*this.RATIO);
									this.paddingRight = Math.floor(30*this.RATIO);
									this.paddingHead = Math.floor(15*this.RATIO);
									this.paddingTail = Math.floor(15*this.RATIO); //px

									this.offsetX = 0;
									this.offsetY = 0;
								},

								$BEFORE_MSG_APP_READY: function() {
								},

								$ON_MSG_APP_READY: function() {
									this.oApp.registerBrowserEvent(this.scrollView, "scroll", "EVENT_SCROLL_VIEW_SCROLL", [], null, 10);
									this.oApp.registerBrowserEvent(window, "resize", "EVENT_WINDOW_RESIZE", [], null, 100);
								},

								$AFTER_MSG_APP_READY : function() {
									this.oApp.exec("EVENT_WINDOW_RESIZE");
								},

								$ON_EVENT_SCROLL_VIEW_SCROLL: function() {
									this.oApp.exec("EDITING_AREA_PAINT");
								},

								$ON_EVENT_WINDOW_RESIZE: function() {
									this.editingArea.style.width = 100+"%";
									this.editingArea.style.height = this.appContainer.clientHeight - (this.menuBar.clientHeight + this.toolBar.clientHeight + this.ruler.clientHeight + this.statusBar.clientHeight) + "px";

									this.scrollView.style.width = this.editingArea.clientWidth+"px";
									this.scrollView.style.height = this.editingArea.clientHeight+"px";

									this.oApp.exec("EDITING_AREA_PAINT");
									this.oApp.exec("POSITION_CENTER");
								},

								$ON_PASTE_HTML: function(sHTML, oPSelection, htOption) {
									//console.log("$ON_PASTE_HTML is called...");
									var runs = carota.html.parse(sHTML, {
										//carota: { color: 'orange', bold: true, size: 14 }
									});
									this.doc.load(runs);
									this.oApp.exec("EVENT_WINDOW_RESIZE");
									//this.oApp.exec("EDITING_AREA_PAINT");
									//this.oApp.exec("POSITION_CENTER");
								},

								$ON_POSITION_CENTER: function() {
									//console.log("$ON_POSITON_CENTER is called...");
									var editingAreaWidth = this.editingArea.clientWidth,
										editingAreaHeight = this.editingArea.clientHeight;

									if (this.documentWidth > editingAreaWidth) {
										this.scrollView.scrollLeft = ((this.documentWidth+this.documentMargin*2)-editingAreaWidth)/2;
										//this.oApp.exec("EDITING_AREA_PAINT");
									}
								},
								
								$ON_EDITING_AREA_PAINT: function() {

									console.log("$ON_EDITING_AREA_PAINT is called...");

									var editingAreaWidth = this.editingArea.clientWidth,
										editingAreaHeight = this.editingArea.clientHeight;
									
									this.offsetX = (editingAreaWidth-this.documentWidth)/2;
									this.offsetY = (editingAreaHeight-this.documentHeight)/2;

									if (this.offsetX < 0) this.offsetX = 0;
									if (this.offsetY < 0) this.offsetY = 0;

									this.offsetX += this.documentMargin;
									this.offsetY += this.documentMargin;

									//console.log("this.offsetX = " + this.offsetX);
									//console.log("this.offsetY = " + this.offsetY);

									//draw paper

									var dpr = Math.max(1, window.devicePixelRatio || 1);
									
									var canvasWidth = Math.max(this.documentWidth, editingAreaWidth),
										canvasHeight = Math.min(this.documentHeight, editingAreaHeight)-16;

									this.editCanvas.width = dpr * canvasWidth;
									this.editCanvas.height = dpr * canvasHeight;
									this.editCanvas.style.width = canvasWidth+"px";
									this.editCanvas.style.height = canvasHeight+"px";

									this.scrollViewHorizontal.style.width = canvasWidth+"px";
									this.scrollViewVertical.style.height = this.documentHeight+"px";

									var ctx = this.editCanvas.getContext("2d");
									ctx.scale(dpr, dpr);
									ctx.translate(-this.scrollView.scrollLeft, -this.scrollView.scrollTop);

									ctx.clearRect(0, 0, canvasWidth, this.documentHeight);

									ctx.fillStyle = "white";
									ctx.fillRect(this.offsetX, this.offsetY, this.documentWidth, this.documentHeight);

									this._drawPaddingMark(ctx);

									var availableWidth = this.documentWidth-(this.paddingLeft+this.paddingRight),
										availableHeight = this.documentHeight-(this.paddingTop+this.paddingHead+this.paddingBottom+this.paddingTail);
									
									this.doc.layout(this.offsetX+this.paddingLeft, this.offsetY+this.paddingTop+this.paddingHead, availableWidth);
									//this.doc.draw(ctx, carota.rect(0, 0, availableWidth, availableHeight));

								},

								_drawPaddingMark: function(ctx) {

									ctx.beginPath();

									ctx.strokeStyle = "#c5c5c5";

									//LT
									ctx.moveTo(this.offsetX+this.paddingLeft, this.offsetY+this.paddingTop+this.paddingHead);
									ctx.lineTo(this.offsetX+this.paddingLeft, this.offsetY+this.paddingTop+this.paddingHead-20);
									ctx.moveTo(this.offsetX+this.paddingLeft, this.offsetY+this.paddingTop+this.paddingHead);
									ctx.lineTo(this.offsetX+this.paddingLeft-20, this.offsetY+this.paddingTop+this.paddingHead);

									//RT
									ctx.moveTo(this.offsetX+this.documentWidth-this.paddingLeft, this.offsetY+this.paddingTop+this.paddingHead);
									ctx.lineTo(this.offsetX+this.documentWidth-this.paddingLeft, this.offsetY+this.paddingTop+this.paddingHead-20);
									ctx.moveTo(this.offsetX+this.documentWidth-this.paddingLeft, this.offsetY+this.paddingTop+this.paddingHead);
									ctx.lineTo(this.offsetX+this.documentWidth-this.paddingLeft+20, this.offsetY+this.paddingTop+this.paddingHead);

									//RB
									ctx.moveTo(this.offsetX+this.documentWidth-this.paddingRight, this.offsetY+this.documentHeight-this.paddingBottom-this.paddingTail);
									ctx.lineTo(this.offsetX+this.documentWidth-this.paddingRight, this.offsetY+this.documentHeight-this.paddingBottom-this.paddingTail+20);
									ctx.moveTo(this.offsetX+this.documentWidth-this.paddingRight, this.offsetY+this.documentHeight-this.paddingBottom-this.paddingTail);
									ctx.lineTo(this.offsetX+this.documentWidth-this.paddingRight+20, this.offsetY+this.documentHeight-this.paddingBottom-this.paddingTail);

									//LB
									ctx.moveTo(this.offsetX+this.paddingLeft, this.offsetY+this.documentHeight-this.paddingBottom-this.paddingTail);
									ctx.lineTo(this.offsetX+this.paddingLeft, this.offsetY+this.documentHeight-this.paddingBottom-this.paddingTail+20);
									ctx.moveTo(this.offsetX+this.paddingLeft, this.offsetY+this.documentHeight-this.paddingBottom-this.paddingTail);
									ctx.lineTo(this.offsetX+this.paddingLeft-20, this.offsetY+this.documentHeight-this.paddingBottom-this.paddingTail);

									ctx.stroke();
								},

								$ON_EDITING_AREA_UPDATE: function() {
									var requirePaint = false;
									/* var newFocused = document.activeElement === textArea;
									if (focused !== newFocused) {
										focused = newFocused;
										requirePaint = true;
									}

									var now = new Date().getTime();
									if (now > nextCaretToggle) {
										nextCaretToggle = now + 500;
										if (this.doc.toggleCaret()) {
											requirePaint = true;
										}
									}

									if (this.editingArea.clientWidth !== cachedWidth ||
										this.editingArea.clientHeight !== cachedHeight) {
										requirePaint = true;
										cachedWidth = this.editingArea.clientWidth;
										cachedHeight = this.editingArea.clientHeight;
									} */

									if (requirePaint) {
										paint();
									}
								}
							});
						},
						"hp_SE_EditingAreaManager.js": function (exports, module, require) {
							/*
							Copyright (C) NAVER corp.  

							This library is free software; you can redistribute it and/or  
							modify it under the terms of the GNU Lesser General Public  
							License as published by the Free Software Foundation; either  
							version 2.1 of the License, or (at your option) any later version.  

							This library is distributed in the hope that it will be useful,  
							but WITHOUT ANY WARRANTY; without even the implied warranty of  
							MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  
							Lesser General Public License for more details.  

							You should have received a copy of the GNU Lesser General Public  
							License along with this library; if not, write to the Free Software  
							Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA  
							*/
							/*[
							 * LOAD_CONTENTS_FIELD
							 *
							 * 에디터 초기화 시에 넘어온 Contents(DB 저장 값)필드를 읽어 에디터에 설정한다.
							 *
							 * bDontAddUndo boolean Contents를 설정하면서 UNDO 히스토리는 추가 하지않는다.
							 *
							---------------------------------------------------------------------------]*/
							/*[
							 * UPDATE_IR_FIELD
							 *
							 * 에디터의 IR값을 IR필드에 설정 한다.
							 *
							 * none
							 *
							---------------------------------------------------------------------------]*/
							/*[
							 * CHANGE_EDITING_MODE
							 *
							 * 에디터의 편집 모드를 변경한다.
							 *
							 * sMode string 전환 할 모드명
							 * bNoFocus boolean 모드 전환 후에 에디터에 포커스를 강제로 할당하지 않는다.
							 *
							---------------------------------------------------------------------------]*/
							/*[
							 * FOCUS
							 *
							 * 에디터 편집 영역에 포커스를 준다.
							 *
							 * none
							 *
							---------------------------------------------------------------------------]*/
							/*[
							 * SET_IR
							 *
							 * IR값을 에디터에 설정 한다.
							 *
							 * none
							 *
							---------------------------------------------------------------------------]*/
							/*[
							 * REGISTER_EDITING_AREA
							 *
							 * 편집 영역 플러그인을 등록 시킨다. 원활한 모드 전환과 IR값 공유등를 위해서 초기화 시에 등록이 필요하다. 
							 *
							 * oEditingAreaPlugin object 편집 영역 플러그인 인스턴스
							 *
							---------------------------------------------------------------------------]*/
							/*[
							 * MSG_EDITING_AREA_RESIZE_STARTED
							 *
							 * 편집 영역 사이즈 조절이 시작 되었음을 알리는 메시지.
							 *
							 * none
							 *
							---------------------------------------------------------------------------]*/
							/*[
							 * RESIZE_EDITING_AREA
							 *
							 * 편집 영역 사이즈를 설정 한다. 변경 전후에 MSG_EDITIING_AREA_RESIZE_STARTED/MSG_EDITING_AREA_RESIZE_ENED를 발생 시켜 줘야 된다.
							 *
							 * ipNewWidth number 새 폭
							 * ipNewHeight number 새 높이
							 *
							---------------------------------------------------------------------------]*/
							/*[
							 * RESIZE_EDITING_AREA_BY
							 *
							 * 편집 영역 사이즈를 늘리거나 줄인다. 변경 전후에 MSG_EDITIING_AREA_RESIZE_STARTED/MSG_EDITING_AREA_RESIZE_ENED를 발생 시켜 줘야 된다.
							 * 변경치를 입력하면 원래 사이즈에서 변경하여 px로 적용하며, width가 %로 설정된 경우에는 폭 변경치가 입력되어도 적용되지 않는다.
							 *
							 * ipWidthChange number 폭 변경치
							 * ipHeightChange number 높이 변경치
							 *
							---------------------------------------------------------------------------]*/
							/*[
							 * MSG_EDITING_AREA_RESIZE_ENDED
							 *
							 * 편집 영역 사이즈 조절이 끝났음을 알리는 메시지.
							 *
							 * none
							 *
							---------------------------------------------------------------------------]*/
							/**
							 * @pluginDesc IR 값과 복수개의 편집 영역을 관리하는 플러그인
							 */
							nhn.husky.SE_EditingAreaManager = jindo.$Class({
								name : "SE_EditingAreaManager",
								
								// Currently active plugin instance(SE_EditingArea_???)
								oActivePlugin : null,
								
								// Intermediate Representation of the content being edited.
								// This should be a textarea element.
								elContentsField : null,
								
								bIsDirty : false,
								bAutoResize : false, // [SMARTEDITORSUS-677] 에디터의 자동확장 기능 On/Off 여부
								
								$init : function(sDefaultEditingMode, elContentsField, oDimension, fOnBeforeUnload, elAppContainer){
									this.sDefaultEditingMode = sDefaultEditingMode;
									this.elContentsField = jindo.$(elContentsField);
									this.elEditingAreaContainer = jindo.$$.getSingle("div.container", elAppContainer);
									this.fOnBeforeUnload = fOnBeforeUnload;
									
									this.oEditingMode = {};
									
									this.elContentsField.style.display = "none";
									
									/* this.nMinWidth = parseInt((oDimension.nMinWidth || 60), 10);
									this.nMinHeight = parseInt((oDimension.nMinHeight || 60), 10);
									
									var oWidth = this._getSize([oDimension.nWidth, oDimension.width, this.elEditingAreaContainer.offsetWidth], this.nMinWidth);
									var oHeight = this._getSize([oDimension.nHeight, oDimension.height, this.elEditingAreaContainer.offsetHeight], this.nMinHeight);
									console.log("oWidth = " + JSON.stringify(oWidth));
									console.log("oHeight = " + JSON.stringify(oHeight));

									this.elEditingAreaContainer.style.width = oWidth.nSize + oWidth.sUnit;
									this.elEditingAreaContainer.style.height = oHeight.nSize + oHeight.sUnit;
									
									if(oWidth.sUnit === "px"){
										elAppContainer.style.width = (oWidth.nSize) + "px";	
									}else if(oWidth.sUnit === "%"){
										elAppContainer.style.minWidth = this.nMinWidth + "px";
									} */
								},

								_getSize : function(aSize, nMin){
									var i, nLen, aRxResult, nSize, sUnit, sDefaultUnit = "px";
									
									nMin = parseInt(nMin, 10);
									
									for(i=0, nLen=aSize.length; i<nLen; i++){
										if(!aSize[i]){
											continue;
										}
										
										if(!isNaN(aSize[i])){
											nSize = parseInt(aSize[i], 10);
											sUnit = sDefaultUnit;
											break;
										}
										
										aRxResult = /([0-9]+)(.*)/i.exec(aSize[i]);
													
										if(!aRxResult || aRxResult.length < 2 || aRxResult[1] <= 0){
											continue;
										}
										
										nSize = parseInt(aRxResult[1], 10);
										sUnit = aRxResult[2];
													
										if(!sUnit){
											sUnit = sDefaultUnit;
										}
										
										if(nSize < nMin && sUnit === sDefaultUnit){
											nSize = nMin;
										}
										
										break;
									}
											
									if(!sUnit){
										sUnit = sDefaultUnit;
									}
									
									if(isNaN(nSize) || (nSize < nMin && sUnit === sDefaultUnit)){
										nSize = nMin;
									}
									
									return {nSize : nSize, sUnit : sUnit};
								},
								

								$BEFORE_MSG_APP_READY : function(/*msg*/){
									this.oApp.exec("ADD_APP_PROPERTY", ["version", nhn.husky.SE_EditingAreaManager.version]);
									this.oApp.exec("ADD_APP_PROPERTY", ["elEditingAreaContainer", this.elEditingAreaContainer]);
									this.oApp.exec("ADD_APP_PROPERTY", ["welEditingAreaContainer", jindo.$Element(this.elEditingAreaContainer)]);
									this.oApp.exec("ADD_APP_PROPERTY", ["getEditingAreaHeight", jindo.$Fn(this.getEditingAreaHeight, this).bind()]);
									this.oApp.exec("ADD_APP_PROPERTY", ["getEditingAreaWidth", jindo.$Fn(this.getEditingAreaWidth, this).bind()]);
									this.oApp.exec("ADD_APP_PROPERTY", ["getRawContents", jindo.$Fn(this.getRawContents, this).bind()]);
									this.oApp.exec("ADD_APP_PROPERTY", ["getContents", jindo.$Fn(this.getContents, this).bind()]);
									this.oApp.exec("ADD_APP_PROPERTY", ["getIR", jindo.$Fn(this.getIR, this).bind()]);
									this.oApp.exec("ADD_APP_PROPERTY", ["setContents", this.setContents]);
									this.oApp.exec("ADD_APP_PROPERTY", ["setIR", this.setIR]);
									this.oApp.exec("ADD_APP_PROPERTY", ["getEditingMode", jindo.$Fn(this.getEditingMode, this).bind()]);
									this.oApp.exec("ADD_APP_PROPERTY", ["getWindow", jindo.$Fn(this.getWindow, this).bind()]);
									this.oApp.exec("ADD_APP_PROPERTY", ["getDocument", jindo.$Fn(this.getDocument, this).bind()]);
								},

								$ON_MSG_APP_READY : function(){
									this.htOptions =  this.oApp.htOptions[this.name] || {};
									this.sDefaultEditingMode = this.htOptions["sDefaultEditingMode"] || this.sDefaultEditingMode;
									//this.iframeWindow = this.oApp.getWindow();
									this.oApp.exec("REGISTER_CONVERTERS", []);
									this.oApp.exec("CHANGE_EDITING_MODE", [this.sDefaultEditingMode, true]);
									this.oApp.exec("LOAD_CONTENTS_FIELD", [false]);

									// [SMARTEDITORSUS-2089] fOnBeforeUnload === false 인 경우, 아예 window.onbeforeunload 를 등록하지 않도록 수정
									if(this.fOnBeforeUnload !== false){
										if(this.fOnBeforeUnload){
											window.onbeforeunload = this.fOnBeforeUnload;
										}else{
											window.onbeforeunload = jindo.$Fn(function(){
												// [SMARTEDITORSUS-1028][SMARTEDITORSUS-1517] QuickEditor 설정 API 개선으로, submit 이후 발생하게 되는 beforeunload 이벤트 핸들링 제거
												//this.oApp.exec("MSG_BEFOREUNLOAD_FIRED");
												// --// [SMARTEDITORSUS-1028][SMARTEDITORSUS-1517]
												//if(this.getContents() != this.elContentsField.value || this.bIsDirty){
												if(this.getRawContents() != this.sCurrentRawContents || this.bIsDirty){
													return this.oApp.$MSG("SE_EditingAreaManager.onExit");
												}
											}, this).bind();
										}
									}
								},

								$AFTER_MSG_APP_READY : function(){
									this.oApp.exec("UPDATE_RAW_CONTENTS");
									
									if(!!this.oApp.htOptions[this.name] && this.oApp.htOptions[this.name].bAutoResize){
										this.bAutoResize = this.oApp.htOptions[this.name].bAutoResize;
									}
									// [SMARTEDITORSUS-941] 아이패드에서는 자동확장기능이 항상 켜져있도록 한다.
									if(this.oApp.oNavigator.msafari){
										this.bAutoResize = true;
									}

									this.startAutoResize();	// [SMARTEDITORSUS-677] 편집영역 자동 확장 옵션이 TRUE이면 자동확장 시작
								},

								$ON_LOAD_CONTENTS_FIELD : function(bDontAddUndo){
									var sContentsFieldValue = this.elContentsField.value;
									
									// [SMARTEDITORSUS-177] [IE9] 글 쓰기, 수정 시에 elContentsField 에 들어간 공백을 제거
									// [SMARTEDITORSUS-312] [FF4] 인용구 첫번째,두번째 디자인 1회 선택 시 에디터에 적용되지 않음
									sContentsFieldValue = sContentsFieldValue.replace(/^\s+/, "");
											
									this.oApp.exec("SET_CONTENTS", [sContentsFieldValue, bDontAddUndo]);
								},
								
								// 현재 contents를 form의 textarea에 세팅 해 줌.
								// form submit 전에 이 부분을 실행시켜야 됨.
								$ON_UPDATE_CONTENTS_FIELD : function(){
									//this.oIRField.value = this.oApp.getIR();
									this.elContentsField.value = this.oApp.getContents();
									this.oApp.exec("UPDATE_RAW_CONTENTS");
									//this.sCurrentRawContents = this.elContentsField.value;
								},
								
								// 에디터의 현재 상태를 기억해 둠. 페이지를 떠날 때 이 값이 변경 됐는지 확인 해서 내용이 변경 됐다는 경고창을 띄움
								// RawContents 대신 contents를 이용해도 되지만, contents 획득을 위해서는 변환기를 실행해야 되기 때문에 RawContents 이용
								$ON_UPDATE_RAW_CONTENTS : function(){
									this.sCurrentRawContents = this.oApp.getRawContents();
								},
								
								$BEFORE_CHANGE_EDITING_MODE : function(sMode){
									if(!this.oEditingMode[sMode]){
										return false;
									}
									
									this.stopAutoResize();	// [SMARTEDITORSUS-677] 해당 편집 모드에서의 자동확장을 중지함
									
									this._oPrevActivePlugin = this.oActivePlugin;
									this.oActivePlugin = this.oEditingMode[sMode];
								},

								$AFTER_CHANGE_EDITING_MODE : function(sMode, bNoFocus){
									if(this._oPrevActivePlugin){
										var sIR = this._oPrevActivePlugin.getIR();
										this.oApp.exec("SET_IR", [sIR]);

										//this.oApp.exec("ENABLE_UI", [this._oPrevActivePlugin.sMode]);
										
										this._setEditingAreaDimension();
									}
									//this.oApp.exec("DISABLE_UI", [this.oActivePlugin.sMode]);
									
									this.startAutoResize();	// [SMARTEDITORSUS-677] 변경된 편집 모드에서의 자동확장을 시작

									if(!bNoFocus){
										this.oApp.delayedExec("FOCUS", [], 0);
									}
								},
								
								/** 
								 * 페이지를 떠날 때 alert을 표시할지 여부를 셋팅하는 함수.
								 */
								$ON_SET_IS_DIRTY : function(bIsDirty){
									this.bIsDirty = bIsDirty;
								},

								// [SMARTEDITORSUS-1698] 모바일에서 팝업 형태의 첨부가 사용될 때 포커스 이슈가 있음
								$ON_FOCUS : function(isPopupOpening){
									if(!this.oActivePlugin || typeof this.oActivePlugin.setIR != "function"){
										return;
									}

									// [SMARTEDITORSUS-599] ipad 대응 이슈.
									// ios5에서는 this.iframe.contentWindow focus가 없어서 생긴 이슈. 
									// document가 아닌 window에 focus() 주어야만 본문에 focus가 가고 입력이됨.
									
									//[SMARTEDITORSUS-1017] [iOS5대응] 모드 전환 시 textarea에 포커스가 있어도 글자가 입력이 안되는 현상
									//원인 : WYSIWYG모드가 아닐 때에도 iframe의 contentWindow에 focus가 가면서 focus기능이 작동하지 않음
									//해결 : WYSIWYG모드 일때만 실행 되도록 조건식 추가 및 기존에 blur처리 코드 삭제
									//[SMARTEDITORSUS-1594] 크롬에서 웹접근성용 키로 빠져나간 후 다시 진입시 간혹 포커싱이 안되는 문제가 있어 iframe에 포커싱을 먼저 주도록 수정
									if(!!this.iframeWindow && this.iframeWindow.document.hasFocus && !this.iframeWindow.document.hasFocus() && this.oActivePlugin.sMode == "WYSIWYG"){
										this.iframeWindow.focus();
									}else{ // 누락된 [SMARTEDITORSUS-1018] 작업분 반영
										this.oActivePlugin.focus();
									}
									
									if(isPopupOpening && this.oApp.bMobile){
										return;
									}
									
									this.oActivePlugin.focus();
								},
								// --[SMARTEDITORSUS-1698]
								
								$ON_IE_FOCUS : function(){
									var oAgent = this.oApp.oNavigator;
									if(!oAgent.ie && !oAgent.edge){	// [SMARTEDITORSUS-2257] edge도 ie와 동일하게 포커스처리해준다.
										return;
									}
									this.oApp.exec("FOCUS");
								},
								
								$ON_SET_CONTENTS : function(sContents, bDontAddUndoHistory){
									this.setContents(sContents, bDontAddUndoHistory);
								},

								$BEFORE_SET_IR : function(sIR, bDontAddUndoHistory){
									bDontAddUndoHistory = bDontAddUndoHistory || false;
									if(!bDontAddUndoHistory){
										this.oApp.exec("RECORD_UNDO_ACTION", ["BEFORE SET CONTENTS", {sSaveTarget:"BODY"}]);
									}
								},

								$ON_SET_IR : function(sIR){
									if(!this.oActivePlugin || typeof this.oActivePlugin.setIR != "function"){
										return;
									}

									this.oActivePlugin.setIR(sIR);
								},

								$AFTER_SET_IR : function(sIR, bDontAddUndoHistory){
									bDontAddUndoHistory = bDontAddUndoHistory || false;
									if(!bDontAddUndoHistory){
										this.oApp.exec("RECORD_UNDO_ACTION", ["AFTER SET CONTENTS", {sSaveTarget:"BODY"}]);
									}
								},

								$ON_REGISTER_EDITING_AREA : function(oEditingAreaPlugin){
									this.oEditingMode[oEditingAreaPlugin.sMode] = oEditingAreaPlugin;
									/* if(oEditingAreaPlugin.sMode == 'Canvas'){
										this.attachDocumentEvents(oEditingAreaPlugin.oEditingArea);
									} */
									this._setEditingAreaDimension(oEditingAreaPlugin);
								},

								$ON_MSG_EDITING_AREA_RESIZE_STARTED : function(){
									this._fitElementInEditingArea(this.elEditingAreaContainer);
									this.oApp.exec("STOP_AUTORESIZE_EDITING_AREA");	// [SMARTEDITORSUS-677] 사용자가 편집영역 사이즈를 변경하면 자동확장 기능 중지
									this.oApp.exec("SHOW_EDITING_AREA_COVER");
									this.elEditingAreaContainer.style.overflow = "hidden";

									this.iStartingHeight = parseInt(this.elEditingAreaContainer.style.height, 10);
								},
								
								/**
								 * [SMARTEDITORSUS-677] 편집영역 자동확장 기능을 중지함
								 */
								$ON_STOP_AUTORESIZE_EDITING_AREA : function(){
									if(!this.bAutoResize){
										return;
									}
									
									this.stopAutoResize();
									this.bAutoResize = false;
								},
								
								/**
								 * [SMARTEDITORSUS-677] 해당 편집 모드에서의 자동확장을 시작함
								 */
								startAutoResize : function(){
									if(!this.bAutoResize || !this.oActivePlugin || typeof this.oActivePlugin.startAutoResize != "function"){
										return;
									}
									
									this.oActivePlugin.startAutoResize();
								},
								
								/**
								 * [SMARTEDITORSUS-677] 해당 편집 모드에서의 자동확장을 중지함
								 */
								stopAutoResize : function(){
									if(!this.bAutoResize || !this.oActivePlugin || typeof this.oActivePlugin.stopAutoResize != "function"){
										return;
									}
									
									this.oActivePlugin.stopAutoResize();
								},
								
								$ON_RESIZE_EDITING_AREA: function(ipNewWidth, ipNewHeight){
									if(ipNewWidth !== null && typeof ipNewWidth !== "undefined"){
										this._resizeWidth(ipNewWidth, "px");	
									}
									if(ipNewHeight !== null && typeof ipNewHeight !== "undefined"){
										this._resizeHeight(ipNewHeight, "px");
									}
									
									this._setEditingAreaDimension();
								},
								
								_resizeWidth : function(ipNewWidth, sUnit){
									var iNewWidth = parseInt(ipNewWidth, 10);
									
									if(iNewWidth < this.nMinWidth){
										iNewWidth = this.nMinWidth;
									}
									
									if(ipNewWidth){		
										this.elEditingAreaContainer.style.width = iNewWidth + sUnit;			
									}
								},
								
								_resizeHeight : function(ipNewHeight, sUnit){
									var iNewHeight = parseInt(ipNewHeight, 10);
									
									if(iNewHeight < this.nMinHeight){
										iNewHeight = this.nMinHeight;
									}

									if(ipNewHeight){
										this.elEditingAreaContainer.style.height = iNewHeight + sUnit;
									}
								},
								
								$ON_RESIZE_EDITING_AREA_BY : function(ipWidthChange, ipHeightChange){
									var iWidthChange = parseInt(ipWidthChange, 10);
									var iHeightChange = parseInt(ipHeightChange, 10);
									var iWidth;
									var iHeight;
									
									if(ipWidthChange !== 0 && this.elEditingAreaContainer.style.width.indexOf("%") === -1){
										iWidth = this.elEditingAreaContainer.style.width?parseInt(this.elEditingAreaContainer.style.width, 10)+iWidthChange:null;
									}
									
									if(iHeightChange !== 0){
										iHeight = this.elEditingAreaContainer.style.height?this.iStartingHeight+iHeightChange:null;
									}
									
									if(!ipWidthChange && !iHeightChange){
										return;
									}
											
									this.oApp.exec("RESIZE_EDITING_AREA", [iWidth, iHeight]);
								},
								
								$ON_MSG_EDITING_AREA_RESIZE_ENDED : function(/*FnMouseDown, FnMouseMove, FnMouseUp*/){
									this.oApp.exec("HIDE_EDITING_AREA_COVER");
									this.elEditingAreaContainer.style.overflow = "";
									this._setEditingAreaDimension();
								},

								/**
								 * 편집영역에 커서가 들어가지 않도록 투명 커버를 씌운다.
								 * @param {Boolean} bDimmed 반투명 처리할지 여부
								 */
								$ON_SHOW_EDITING_AREA_COVER : function(bDimmed){
									if(!this.elEditingAreaCover){
										this.elEditingAreaCover = document.createElement("DIV");
										this.elEditingAreaCover.style.cssText = 'position:absolute;top:0;left:0;z-index:100;background:#000000;filter:alpha(opacity=0);opacity:0.0;-moz-opacity:0.0;-khtml-opacity:0.0;height:100%;width:100%';
										this.elEditingAreaContainer.appendChild(this.elEditingAreaCover);
									}
									if(bDimmed){
										jindo.$Element(this.elEditingAreaCover).opacity(0.4);
									}
									this.elEditingAreaCover.style.display = "block";
								},
								
								$ON_HIDE_EDITING_AREA_COVER : function(){
									if(!this.elEditingAreaCover){
										return;
									}
									this.elEditingAreaCover.style.display = "none";
									jindo.$Element(this.elEditingAreaCover).opacity(0);
								},
								
								$ON_KEEP_WITHIN_EDITINGAREA : function(elLayer, nHeight){
									var nTop = parseInt(elLayer.style.top, 10);
									if(nTop + elLayer.offsetHeight > this.oApp.elEditingAreaContainer.offsetHeight){
										if(typeof nHeight == "number"){
											elLayer.style.top = nTop - elLayer.offsetHeight - nHeight + "px";
										}else{
											elLayer.style.top = this.oApp.elEditingAreaContainer.offsetHeight - elLayer.offsetHeight + "px";
										}
									}

									var nLeft = parseInt(elLayer.style.left, 10);
									if(nLeft + elLayer.offsetWidth > this.oApp.elEditingAreaContainer.offsetWidth){
										elLayer.style.left = this.oApp.elEditingAreaContainer.offsetWidth - elLayer.offsetWidth + "px";
									}
								},

								$ON_EVENT_EDITING_AREA_KEYDOWN : function(){
									this.oApp.exec("HIDE_ACTIVE_LAYER", []);
								},

								$ON_EVENT_EDITING_AREA_MOUSEDOWN : function(){
									this.oApp.exec("HIDE_ACTIVE_LAYER", []);
								},

								$ON_EVENT_EDITING_AREA_SCROLL : function(){
									this.oApp.exec("HIDE_ACTIVE_LAYER", []);
								},

								_setEditingAreaDimension : function(oEditingAreaPlugin){
									oEditingAreaPlugin = oEditingAreaPlugin || this.oActivePlugin;
									this._fitElementInEditingArea(oEditingAreaPlugin.elEditingArea);
								},
								
								_fitElementInEditingArea : function(el){
									el.style.height = this.elEditingAreaContainer.offsetHeight+"px";
							//		el.style.width = this.elEditingAreaContainer.offsetWidth+"px";
							//		el.style.width = this.elEditingAreaContainer.style.width || (this.elEditingAreaContainer.offsetWidth+"px");
								},
								
								attachDocumentEvents : function(doc){
									this.oApp.registerBrowserEvent(doc, "click", "EVENT_EDITING_AREA_CLICK");
									this.oApp.registerBrowserEvent(doc, "dblclick", "EVENT_EDITING_AREA_DBLCLICK");
									this.oApp.registerBrowserEvent(doc, "mousedown", "EVENT_EDITING_AREA_MOUSEDOWN");
									this.oApp.registerBrowserEvent(doc, "mousemove", "EVENT_EDITING_AREA_MOUSEMOVE");
									this.oApp.registerBrowserEvent(doc, "mouseup", "EVENT_EDITING_AREA_MOUSEUP");
									this.oApp.registerBrowserEvent(doc, "mouseout", "EVENT_EDITING_AREA_MOUSEOUT");
									this.oApp.registerBrowserEvent(doc, "mousewheel", "EVENT_EDITING_AREA_MOUSEWHEEL");
									this.oApp.registerBrowserEvent(doc, "keydown", "EVENT_EDITING_AREA_KEYDOWN");
									this.oApp.registerBrowserEvent(doc, "keypress", "EVENT_EDITING_AREA_KEYPRESS");
									this.oApp.registerBrowserEvent(doc, "keyup", "EVENT_EDITING_AREA_KEYUP");
									this.oApp.registerBrowserEvent(doc, "scroll", "EVENT_EDITING_AREA_SCROLL");
								},
								
								$ON_GET_COVER_DIV : function(sAttr,oReturn){
									if(this.elEditingAreaCover) {
										oReturn[sAttr] = this.elEditingAreaCover;
									}
								},
								
								$ON_SHOW_LOADING_LAYER : function(){
									this.elLoadingLayer.style.display = 'block';
								},

								$ON_HIDE_LOADING_LAYER : function(){
									this.elLoadingLayer.style.display = 'none';
								},
								
								getIR : function(){
									if(!this.oActivePlugin){
										return "";
									}
									return this.oActivePlugin.getIR();
								},

								setIR : function(sIR, bDontAddUndo){
									this.oApp.exec("SET_IR", [sIR, bDontAddUndo]);
								},

								getRawContents : function(){
									if(!this.oActivePlugin){
										return "";
									}
									return this.oActivePlugin.getRawContents();
								},
								
								getContents : function(){
									// [SMARTEDITORSUS-2077]
									this._convertLastBrToNbsp();

									var sIR = this.oApp.getIR();
									var sContents;

									if(this.oApp.applyConverter){
										sContents = this.oApp.applyConverter("IR_TO_DB", sIR, this.oApp.getDocument());
									}else{
										sContents = sIR;
									}
									
									sContents = this._cleanContents(sContents);

									return sContents;
								},
								
								/**
								 * [SMARTEDITORSUS-2077]
								 * 문단 내 마지막 <br>을 찾아서,
								 * 특수한 경우를 제외하고 모두 &nbsp;로 변환한다.
								 * 
								 * -NBSP로 변환해야 할 필요성
								 * --[IE 문서모드 8~10] 레이아웃 상 문단 내부 맨 마지막 요소가 <br>인 경우,
								 * <br>이 두 줄의 높이를 가진 것처럼 표현되는 현상이 있음
								 *  
								 * -NBSP로 변환하지 않고 <br>을 제거하는 경우
								 * --레이아웃 상 <br> 바로 앞에 <img>가 위치하고,
								 * 이 <img>가 
								 * parentNode가 허용하는 최대 가로폭 이상의 가로 크기를 가지고 있어
								 * parentNode가 허용하는 최대 가로폭으로 리사이징된 경우
								 * ---<br>이 NBSP로 변환되면, <img> 아래줄로 밀려나 한 줄을 더 차지하게 됨
								 * 
								 */
								_convertLastBrToNbsp : function(){
									var elBody = this.oApp.getDocument().body,
									aBr, elBr,
									elBrContainer, elImgContainer, elNextToImgContainer, elUndesiredContainer,
									aImg, elImg, nImgWidth,
									elImgParent, nParentWidth,
									bConvertBrToNbsp,
									oNbsp = document.createTextNode('\u00A0'), oNbspClone,
									elBrParent;
									
									// br:last-child 탐색
									aBr = jindo.$$('br:last-child', elBody, {oneTimeOffCache : true});
									for(var i = 0, len = aBr.length; i < len; i++){
										elImg = null;
										elBrParent = null;
										elBr = aBr[i];
										
										// <br>부터 부모로 거슬러 올라가면서, previousSibling이 있는지 찾는다.
										elImgContainer = this._findNextSiblingRecursive(elBr, {isReverse : true});
										if(!(elImgContainer && (elImgContainer.nodeType === 1))){
											continue;
										}
										
										elBrContainer = elImgContainer.nextSibling;
										
										/*
										 * <br> container에서 부모로 거슬러 올라가면서, nextSibling이 있는지 찾는다.
										 * nextSibling이 없다는 것이 확인되어야만, 
										 * <br> container가 문단 맨 마지막에 있다는 것을
										 * 보장할 수 있기 때문이다.
										 */
										elUndesiredContainer = this._findNextSiblingRecursive(elBrContainer);
										// <br> container 뒤의 container는 존재해서는 안 된다.
										if(elUndesiredContainer){
											continue;
										}
										
										if(elImgContainer.tagName.toUpperCase() === 'IMG'){
											// previousSibling이 <img>이면 바로 할당
											elImg = elImgContainer;
										}else{
											// previousSibling의 img:last-child 탐색
											aImg = jindo.$$('img:last-child', elImgContainer, {oneTimeOffCache : true});
											
											// 가장 마지막 <img>가 고려 대상이다. 즉, <br> 바로 앞에 위치하고 있을 것으로 추정되는 img
											if(aImg.length > 0){
												elImg = aImg[aImg.length - 1];
											}
										}
										
										if(elImg){
											/*
											 * <img> container 바로 뒤가 실제로 <br> container인지 확인.
											 * 레이아웃 상에서 실제로 <img> 뒤에 <br>이 붙어 있는지 확인하는 과정이다.
											 */
											elNextToImgContainer = this._findNextSiblingRecursive(elImg);
											if(elNextToImgContainer == elBrContainer){
												elImgParent = elImg.parentNode;
												if(!elImgParent){
													continue;
												}
												
												// <img>의 width 확인
												nImgWidth = jindo.$Element(elImg).width(),
												
												// <img> parentNode의 width 확인
												elImgParent = elImg.parentNode,
												nParentWidth = jindo.$Element(elImgParent).width();
												
												/*
												 * <img>와 parentNode의 width가 같은지 확인하여
												 * <img> 뒤의 <br>을 &nbsp;로 변환할지, 아니면 제거할지 판단한다.
												 */
												bConvertBrToNbsp = !(nImgWidth === nParentWidth);
											}else{
												// <img> container와 <br> container 사이에 다른 container가 존재한다면, &nbsp;로 변환
												bConvertBrToNbsp = true;
											}
										}else{
											// img:last-child 가 존재하지 않으면, <br>을 &nbsp;로 변환
											bConvertBrToNbsp = true;
										}
											
										elBrParent = elBr.parentNode;
										if(bConvertBrToNbsp){
											// <br>을 &nbsp;로 변환
											oNbspClone = oNbsp.cloneNode(false);
											
											elBrParent.replaceChild(oNbspClone, elBr);
										}else{
											// <br>을 &nbsp;로 변환하지 않고 제거해 버림
											this._recursiveRemoveChild(elBr);
										}
									}
								},
								
								/**
								 * 대상 element의 nextSibling이 있는지
								 * tree를 거슬러 올라가며 recursive 탐색
								 * 
								 * @param {HTMLElement} el 탐색 시작점 element
								 * @param {Object} htOption
								 *	 @param {Boolean} htOption.isReverse nextSibling 이 아닌, previousSibling을 탐색
								 */
								_findNextSiblingRecursive : function(el, htOption){
									var elTarget = el,
									elSibling,
									isReverse = (htOption && htOption.isReverse) ? true : false,
									rxContainer = new RegExp('^(TD|BODY)$', 'i');
									
									/*
									 * 종료 조건
									 * -container 역할을 하는 태그로 지정한 TD, BODY가 parentNode가 될 때까지 거슬러 올라감
									 * -sibling 존재
									 */
									while(!elSibling){
										if(isReverse){
											elSibling = elTarget.previousSibling;
										}else{
											elSibling = elTarget.nextSibling;
										}
										
										elTarget = elTarget.parentNode;
										if(rxContainer.test(elTarget.tagName)){
											elSibling = null;
											break;
										}
									}
									
									return elSibling;
								},
								
								/**
								 * 대상 element를 parentNode에서 제거한다.
								 * 
								 * 이후, 
								 * parentNode 입장에서 
								 * childNode가 아무것도 없으면
								 * 그 parentNode에서 이 parentNode를 제거하는 작업을
								 * recursive로 수행한다.
								 */
								_recursiveRemoveChild : function(el){
									var elParent = el.parentNode,
									elChild = el,
									aChild;
									
									do{
										elParent.removeChild(elChild);
									}while((aChild = elParent.childNodes) && (aChild.length == 0) && (elChild = elParent) && (elParent = elParent.parentNode))
								},
								
								_cleanContents : function(sContents){
									return sContents.replace(new RegExp("(<img [^>]*>)"+unescape("%uFEFF")+"", "ig"), "$1");
								},

								setContents : function(sContents, bDontAddUndo){
									var sIR;

									if(this.oApp.applyConverter){
										sIR = this.oApp.applyConverter("DB_TO_IR", sContents, this.oApp.getDocument());
									}else{
										sIR = sContents;
									}

									this.oApp.exec("SET_IR", [sIR, bDontAddUndo]);
								},
								
								getEditingMode : function(){
									return this.oActivePlugin.sMode;
								},
								
								getEditingAreaWidth : function(){
									return this.elEditingAreaContainer.offsetWidth;
								},
								
								getEditingAreaHeight : function(){
									return this.elEditingAreaContainer.offsetHeight;
								},

								getWindow : function(){
									return window;
								},

								getDocument : function(){
									return document;
								},
							});
						}
					}
				},
				"husky_framework": {
					"HuskyCore.js": function (exports, module, require) {
						/*
						Copyright (C) NAVER corp.  

						This library is free software; you can redistribute it and/or  
						modify it under the terms of the GNU Lesser General Public  
						License as published by the Free Software Foundation; either  
						version 2.1 of the License, or (at your option) any later version.  

						This library is distributed in the hope that it will be useful,  
						but WITHOUT ANY WARRANTY; without even the implied warranty of  
						MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  
						Lesser General Public License for more details.  

						You should have received a copy of the GNU Lesser General Public  
						License along with this library; if not, write to the Free Software  
						Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA  
						*/
						if(typeof window.nhn=='undefined'){window.nhn = {};}
						if (!nhn.husky){nhn.husky = {};}
						/**
						 * @fileOverview This file contains Husky framework core
						 * @name HuskyCore.js
						 */
						(function(){
							var _rxMsgHandler = /^\$(LOCAL|BEFORE|ON|AFTER)_/,
								_rxMsgAppReady = /^\$(BEFORE|ON|AFTER)_MSG_APP_READY$/,
								_aHuskyCores = [],	// HuskyCore instance list
								_htLoadedFile = {};	// lazy-loaded file list

							nhn.husky.HuskyCore = jindo.$Class({
								name : "HuskyCore",
								aCallerStack : null,
								bMobile : jindo.$Agent().navigator().mobile || jindo.$Agent().navigator().msafari, 

								$init : function(htOptions){
									this.htOptions = htOptions||{};
							
									_aHuskyCores.push(this);
							
									// To prevent processing a Husky message before all the plugins are registered and ready,
									// Queue up all the messages here until the application's status is changed to READY
									this.messageQueue = [];
							
									this.oMessageMap = {};
									this.oDisabledMessage = {};
									this.oLazyMessage = {};
									this.aPlugins = [];
							
									this.appStatus = nhn.husky.APP_STATUS.NOT_READY;
									
									this.aCallerStack = [];
									
									this._fnWaitForPluginReady = jindo.$Fn(this._waitForPluginReady, this).bind();
									
									// Register the core as a plugin so it can receive messages
									this.registerPlugin(this);
								},
								
								exec : function(msg, args, oEvent){
									// If the application is not yet ready just queue the message
									if(this.appStatus == nhn.husky.APP_STATUS.NOT_READY){
										this.messageQueue[this.messageQueue.length] = {'msg':msg, 'args':args, 'event':oEvent};
										return true;
									}
							
									this.exec = this._doExec;
									this.exec(msg, args, oEvent);
								},
								
								absorbedExec: function(msg, args, nAbsorb, oEvent) {
									var fExec = jindo.$Fn(this.exec, this).bind(msg, args, oEvent);
									if (this["timerId_"+msg] != null) {
										//console.log("clearTimeout() is called...");
										//console.log("" + this["timerId_"+msg]);
										clearTimeout(this["timerId_"+msg]);
										this["timerId_"+msg] = setTimeout(fExec, nAbsorb);
									} else
										this["timerId_"+msg] = setTimeout(fExec, nAbsorb);
								},

								delayedExec: function(msg, args, nDelay, oEvent) {
									var fExec = jindo.$Fn(this.exec, this).bind(msg, args, oEvent);
									setTimeout(fExec, nDelay);
								},
							
								_doExec: function(msg, args, oEvent) {
									var bContinue = false;
							
									// Lazy메시지가 있으면 파일을 로딩한다.
									if(this.oLazyMessage[msg]){
										var htLazyInfo = this.oLazyMessage[msg]; 
										this._loadLazyFiles(msg, args, oEvent, htLazyInfo.aFilenames, 0);
										return false;
									}
							
									if(!this.oDisabledMessage[msg]){
										var allArgs = [];
										if(args && args.length){
											var iLen = args.length;
											for(var i=0; i<iLen; i++){allArgs[i] = args[i];}
										}
										if(oEvent){allArgs[allArgs.length] = oEvent;}
							
										bContinue = this._execMsgStep("BEFORE", msg, allArgs);
										if(bContinue){bContinue = this._execMsgStep("ON", msg, allArgs);}
										if(bContinue){bContinue = this._execMsgStep("AFTER", msg, allArgs);}
									}
							
									return bContinue;
								},
							
								
								registerPlugin : function(oPlugin){
									if(!oPlugin){throw("An error occured in registerPlugin(): invalid plug-in");}
							
									oPlugin.nIdx = this.aPlugins.length;
									oPlugin.oApp = this;
									this.aPlugins[oPlugin.nIdx] = oPlugin;
							
									// If the plugin does not specify that it takes time to be ready, change the stauts to READY right away
									if(oPlugin.status != nhn.husky.PLUGIN_STATUS.NOT_READY){oPlugin.status = nhn.husky.PLUGIN_STATUS.READY;}
							
									// If run() function had been called already, need to recreate the message map
									if(this.appStatus != nhn.husky.APP_STATUS.NOT_READY){
										for(var funcName in oPlugin){
											if(_rxMsgHandler.test(funcName)){
												this.addToMessageMap(funcName, oPlugin);
											}
										}
									}
							
									this.exec("MSG_PLUGIN_REGISTERED", [oPlugin]);
							
									return oPlugin.nIdx;
								},
							
								disableMessage : function(sMessage, bDisable){this.oDisabledMessage[sMessage] = bDisable;},
							
								registerBrowserEvent: function(obj, sEvent, sMessage, aParams, nDelay, nAbsorb) {
									aParams = aParams || [];
									var func = nAbsorb ? jindo.$Fn(this.delayedExec, this).bind(sMessage, aParams, nAbsorb)
										: nDelay ? jindo.$Fn(this.delayedExec, this).bind(sMessage, aParams, nDelay) 
										: jindo.$Fn(this.exec, this).bind(sMessage, aParams);
									if (nAbsorb)
										func = jindo.$Fn(this.absorbedExec, this).bind(sMessage, aParams, nAbsorb);
									else if(nDelay)
										func = jindo.$Fn(this.delayedExec, this).bind(sMessage, aParams, nDelay);
									else
										func = jindo.$Fn(this.exec, this).bind(sMessage, aParams);
									return jindo.$Fn(func, this).attach(obj, sEvent);
								},
							
								run : function(htOptions){
									this.htRunOptions = htOptions || {};
							
									// Change the status from NOT_READY to let exec to process all the way
									this._changeAppStatus(nhn.husky.APP_STATUS.WAITING_FOR_PLUGINS_READY);
							
									// Process all the messages in the queue
									var iQueueLength = this.messageQueue.length;
									for(var i=0; i<iQueueLength; i++){
										var curMsgAndArgs = this.messageQueue[i];
										this.exec(curMsgAndArgs.msg, curMsgAndArgs.args, curMsgAndArgs.event);
									}
							
									this._fnWaitForPluginReady();
								},
							
								acceptLocalBeforeFirstAgain : function(oPlugin, bAccept){
									// LOCAL_BEFORE_FIRST will be fired again if oPlugin._husky_bRun == false
									oPlugin._husky_bRun = !bAccept;
								},
								
								// Use this also to update the mapping
								createMessageMap : function(sMsgHandler){
									this.oMessageMap[sMsgHandler] = [];
							
									var nLen = this.aPlugins.length;
									for(var i=0; i<nLen; i++){this._doAddToMessageMap(sMsgHandler, this.aPlugins[i]);}
								},
								
								addToMessageMap : function(sMsgHandler, oPlugin){
									// cannot "ADD" unless the map is already created.
									// the message will be added automatically to the mapping when it is first passed anyways, so do not add now
									if(!this.oMessageMap[sMsgHandler]){return;}
							
									this._doAddToMessageMap(sMsgHandler, oPlugin);
								},
							
								_changeAppStatus : function(appStatus){
									this.appStatus = appStatus;
							
									// Initiate MSG_APP_READY if the application's status is being switched to READY
									if(this.appStatus == nhn.husky.APP_STATUS.READY){this.exec("MSG_APP_READY");}
								},
							
								
								_execMsgStep : function(sMsgStep, sMsg, args){
									return this._execMsgHandler ("$"+sMsgStep+"_"+sMsg, args);
								},
								_execMsgHandler : function(sMsgHandler, args){
									var i;
									if(!this.oMessageMap[sMsgHandler]){
										this.createMessageMap(sMsgHandler);
									}
							
									var aPlugins = this.oMessageMap[sMsgHandler];
									var iNumOfPlugins = aPlugins.length;
									
									if(iNumOfPlugins === 0){return true;}
							
									var bResult = true;
							
									// two similar codes were written twice due to the performace.
									if(_rxMsgAppReady.test(sMsgHandler)){
										for(i=0; i<iNumOfPlugins; i++){
											if(this._execHandler(aPlugins[i], sMsgHandler, args) === false){
												bResult = false;
												break;
											}
										}
									}else{
										for(i=0; i<iNumOfPlugins; i++){
											if(!aPlugins[i]._husky_bRun){
												aPlugins[i]._husky_bRun = true;
												if(typeof aPlugins[i].$LOCAL_BEFORE_FIRST == "function" && this._execHandler(aPlugins[i], "$LOCAL_BEFORE_FIRST", [sMsgHandler, args]) === false){continue;}
											}
							
											if(typeof aPlugins[i].$LOCAL_BEFORE_ALL == "function"){
												if(this._execHandler(aPlugins[i], "$LOCAL_BEFORE_ALL", [sMsgHandler, args]) === false){continue;}
											}
							
											if(this._execHandler(aPlugins[i], sMsgHandler, args) === false){
												bResult = false;
												break;
											}
										}
									}
									
									return bResult;
								},
							
								
								_execHandler : function(oPlugin, sHandler, args){
									this.aCallerStack.push(oPlugin);
									var bResult = oPlugin[sHandler].apply(oPlugin, args);
									this.aCallerStack.pop();

									return bResult;
								},
							
								_doAddToMessageMap : function(sMsgHandler, oPlugin){
									if(typeof oPlugin[sMsgHandler] != "function"){return;}
							
									var aMap = this.oMessageMap[sMsgHandler];
									// do not add if the plugin is already in the mapping
									for(var i=0, iLen=aMap.length; i<iLen; i++){
										if(this.oMessageMap[sMsgHandler][i] == oPlugin){return;}
									}
									this.oMessageMap[sMsgHandler][i] = oPlugin;
								},
							
								_waitForPluginReady : function(){
									var bAllReady = true;
									for(var i=0; i<this.aPlugins.length; i++){
										if(this.aPlugins[i].status == nhn.husky.PLUGIN_STATUS.NOT_READY){
											bAllReady = false;
											break;
										}
									}
									if(bAllReady){
										this._changeAppStatus(nhn.husky.APP_STATUS.READY);
									}else{
										setTimeout(this._fnWaitForPluginReady, 100);
									}
								},
							
								/**
								 * Lazy로딩을 실행한다.
								 * @param {Object} oPlugin  플러그인 인스턴스
								 * @param {String} sMsg 메시지명
								 * @param {Array} aArgs 메시지에 전달되는 매개변수
								 * @param {Event} oEvent 메시지에 전달되는 이벤트
								 * @param {Array} aFilenames Lazy로딩할 파일명
								 * @param {Integer} nIdx 로딩할 파일인덱스
								 */
								_loadLazyFiles : function(sMsg, aArgs, oEvent, aFilenames, nIdx){
									var nLen = aFilenames.length;
									if(nLen <= nIdx){
										// 파일이 모두 로딩된 상태라면 oLazyMessage 에서 정보를 제거하고 메시지를 실행한다.
										this.oLazyMessage[sMsg] = null;
										this.oApp.exec(sMsg, aArgs, oEvent);
										return;
									}
							
									var sFilename = aFilenames[nIdx];
							
									if(_htLoadedFile[sFilename]){
										// 파일이 이미 로딩된 경우 다음 파일을 로딩한다.
										this._loadLazyFiles(sMsg, aArgs, oEvent, aFilenames, nIdx+1);
									}else{
										// 파일을 Lazy로딩한다.
										// TODO: 진도컴포넌트 디펜던시 제거?
										// TODO: 응답결과가 정상적이지 않을 경우에 대한 처리?
										jindo.LazyLoading.load(nhn.husky.SE2M_Configuration.LazyLoad.sJsBaseURI+"/"+sFilename, 
											jindo.$Fn(function(sMsg, aArgs, oEvent, aFilenames, nIdx){
												// 로딩완료된 파일은 상태를 변경하고
												var sFilename = aFilenames[nIdx];
												_htLoadedFile[sFilename] = 1;
												// 다음 파일을 로딩한다.
												this._loadLazyFiles(sMsg, aArgs, oEvent, aFilenames, nIdx+1);
											}, this).bind(sMsg, aArgs, oEvent, aFilenames, nIdx),
											"utf-8"
										);
									}
								},
							
								/**
								 * Lazy로딩으로 처리할 메시지를 등록한다.
								 * @param {Array} aMsgs 메시지명
								 * @param {Array} aFilenames Lazy로딩할 파일명
								 */
								registerLazyMessage : function(aMsgs, aFilenames){
									aMsgs = aMsgs || [];
									aFilenames = aFilenames || [];
									
									for(var i = 0, sMsg, htLazyInfo; (sMsg = aMsgs[i]); i++){
										htLazyInfo = this.oLazyMessage[sMsg];
										if(htLazyInfo){
											htLazyInfo.aFilenames = htLazyInfo.aFilenames.concat(aFilenames);
										}else{
											this.oLazyMessage[sMsg] = {
												sMsg : sMsg,
												aFilenames : aFilenames
											};
										}
									}
								}
							});
							
							/**
							 * 로컬변수를 리셋한다. 
							 */
							nhn.husky.HuskyCore.reset = function(){
								_aHuskyCores = [];
								_htLoadedFile = {};
							};
							/**
							 * Lazy로딩완료된 파일목록에 파일명을 추가한다.
							 * @param {String} sFilename Lazy로딩완료될 경우 마킹할 파일명
							 */
							nhn.husky.HuskyCore.addLoadedFile = function(sFilename){
								_htLoadedFile[sFilename] = 1;
							};
							/**
							 * 플러그인 일부분을 Lazy로딩하여 쉽게 확장할 수 있도록 믹스인 기능을 제공한다. 
							 * @param {Class} oClass 믹스인을 적용할 클래스
							 * @param {Object} htMixin 덧붙일 프로토타입 데이터
							 * @param {Boolean} bOverride 원본 클래스에 프로토타입을 덮어씌울지 여부
							 */
							nhn.husky.HuskyCore.mixin = function(oClass, htMixin, bOverride){
								//TODO: error handling?
							//	if(typeof oClass != "function"){
							//		throw new Error("SmartEditor: can't mixin (oClass is invalid)");
							//	}
								var aPlugins = [], i, j, k, oHuskyCore, oPlugin;
								// 믹스인을 적용할 클래스가 이미 플러그인으로 등록된 상태라면 
								for(i = 0; (oHuskyCore = _aHuskyCores[i]); i++){
									for(j = 0; (oPlugin = oHuskyCore.aPlugins[j]); j++){
										if(oPlugin instanceof oClass){
											// 1. 메시지 추가등록을 위해 해당 플러그인 인스턴스를 담아두고
											aPlugins.push(oPlugin);
											// 2. 해당 플러그인 인스턴스에 $LOCAL_BEFORE_FIRST 핸들러가 없으면 핸들러처리를 위한 플래그를 리셋한다. 
											// if there were no $LOCAL_BEFORE_FIRST in already-loaded script, set to accept $LOCAL_BEFORE_FIRST next time as the function could be included in the lazy-loaded script.
											if(typeof oPlugin["$LOCAL_BEFORE_FIRST"] !== "function"){
												oPlugin.oApp.acceptLocalBeforeFirstAgain(oPlugin, true);
											}
										}else if(oPlugin._$superClass === oClass){	
											// [SMARTEDITORSUS-1697] 
											// jindo 클래스를 상속받아 확장된 클래스의 경우, 
											// 1. instanceof 로 확인이 안되며
											// 2. super 클래스에 mixin 처리한 것이 반영이 안된다.
											// 따라서 상속된 jindo 클래스의 인스턴스는 인스턴스에 직접 mixin 처리한다.
											if(typeof oPlugin["$LOCAL_BEFORE_FIRST"] !== "function"){
												oPlugin.oApp.acceptLocalBeforeFirstAgain(oPlugin, true);
											}
											for(k in htMixin){
												if(bOverride || !Object.prototype.hasOwnProperty.call(oPlugin, k)){
													oPlugin[k] = htMixin[k];
													if(_rxMsgHandler.test(k)){
														oPlugin.oApp.addToMessageMap(k, oPlugin);
													}
												}
											}
										}
									}
								}

								// mixin 처리
								for(k in htMixin){
									if(bOverride || !Object.prototype.hasOwnProperty.call(oClass.prototype, k)){
										oClass.prototype[k] = htMixin[k];
										// 새로 추가되는 함수가 메시지 핸들러라면 메시지 매핑에 추가 해준다.
										if(_rxMsgHandler.test(k)){
											for(j = 0; (oPlugin = aPlugins[j]); j++){
												oPlugin.oApp.addToMessageMap(k, oPlugin);
											}
										}
									}
								}
							};
							
							nhn.husky.APP_STATUS = {
								'NOT_READY' : 0,
								'WAITING_FOR_PLUGINS_READY' : 1,
								'READY' : 2
							};
							
							nhn.husky.PLUGIN_STATUS = {
								'NOT_READY' : 0,
								'READY' : 1
							};
						})();
					},
					"HuskyRange.js": function (exports, module, require) {
						/*
						Copyright (C) NAVER corp.  

						This library is free software; you can redistribute it and/or  
						modify it under the terms of the GNU Lesser General Public  
						License as published by the Free Software Foundation; either  
						version 2.1 of the License, or (at your option) any later version.  

						This library is distributed in the hope that it will be useful,  
						but WITHOUT ANY WARRANTY; without even the implied warranty of  
						MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  
						Lesser General Public License for more details.  

						You should have received a copy of the GNU Lesser General Public  
						License along with this library; if not, write to the Free Software  
						Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA  
						*/
						if(typeof window.nhn=='undefined'){window.nhn = {};}

						nhn.CurrentSelection_IE = function(){
							this.getCommonAncestorContainer = function(){
								try{
									this._oSelection = this._document.selection;
									if(this._oSelection.type == "Control"){
										return this._oSelection.createRange().item(0);
									}else{
										return this._oSelection.createRangeCollection().item(0).parentElement();
									}
								}catch(e){
									return this._document.body;
								}
							};
							
							this.isCollapsed = function(){
								this._oSelection = this._document.selection;

								return this._oSelection.type == "None";
							};
						};

						nhn.CurrentSelection_FF = function(){
							this.getCommonAncestorContainer = function(){
								return this._getSelection().commonAncestorContainer;
							};
							
							this.isCollapsed = function(){
								var oSelection = this._window.getSelection();
								
								if(oSelection.rangeCount<1){ return true; }
								return oSelection.getRangeAt(0).collapsed;
							};
							
							this._getSelection = function(){
								try{
									return this._window.getSelection().getRangeAt(0);
								}catch(e){
									return this._document.createRange();
								}
							};
						};

						nhn.CurrentSelection = new (jindo.$Class({
							$init : function(){
								var oAgentInfo = jindo.$Agent().navigator();
								if(oAgentInfo.ie && document.selection){
									nhn.CurrentSelection_IE.apply(this);
								}else{
									nhn.CurrentSelection_FF.apply(this);
								}
							},
							
							setWindow : function(oWin){
								this._window = oWin;
								this._document = oWin.document;
							}
						}))();

						/**
						 * @fileOverview This file contains a cross-browser implementation of W3C's DOM Range
						 * @name W3CDOMRange.js
						 */
						nhn.W3CDOMRange = jindo.$Class({
							$init : function(win){
								this.reset(win);
							},
							
							reset : function(win){
								this._window = win;
								this._document = this._window.document;

								this.collapsed = true;
								this.commonAncestorContainer = this._document.body;
								this.endContainer = this._document.body;
								this.endOffset = 0;
								this.startContainer = this._document.body;
								this.startOffset = 0;

								this.oBrowserSelection = new nhn.BrowserSelection(this._window);
								this.selectionLoaded = this.oBrowserSelection.selectionLoaded;
							},

							cloneContents : function(){
								var oClonedContents = this._document.createDocumentFragment();
								var oTmpContainer = this._document.createDocumentFragment();

								var aNodes = this._getNodesInRange();

								if(aNodes.length < 1){return oClonedContents;}

								var oClonedContainers = this._constructClonedTree(aNodes, oTmpContainer);

								// oTopContainer = aNodes[aNodes.length-1].parentNode and this is not part of the initial array and only those child nodes should be cloned
								var oTopContainer = oTmpContainer.firstChild;

								if(oTopContainer){
									var elCurNode = oTopContainer.firstChild;
									var elNextNode;

									while(elCurNode){
										elNextNode = elCurNode.nextSibling;
										oClonedContents.appendChild(elCurNode);
										elCurNode = elNextNode;
									}
								}

								oClonedContainers = this._splitTextEndNodes({oStartContainer: oClonedContainers.oStartContainer, iStartOffset: this.startOffset, 
																			oEndContainer: oClonedContainers.oEndContainer, iEndOffset: this.endOffset});

								if(oClonedContainers.oStartContainer && oClonedContainers.oStartContainer.previousSibling){
									nhn.DOMFix.parentNode(oClonedContainers.oStartContainer).removeChild(oClonedContainers.oStartContainer.previousSibling);
								}

								if(oClonedContainers.oEndContainer && oClonedContainers.oEndContainer.nextSibling){
									nhn.DOMFix.parentNode(oClonedContainers.oEndContainer).removeChild(oClonedContainers.oEndContainer.nextSibling);
								}

								return oClonedContents;
							},

							_constructClonedTree : function(aNodes, oClonedParentNode){
								var oClonedStartContainer = null;
								var oClonedEndContainer = null;

								var oStartContainer = this.startContainer;
								var oEndContainer = this.endContainer;

								var _recurConstructClonedTree = function(aAllNodes, iCurIdx, oClonedParentNode){

									if(iCurIdx < 0){return iCurIdx;}

									var iChildIdx = iCurIdx-1;

									var oCurNodeCloneWithChildren = aAllNodes[iCurIdx].cloneNode(false);

									if(aAllNodes[iCurIdx] == oStartContainer){oClonedStartContainer = oCurNodeCloneWithChildren;}
									if(aAllNodes[iCurIdx] == oEndContainer){oClonedEndContainer = oCurNodeCloneWithChildren;}

									while(iChildIdx >= 0 && nhn.DOMFix.parentNode(aAllNodes[iChildIdx]) == aAllNodes[iCurIdx]){
										iChildIdx = this._recurConstructClonedTree(aAllNodes, iChildIdx, oCurNodeCloneWithChildren);
									}

									// this may trigger an error message in IE when an erroneous script is inserted
									oClonedParentNode.insertBefore(oCurNodeCloneWithChildren, oClonedParentNode.firstChild);

									return iChildIdx;
								};
								this._recurConstructClonedTree = _recurConstructClonedTree;
								aNodes[aNodes.length] = nhn.DOMFix.parentNode(aNodes[aNodes.length-1]);
								this._recurConstructClonedTree(aNodes, aNodes.length-1, oClonedParentNode);

								return {oStartContainer: oClonedStartContainer, oEndContainer: oClonedEndContainer};
							},

							cloneRange : function(){
								return this._copyRange(new nhn.W3CDOMRange(this._window));
							},

							_copyRange : function(oClonedRange){
								oClonedRange.collapsed = this.collapsed;
								oClonedRange.commonAncestorContainer = this.commonAncestorContainer;
								oClonedRange.endContainer = this.endContainer;
								oClonedRange.endOffset = this.endOffset;
								oClonedRange.startContainer = this.startContainer;
								oClonedRange.startOffset = this.startOffset;
								oClonedRange._document = this._document;
								
								return oClonedRange;
							},

							collapse : function(toStart){
								if(toStart){
									this.endContainer = this.startContainer;
									this.endOffset = this.startOffset;
								}else{
									this.startContainer = this.endContainer;
									this.startOffset = this.endOffset;
								}

								this._updateRangeInfo();
							},

							compareBoundaryPoints : function(how, sourceRange){
								switch(how){
									case nhn.W3CDOMRange.START_TO_START:
										return this._compareEndPoint(this.startContainer, this.startOffset, sourceRange.startContainer, sourceRange.startOffset);
									case nhn.W3CDOMRange.START_TO_END:
										return this._compareEndPoint(this.endContainer, this.endOffset, sourceRange.startContainer, sourceRange.startOffset);
									case nhn.W3CDOMRange.END_TO_END:
										return this._compareEndPoint(this.endContainer, this.endOffset, sourceRange.endContainer, sourceRange.endOffset);
									case nhn.W3CDOMRange.END_TO_START:
										return this._compareEndPoint(this.startContainer, this.startOffset, sourceRange.endContainer, sourceRange.endOffset);
								}
							},

							_findBody : function(oNode){
								if(!oNode){return null;}
								while(oNode){
									if(oNode.tagName == "BODY"){return oNode;}
									oNode = nhn.DOMFix.parentNode(oNode);
								}
								return null;
							},

							_compareEndPoint : function(oContainerA, iOffsetA, oContainerB, iOffsetB){
								return this.oBrowserSelection.compareEndPoints(oContainerA, iOffsetA, oContainerB, iOffsetB);
						/*
								var iIdxA, iIdxB;

								if(!oContainerA || this._findBody(oContainerA) != this._document.body){
									oContainerA = this._document.body;
									iOffsetA = 0;
								}

								if(!oContainerB || this._findBody(oContainerB) != this._document.body){
									oContainerB = this._document.body;
									iOffsetB = 0;
								}

								var compareIdx = function(iIdxA, iIdxB){
									// iIdxX == -1 when the node is the commonAncestorNode
									// if iIdxA == -1
									// -> [[<nodeA>...<nodeB></nodeB>]]...</nodeA>
									// if iIdxB == -1
									// -> <nodeB>...[[<nodeA></nodeA>...</nodeB>]]
									if(iIdxB == -1){iIdxB = iIdxA+1;}
									if(iIdxA < iIdxB){return -1;}
									if(iIdxA == iIdxB){return 0;}
									return 1;
								};

								var oCommonAncestor = this._getCommonAncestorContainer(oContainerA, oContainerB);

								// ================================================================================================================================================
								//  Move up both containers so that both containers are direct child nodes of the common ancestor node. From there, just compare the offset
								// Add 0.5 for each contaienrs that has "moved up" since the actual node is wrapped by 1 or more parent nodes and therefore its position is somewhere between idx & idx+1
								// <COMMON_ANCESTOR>NODE1<P>NODE2</P>NODE3</COMMON_ANCESTOR>
								// The position of NODE2 in COMMON_ANCESTOR is somewhere between after NODE1(idx1) and before NODE3(idx2), so we let that be 1.5

								// container node A in common ancestor container
								var oNodeA = oContainerA;
								var oTmpNode = null;
								if(oNodeA != oCommonAncestor){
									while((oTmpNode = nhn.DOMFix.parentNode(oNodeA)) != oCommonAncestor){oNodeA = oTmpNode;}
									
									iIdxA = this._getPosIdx(oNodeA)+0.5;
								}else{
									iIdxA = iOffsetA;
								}
								
								// container node B in common ancestor container
								var oNodeB = oContainerB;
								if(oNodeB != oCommonAncestor){
									while((oTmpNode = nhn.DOMFix.parentNode(oNodeB)) != oCommonAncestor){oNodeB = oTmpNode;}
									
									iIdxB = this._getPosIdx(oNodeB)+0.5;
								}else{
									iIdxB = iOffsetB;
								}

								return compareIdx(iIdxA, iIdxB);
						*/
							},

							_getCommonAncestorContainer : function(oNode1, oNode2){
								oNode1 = oNode1 || this.startContainer;
								oNode2 = oNode2 || this.endContainer;
								
								var oComparingNode = oNode2;

								while(oNode1){
									while(oComparingNode){
										if(oNode1 == oComparingNode){return oNode1;}
										oComparingNode = nhn.DOMFix.parentNode(oComparingNode);
									}
									oComparingNode = oNode2;
									oNode1 = nhn.DOMFix.parentNode(oNode1);
								}

								return this._document.body;
							},

							deleteContents : function(){
								if(this.collapsed){return;}

								this._splitTextEndNodesOfTheRange();

								var aNodes = this._getNodesInRange();

								if(aNodes.length < 1){return;}
								var oPrevNode = aNodes[0].previousSibling;

								while(oPrevNode && this._isBlankTextNode(oPrevNode)){oPrevNode = oPrevNode.previousSibling;}

								var oNewStartContainer, iNewOffset = -1;
								if(!oPrevNode){
									oNewStartContainer = nhn.DOMFix.parentNode(aNodes[0]);
									iNewOffset = 0;
								}

								for(var i=0; i<aNodes.length; i++){
									var oNode = aNodes[i];

									if(!oNode.firstChild || this._isAllChildBlankText(oNode)){
										if(oNewStartContainer == oNode){
											iNewOffset = this._getPosIdx(oNewStartContainer);
											oNewStartContainer = nhn.DOMFix.parentNode(oNode);
										}
										oNode.parentNode.removeChild(oNode);
									}else{
										// move the starting point to out of the parent container if the starting point of parent container is meant to be removed
										// [<span>A]B</span>
										// -> []<span>B</span>
										// without these lines, the result would yeild to
										// -> <span>[]B</span>
										if(oNewStartContainer == oNode && iNewOffset === 0){
											iNewOffset = this._getPosIdx(oNewStartContainer);
											oNewStartContainer = nhn.DOMFix.parentNode(oNode);
										}
									}
								}

								if(!oPrevNode){
									this.setStart(oNewStartContainer, iNewOffset, true, true);
								}else{
									if(oPrevNode.tagName == "BODY"){
										this.setStartBefore(oPrevNode, true);
									}else{
										this.setStartAfter(oPrevNode, true);
									}
								}

								this.collapse(true);
							},

							extractContents : function(){
								var oClonedContents = this.cloneContents();
								this.deleteContents();
								return oClonedContents;
							},

							getInsertBeforeNodes : function(){
								var oFirstNode = null;

								var oParentContainer;

								if(this.startContainer.nodeType == "3"){
									oParentContainer = nhn.DOMFix.parentNode(this.startContainer);
									if(this.startContainer.nodeValue.length <= this.startOffset){
										oFirstNode = this.startContainer.nextSibling;
									}else{
										oFirstNode = this.startContainer.splitText(this.startOffset);
									}
								}else{
									oParentContainer = this.startContainer;
									oFirstNode = nhn.DOMFix.childNodes(this.startContainer)[this.startOffset];
								}

								if(!oFirstNode || !nhn.DOMFix.parentNode(oFirstNode)){oFirstNode = null;}
								
								return {elParent: oParentContainer, elBefore: oFirstNode};
							},
							
							insertNode : function(newNode){
								var oInsertBefore = this.getInsertBeforeNodes();

								oInsertBefore.elParent.insertBefore(newNode, oInsertBefore.elBefore);

								this.setStartBefore(newNode);
							},

							selectNode : function(refNode){
								this.reset(this._window);

								this.setStartBefore(refNode);
								this.setEndAfter(refNode);
							},

							selectNodeContents : function(refNode){
								this.reset(this._window);
								
								this.setStart(refNode, 0, true);
								this.setEnd(refNode, nhn.DOMFix.childNodes(refNode).length);
							},

							_endsNodeValidation : function(oNode, iOffset){
								if(!oNode || this._findBody(oNode) != this._document.body){throw new Error("INVALID_NODE_TYPE_ERR oNode is not part of current document");}

								if(oNode.nodeType == 3){
									if(iOffset > oNode.nodeValue.length){iOffset = oNode.nodeValue.length;}
								}else{
									if(iOffset > nhn.DOMFix.childNodes(oNode).length){iOffset = nhn.DOMFix.childNodes(oNode).length;}
								}

								return iOffset;
							},
							

							setEnd : function(refNode, offset, bSafe, bNoUpdate){
								if(!bSafe){offset = this._endsNodeValidation(refNode, offset);}

								this.endContainer = refNode;
								this.endOffset = offset;
								
								if(!bNoUpdate){
									if(!this.startContainer || this._compareEndPoint(this.startContainer, this.startOffset, this.endContainer, this.endOffset) != -1){
										this.collapse(false);
									}else{
										this._updateRangeInfo();
									}
								}
							},

							setEndAfter : function(refNode, bNoUpdate){
								if(!refNode){throw new Error("INVALID_NODE_TYPE_ERR in setEndAfter");}

								if(refNode.tagName == "BODY"){
									this.setEnd(refNode, nhn.DOMFix.childNodes(refNode).length, true, bNoUpdate);
									return;
								}
								this.setEnd(nhn.DOMFix.parentNode(refNode), this._getPosIdx(refNode)+1, true, bNoUpdate);
							},

							setEndBefore : function(refNode, bNoUpdate){
								if(!refNode){throw new Error("INVALID_NODE_TYPE_ERR in setEndBefore");}

								if(refNode.tagName == "BODY"){
									this.setEnd(refNode, 0, true, bNoUpdate);
									return;
								}

								this.setEnd(nhn.DOMFix.parentNode(refNode), this._getPosIdx(refNode), true, bNoUpdate);
							},

							setStart : function(refNode, offset, bSafe, bNoUpdate){
								if(!bSafe){offset = this._endsNodeValidation(refNode, offset);}

								this.startContainer = refNode;
								this.startOffset = offset;

								if(!bNoUpdate){
									if(!this.endContainer || this._compareEndPoint(this.startContainer, this.startOffset, this.endContainer, this.endOffset) != -1){
										this.collapse(true);
									}else{
										this._updateRangeInfo();
									}
								}
							},

							setStartAfter : function(refNode, bNoUpdate){
								if(!refNode){throw new Error("INVALID_NODE_TYPE_ERR in setStartAfter");}

								if(refNode.tagName == "BODY"){
									this.setStart(refNode, nhn.DOMFix.childNodes(refNode).length, true, bNoUpdate);
									return;
								}

								this.setStart(nhn.DOMFix.parentNode(refNode), this._getPosIdx(refNode)+1, true, bNoUpdate);
							},

							setStartBefore : function(refNode, bNoUpdate){
								if(!refNode){throw new Error("INVALID_NODE_TYPE_ERR in setStartBefore");}

								if(refNode.tagName == "BODY"){
									this.setStart(refNode, 0, true, bNoUpdate);
									return;
								}
								this.setStart(nhn.DOMFix.parentNode(refNode), this._getPosIdx(refNode), true, bNoUpdate);
							},

							surroundContents : function(newParent){
								newParent.appendChild(this.extractContents());
								this.insertNode(newParent);
								this.selectNode(newParent);
							},

							toString : function(){
								var oTmpContainer = this._document.createElement("DIV");
								oTmpContainer.appendChild(this.cloneContents());

								return oTmpContainer.textContent || oTmpContainer.innerText || "";
							},
							
							// this.oBrowserSelection.getCommonAncestorContainer which uses browser's built-in API runs faster but may return an incorrect value.
							// Call this function to fix the problem.
							//
							// In IE, the built-in API would return an incorrect value when,
							// 1. commonAncestorContainer is not selectable
							// AND
							// 2. The selected area will look the same when its child node is selected
							// eg)
							// when <P><SPAN>TEST</SPAN></p> is selected, <SPAN>TEST</SPAN> will be returned as commonAncestorContainer
							fixCommonAncestorContainer : function(){
								if(!jindo.$Agent().navigator().ie){
									return;
								}
								
								this.commonAncestorContainer = this._getCommonAncestorContainer();
							},

							_isBlankTextNode : function(oNode){
								if(oNode.nodeType == 3 && oNode.nodeValue == ""){return true;}
								return false;
							},
							
							_isAllChildBlankText : function(elNode){
								for(var i=0, nLen=elNode.childNodes.length; i<nLen; i++){
									if(!this._isBlankTextNode(elNode.childNodes[i])){return false;}
								}
								return true;
							},
							
							_getPosIdx : function(refNode){
								var idx = 0;
								for(var node = refNode.previousSibling; node; node = node.previousSibling){idx++;}

								return idx;
							},

							_updateRangeInfo : function(){
								if(!this.startContainer){
									this.reset(this._window);
									return;
								}

								// isCollapsed may not function correctly when the cursor is located,
								// (below a table) AND (at the end of the document where there's no P tag or anything else to actually hold the cursor)
								this.collapsed = this.oBrowserSelection.isCollapsed(this) || (this.startContainer === this.endContainer && this.startOffset === this.endOffset);
						//		this.collapsed = this._isCollapsed(this.startContainer, this.startOffset, this.endContainer, this.endOffset);
								this.commonAncestorContainer = this.oBrowserSelection.getCommonAncestorContainer(this);
						//		this.commonAncestorContainer = this._getCommonAncestorContainer(this.startContainer, this.endContainer);
							},
							
							_isCollapsed : function(oStartContainer, iStartOffset, oEndContainer, iEndOffset){
								var bCollapsed = false;

								if(oStartContainer == oEndContainer && iStartOffset == iEndOffset){
									bCollapsed = true;
								}else{
									var oActualStartNode = this._getActualStartNode(oStartContainer, iStartOffset);
									var oActualEndNode = this._getActualEndNode(oEndContainer, iEndOffset);

									// Take the parent nodes on the same level for easier comparison when they're next to each other
									// eg) From
									//	<A>
									//		<B>
									//			<C>
									//			</C>
									//		</B>
									//		<D>
									//			<E>
									//				<F>
									//				</F>
									//			</E>
									//		</D>
									//	</A>
									//	, it's easier to compare the position of B and D rather than C and F because they are siblings
									//
									// If the range were collapsed, oActualEndNode will precede oActualStartNode by doing this
									oActualStartNode = this._getNextNode(this._getPrevNode(oActualStartNode));
									oActualEndNode = this._getPrevNode(this._getNextNode(oActualEndNode));

									if(oActualStartNode && oActualEndNode && oActualEndNode.tagName != "BODY" && 
										(this._getNextNode(oActualEndNode) == oActualStartNode || (oActualEndNode == oActualStartNode && this._isBlankTextNode(oActualEndNode)))
									){
										bCollapsed = true;
									}
								}
								
								return bCollapsed;
							},

							_splitTextEndNodesOfTheRange : function(){
								var oEndPoints = this._splitTextEndNodes({oStartContainer: this.startContainer, iStartOffset: this.startOffset, 
																			oEndContainer: this.endContainer, iEndOffset: this.endOffset});

								this.startContainer = oEndPoints.oStartContainer;
								this.startOffset = oEndPoints.iStartOffset;

								this.endContainer = oEndPoints.oEndContainer;
								this.endOffset = oEndPoints.iEndOffset;
							},

							_splitTextEndNodes : function(oEndPoints){
								oEndPoints = this._splitStartTextNode(oEndPoints);
								oEndPoints = this._splitEndTextNode(oEndPoints);

								return oEndPoints;
							},

							_splitStartTextNode : function(oEndPoints){
								var oStartContainer = oEndPoints.oStartContainer;
								var iStartOffset = oEndPoints.iStartOffset;

								var oEndContainer = oEndPoints.oEndContainer;
								var iEndOffset = oEndPoints.iEndOffset;

								if(!oStartContainer){return oEndPoints;}
								if(oStartContainer.nodeType != 3){return oEndPoints;}
								if(iStartOffset === 0){return oEndPoints;}

								if(oStartContainer.nodeValue.length <= iStartOffset){return oEndPoints;}

								var oLastPart = oStartContainer.splitText(iStartOffset);

								if(oStartContainer == oEndContainer){
									iEndOffset -= iStartOffset;
									oEndContainer = oLastPart;
								}
								oStartContainer = oLastPart;
								iStartOffset = 0;

								return {oStartContainer: oStartContainer, iStartOffset: iStartOffset, oEndContainer: oEndContainer, iEndOffset: iEndOffset};
							},

							_splitEndTextNode : function(oEndPoints){
								var oStartContainer = oEndPoints.oStartContainer;
								var iStartOffset = oEndPoints.iStartOffset;

								var oEndContainer = oEndPoints.oEndContainer;
								var iEndOffset = oEndPoints.iEndOffset;

								if(!oEndContainer){return oEndPoints;}
								if(oEndContainer.nodeType != 3){return oEndPoints;}

								if(iEndOffset >= oEndContainer.nodeValue.length){return oEndPoints;}
								if(iEndOffset === 0){return oEndPoints;}

								oEndContainer.splitText(iEndOffset);

								return {oStartContainer: oStartContainer, iStartOffset: iStartOffset, oEndContainer: oEndContainer, iEndOffset: iEndOffset};
							},
							
							_getNodesInRange : function(){
								if(this.collapsed){return [];}

								var oStartNode = this._getActualStartNode(this.startContainer, this.startOffset);
								var oEndNode = this._getActualEndNode(this.endContainer, this.endOffset);

								return this._getNodesBetween(oStartNode, oEndNode);
							},

							_getActualStartNode : function(oStartContainer, iStartOffset){
								var oStartNode = oStartContainer;

								if(oStartContainer.nodeType == 3){
									if(iStartOffset >= oStartContainer.nodeValue.length){
										oStartNode = this._getNextNode(oStartContainer);
										if(oStartNode.tagName == "BODY"){oStartNode = null;}
									}else{
										oStartNode = oStartContainer;
									}
								}else{
									if(iStartOffset < nhn.DOMFix.childNodes(oStartContainer).length){
										oStartNode = nhn.DOMFix.childNodes(oStartContainer)[iStartOffset];
									}else{
										oStartNode = this._getNextNode(oStartContainer);
										if(oStartNode.tagName == "BODY"){oStartNode = null;}
									}
								}

								return oStartNode;
							},

							_getActualEndNode : function(oEndContainer, iEndOffset){
								var oEndNode = oEndContainer;

								if(iEndOffset === 0){
									oEndNode = this._getPrevNode(oEndContainer);
									if(oEndNode.tagName == "BODY"){oEndNode = null;}
								}else if(oEndContainer.nodeType == 3){
									oEndNode = oEndContainer;
								}else{
									oEndNode = nhn.DOMFix.childNodes(oEndContainer)[iEndOffset-1];
								}

								return oEndNode;
							},

							_getNextNode : function(oNode){
								if(!oNode || oNode.tagName == "BODY"){return this._document.body;}

								if(oNode.nextSibling){return oNode.nextSibling;}
								
								return this._getNextNode(nhn.DOMFix.parentNode(oNode));
							},

							_getPrevNode : function(oNode){
								if(!oNode || oNode.tagName == "BODY"){return this._document.body;}

								if(oNode.previousSibling){return oNode.previousSibling;}
								
								return this._getPrevNode(nhn.DOMFix.parentNode(oNode));
							},

							// includes partially selected
							// for <div id="a"><div id="b"></div></div><div id="c"></div>, _getNodesBetween(b, c) will yield to b, "a" and c
							_getNodesBetween : function(oStartNode, oEndNode){
								var aNodesBetween = [];
								this._nNodesBetweenLen = 0;

								if(!oStartNode || !oEndNode){return aNodesBetween;}

								// IE may throw an exception on "oCurNode = oCurNode.nextSibling;" when oCurNode is 'invalid', not null or undefined but somehow 'invalid'.
								// It happened during browser's build-in UNDO with control range selected(table).
								try{
									this._recurGetNextNodesUntil(oStartNode, oEndNode, aNodesBetween);
								}catch(e){
									return [];
								}
								
								return aNodesBetween;
							},

							_recurGetNextNodesUntil : function(oNode, oEndNode, aNodesBetween){
								if(!oNode){return false;}

								if(!this._recurGetChildNodesUntil(oNode, oEndNode, aNodesBetween)){return false;}

								var oNextToChk = oNode.nextSibling;
								
								while(!oNextToChk){
									if(!(oNode = nhn.DOMFix.parentNode(oNode))){return false;}

									aNodesBetween[this._nNodesBetweenLen++] = oNode;

									if(oNode == oEndNode){return false;}

									oNextToChk = oNode.nextSibling;
								}

								return this._recurGetNextNodesUntil(oNextToChk, oEndNode, aNodesBetween);
							},

							_recurGetChildNodesUntil : function(oNode, oEndNode, aNodesBetween){
								if(!oNode){return false;}

								var bEndFound = false;
								var oCurNode = oNode;
								if(oCurNode.firstChild){
									oCurNode = oCurNode.firstChild;
									while(oCurNode){
										if(!this._recurGetChildNodesUntil(oCurNode, oEndNode, aNodesBetween)){
											bEndFound = true;
											break;
										}
										oCurNode = oCurNode.nextSibling;
									}
								}
								aNodesBetween[this._nNodesBetweenLen++] = oNode;

								if(bEndFound){return false;}
								if(oNode == oEndNode){return false;}

								return true;
							}
						});

						nhn.W3CDOMRange.START_TO_START = 0;
						nhn.W3CDOMRange.START_TO_END = 1;
						nhn.W3CDOMRange.END_TO_END = 2;
						nhn.W3CDOMRange.END_TO_START = 3;


						/**
						 * @fileOverview This file contains a cross-browser function that implements all of the W3C's DOM Range specification and some more
						 * @name HuskyRange.js
						 */
						nhn.HuskyRange = jindo.$Class({
							_rxCursorHolder : /^(?:\uFEFF|\u00A0|\u200B|<br>)$/i,
							_rxTextAlign : /text-align:[^"';]*;?/i,

							setWindow : function(win){
								this.reset(win || window);
							},

							$init : function(win){
								this.HUSKY_BOOMARK_START_ID_PREFIX = "husky_bookmark_start_";
								this.HUSKY_BOOMARK_END_ID_PREFIX = "husky_bookmark_end_";

								this.sBlockElement = "P|DIV|LI|H[1-6]|PRE";
								this.sBlockContainer = "BODY|TABLE|TH|TR|TD|UL|OL|BLOCKQUOTE|FORM";

								this.rxBlockElement = new RegExp("^("+this.sBlockElement+")$");
								this.rxBlockContainer = new RegExp("^("+this.sBlockContainer+")$");
								this.rxLineBreaker = new RegExp("^("+this.sBlockElement+"|"+this.sBlockContainer+")$");
								this.rxHasBlock = new RegExp("(?:<(?:"+this.sBlockElement+"|"+this.sBlockContainer+").*?>|style=[\"']?[^>]*?(?:display\\s?:\\s?block)[^>]*?[\"']?)", "i");

								this.setWindow(win);
							},

							select : function(){
								try{
									this.oBrowserSelection.selectRange(this);
								}catch(e){
									// console.warn("[WARNING] 잘못된 범위가 지정 됨!");
								}
							},

							setFromSelection : function(iNum){
								this.setRange(this.oBrowserSelection.getRangeAt(iNum), true);
							},

							setRange : function(oW3CRange, bSafe){
								this.reset(this._window);

								this.setStart(oW3CRange.startContainer, oW3CRange.startOffset, bSafe, true);
								this.setEnd(oW3CRange.endContainer, oW3CRange.endOffset, bSafe);
							},

							setEndNodes : function(oSNode, oENode){
								this.reset(this._window);

								this.setEndAfter(oENode, true);
								this.setStartBefore(oSNode);
							},
							
							splitTextAtBothEnds : function(){
								this._splitTextEndNodesOfTheRange();
							},

							getStartNode : function(){
								if(this.collapsed){
									if(this.startContainer.nodeType == 3){
										if(this.startOffset === 0){return null;}
										if(this.startContainer.nodeValue.length <= this.startOffset){return null;}
										return this.startContainer;
									}
									return null;
								}
								
								if(this.startContainer.nodeType == 3){
									if(this.startOffset >= this.startContainer.nodeValue.length){return this._getNextNode(this.startContainer);}
									return this.startContainer;
								}else{
									if(this.startOffset >= nhn.DOMFix.childNodes(this.startContainer).length){return this._getNextNode(this.startContainer);}
									return nhn.DOMFix.childNodes(this.startContainer)[this.startOffset];
								}
							},
							
							getEndNode : function(){
								if(this.collapsed){return this.getStartNode();}
								
								if(this.endContainer.nodeType == 3){
									if(this.endOffset === 0){return this._getPrevNode(this.endContainer);}
									return this.endContainer;
								}else{
									if(this.endOffset === 0){return this._getPrevNode(this.endContainer);}
									return nhn.DOMFix.childNodes(this.endContainer)[this.endOffset-1];
								}
							},

							getNodeAroundRange : function(bBefore, bStrict){
								if(!this.collapsed){return this.getStartNode();}

								if(this.startContainer && this.startContainer.nodeType == 3){return this.startContainer;}
								//if(this.collapsed && this.startContainer && this.startContainer.nodeType == 3) return this.startContainer;
								//if(!this.collapsed || (this.startContainer && this.startContainer.nodeType == 3)) return this.getStartNode();

								var oBeforeRange, oAfterRange, oResult;

								if(this.startOffset >= nhn.DOMFix.childNodes(this.startContainer).length){
									oAfterRange = this._getNextNode(this.startContainer);
								}else{
									oAfterRange = nhn.DOMFix.childNodes(this.startContainer)[this.startOffset];
								}

								if(this.endOffset === 0){
									oBeforeRange = this._getPrevNode(this.endContainer);
								}else{
									oBeforeRange = nhn.DOMFix.childNodes(this.endContainer)[this.endOffset-1];
								}

								if(bBefore){
									oResult = oBeforeRange;
									if(!oResult && !bStrict){oResult = oAfterRange;}
								}else{
									oResult = oAfterRange;
									if(!oResult && !bStrict){oResult = oBeforeRange;}
								}

								return oResult;
							},

							_getXPath : function(elNode){
								var sXPath = "";
								
								while(elNode && elNode.nodeType == 1){
									sXPath = "/" + elNode.tagName+"["+this._getPosIdx4XPath(elNode)+"]" + sXPath;
									elNode = nhn.DOMFix.parentNode(elNode);
								}
								
								return sXPath;
							},
							
							_getPosIdx4XPath : function(refNode){
								var idx = 0;
								for(var node = refNode.previousSibling; node; node = node.previousSibling){
									if(node.tagName == refNode.tagName){idx++;}
								}

								return idx;
							},
							
							// this was written specifically for XPath Bookmark and it may not perform correctly for general purposes
							_evaluateXPath : function(sXPath, oDoc){
								sXPath = sXPath.substring(1, sXPath.length-1);
								var aXPath = sXPath.split(/\//);
								var elNode = oDoc.body;

								for(var i=2; i<aXPath.length && elNode; i++){
									aXPath[i].match(/([^[]+)\[(\d+)/i);
									var sTagName = RegExp.$1;
									var nIdx = RegExp.$2;

									var aAllNodes = nhn.DOMFix.childNodes(elNode);
									var aNodes = [];
									var nLength = aAllNodes.length;
									var nCount = 0;
									for(var ii=0; ii<nLength; ii++){
										if(aAllNodes[ii].tagName == sTagName){aNodes[nCount++] = aAllNodes[ii];}
									}

									if(aNodes.length < nIdx){
										elNode = null;
									}else{
										elNode = aNodes[nIdx];
									}
								}

								return elNode;
							},

							_evaluateXPathBookmark : function(oBookmark){
								var sXPath = oBookmark["sXPath"];
								var nTextNodeIdx = oBookmark["nTextNodeIdx"];
								var nOffset = oBookmark["nOffset"];

								var elContainer = this._evaluateXPath(sXPath, this._document);

								if(nTextNodeIdx > -1 && elContainer){
									var aChildNodes = nhn.DOMFix.childNodes(elContainer);
									var elNode = null;
									
									var nIdx = nTextNodeIdx;
									var nOffsetLeft = nOffset;
									
									while((elNode = aChildNodes[nIdx]) && elNode.nodeType == 3 && elNode.nodeValue.length < nOffsetLeft){
										nOffsetLeft -= elNode.nodeValue.length;
										nIdx++;
									}
									
									elContainer = nhn.DOMFix.childNodes(elContainer)[nIdx];
									nOffset = nOffsetLeft;
								}

								if(!elContainer){
									elContainer = this._document.body;
									nOffset = 0;
								}
								return {elContainer: elContainer, nOffset: nOffset};
							},
							
							// this was written specifically for XPath Bookmark and it may not perform correctly for general purposes
							getXPathBookmark : function(){
								var nTextNodeIdx1 = -1;
								var htEndPt1 = {elContainer: this.startContainer, nOffset: this.startOffset};
								var elNode1 = this.startContainer;
								if(elNode1.nodeType == 3){
									htEndPt1 = this._getFixedStartTextNode();
									nTextNodeIdx1 = this._getPosIdx(htEndPt1.elContainer);
									elNode1 = nhn.DOMFix.parentNode(elNode1);
								}
								var sXPathNode1 = this._getXPath(elNode1);
								var oBookmark1 = {sXPath:sXPathNode1, nTextNodeIdx:nTextNodeIdx1, nOffset: htEndPt1.nOffset};
								var oBookmark2;

								if(this.collapsed){
									oBookmark2 = {sXPath:sXPathNode1, nTextNodeIdx:nTextNodeIdx1, nOffset: htEndPt1.nOffset};
								}else{
									var nTextNodeIdx2 = -1;
									var htEndPt2 = {elContainer: this.endContainer, nOffset: this.endOffset};
									var elNode2 = this.endContainer;
									if(elNode2.nodeType == 3){
										htEndPt2 = this._getFixedEndTextNode();
										nTextNodeIdx2 = this._getPosIdx(htEndPt2.elContainer);
										elNode2 = nhn.DOMFix.parentNode(elNode2);
									}
									var sXPathNode2 = this._getXPath(elNode2);
									oBookmark2 = {sXPath:sXPathNode2, nTextNodeIdx:nTextNodeIdx2, nOffset: htEndPt2.nOffset};
								}
								return [oBookmark1, oBookmark2];
							},
							
							moveToXPathBookmark : function(aBookmark){
								if(!aBookmark){return false;}

								var oBookmarkInfo1 = this._evaluateXPathBookmark(aBookmark[0]);
								var oBookmarkInfo2 = this._evaluateXPathBookmark(aBookmark[1]);

								if(!oBookmarkInfo1["elContainer"] || !oBookmarkInfo2["elContainer"]){return;}

								this.startContainer = oBookmarkInfo1["elContainer"];
								this.startOffset = oBookmarkInfo1["nOffset"];

								this.endContainer = oBookmarkInfo2["elContainer"];
								this.endOffset = oBookmarkInfo2["nOffset"];
								
								return true;
							},
							
							_getFixedTextContainer : function(elNode, nOffset){
								while(elNode && elNode.nodeType == 3 && elNode.previousSibling && elNode.previousSibling.nodeType == 3){
									nOffset += elNode.previousSibling.nodeValue.length;
									elNode = elNode.previousSibling;
								}
								
								return {elContainer:elNode, nOffset:nOffset};
							},
							
							_getFixedStartTextNode : function(){
								return this._getFixedTextContainer(this.startContainer, this.startOffset);
							},
							
							_getFixedEndTextNode : function(){
								return this._getFixedTextContainer(this.endContainer, this.endOffset);
							},
							
							placeStringBookmark : function(){
								if(this.collapsed || jindo.$Agent().navigator().ie || jindo.$Agent().navigator().firefox){
									return this.placeStringBookmark_NonWebkit();
								}else{
									return this.placeStringBookmark_Webkit();
								}
							},

							placeStringBookmark_NonWebkit : function(){
								var sTmpId = (new Date()).getTime();

								var oInsertionPoint = this.cloneRange();
								oInsertionPoint.collapseToEnd();
								var oEndMarker = this._document.createElement("SPAN");
								oEndMarker.id = this.HUSKY_BOOMARK_END_ID_PREFIX+sTmpId;
								oInsertionPoint.insertNode(oEndMarker);

								oInsertionPoint = this.cloneRange();
								oInsertionPoint.collapseToStart();
								var oStartMarker = this._document.createElement("SPAN");
								oStartMarker.id = this.HUSKY_BOOMARK_START_ID_PREFIX+sTmpId;
								oInsertionPoint.insertNode(oStartMarker);

								// IE에서 빈 SPAN의 앞뒤로 커서가 이동하지 않아 문제가 발생 할 수 있어, 보이지 않는 특수 문자를 임시로 넣어 줌.
								if(jindo.$Agent().navigator().ie){
									// SPAN의 위치가 TD와 TD 사이에 있을 경우, 텍스트 삽입 시 알수 없는 오류가 발생한다.
									// TD와 TD사이에서는 텍스트 삽입이 필요 없음으로 그냥 try/catch로 처리
									try{
										oStartMarker.innerHTML = unescape("%uFEFF");
									}catch(e){
										// console.warn(e);
									}
									
									try{
										oEndMarker.innerHTML = unescape("%uFEFF");
									}catch(e){
										// console.warn(e);
									}
								}
								this.moveToBookmark(sTmpId);

								return sTmpId;
							},
							
							placeStringBookmark_Webkit : function(){
								var sTmpId = (new Date()).getTime();

								var elInsertBefore, elInsertParent;

								// Do not insert the bookmarks between TDs as it will break the rendering in Chrome/Safari
								// -> modify the insertion position from [<td>abc</td>]<td>abc</td> to <td>[abc]</td><td>abc</td>
								var oInsertionPoint = this.cloneRange();
								oInsertionPoint.collapseToEnd();
								elInsertBefore = this._document.createTextNode("");
								oInsertionPoint.insertNode(elInsertBefore);
								elInsertParent = elInsertBefore.parentNode;
								if(elInsertBefore.previousSibling && elInsertBefore.previousSibling.tagName == "TD"){
									elInsertParent = elInsertBefore.previousSibling;
									elInsertBefore = null;
								}
								var oEndMarker = this._document.createElement("SPAN");
								oEndMarker.id = this.HUSKY_BOOMARK_END_ID_PREFIX+sTmpId;
								elInsertParent.insertBefore(oEndMarker, elInsertBefore);

								oInsertionPoint = this.cloneRange();
								oInsertionPoint.collapseToStart();
								elInsertBefore = this._document.createTextNode("");
								oInsertionPoint.insertNode(elInsertBefore);
								elInsertParent = elInsertBefore.parentNode;
								if(elInsertBefore.nextSibling && elInsertBefore.nextSibling.tagName == "TD"){
									elInsertParent = elInsertBefore.nextSibling;
									elInsertBefore = elInsertParent.firstChild;
								}
								var oStartMarker = this._document.createElement("SPAN");
								oStartMarker.id = this.HUSKY_BOOMARK_START_ID_PREFIX+sTmpId;
								elInsertParent.insertBefore(oStartMarker, elInsertBefore);

								//elInsertBefore.parentNode.removeChild(elInsertBefore);
								
								this.moveToBookmark(sTmpId);

								return sTmpId;
							},

							cloneRange : function(){
								return this._copyRange(new nhn.HuskyRange(this._window));
							},

							moveToBookmark : function(vBookmark){
								if(typeof(vBookmark) != "object"){
									return this.moveToStringBookmark(vBookmark);
								}else{
									return this.moveToXPathBookmark(vBookmark);
								}
							},

							getStringBookmark : function(sBookmarkID, bEndBookmark){
								if(bEndBookmark){
									return this._document.getElementById(this.HUSKY_BOOMARK_END_ID_PREFIX+sBookmarkID);
								}else{
									return this._document.getElementById(this.HUSKY_BOOMARK_START_ID_PREFIX+sBookmarkID);
								}
							},
							
							moveToStringBookmark : function(sBookmarkID, bIncludeBookmark){
								var oStartMarker = this.getStringBookmark(sBookmarkID);
								var oEndMarker = this.getStringBookmark(sBookmarkID, true);

								if(!oStartMarker || !oEndMarker){return false;}

								this.reset(this._window);

								if(bIncludeBookmark){
									this.setEndAfter(oEndMarker);
									this.setStartBefore(oStartMarker);
								}else{
									this.setEndBefore(oEndMarker);
									this.setStartAfter(oStartMarker);
								}
								return true;
							},

							removeStringBookmark : function(sBookmarkID){
							/*
								var oStartMarker = this._document.getElementById(this.HUSKY_BOOMARK_START_ID_PREFIX+sBookmarkID);
								var oEndMarker = this._document.getElementById(this.HUSKY_BOOMARK_END_ID_PREFIX+sBookmarkID);

								if(oStartMarker) nhn.DOMFix.parentNode(oStartMarker).removeChild(oStartMarker);
								if(oEndMarker) nhn.DOMFix.parentNode(oEndMarker).removeChild(oEndMarker);
							*/
								this._removeAll(this.HUSKY_BOOMARK_START_ID_PREFIX+sBookmarkID);
								this._removeAll(this.HUSKY_BOOMARK_END_ID_PREFIX+sBookmarkID);
							},
							
							_removeAll : function(sID){
								var elNode;
								while((elNode = this._document.getElementById(sID))){
									elNode.parentNode.removeChild(elNode);
								}
							},

							collapseToStart : function(){
								this.collapse(true);
							},
							
							collapseToEnd : function(){
								this.collapse(false);
							},

							createAndInsertNode : function(sTagName){
								var tmpNode = this._document.createElement(sTagName);
								this.insertNode(tmpNode);
								return tmpNode;
							},

							getNodes : function(bSplitTextEndNodes, fnFilter){
								if(bSplitTextEndNodes){this._splitTextEndNodesOfTheRange();}

								var aAllNodes = this._getNodesInRange();
								var aFilteredNodes = [];

								if(!fnFilter){return aAllNodes;}

								for(var i=0; i<aAllNodes.length; i++){
									if(fnFilter(aAllNodes[i])){aFilteredNodes[aFilteredNodes.length] = aAllNodes[i];}
								}

								return aFilteredNodes;
							},

							getTextNodes : function(bSplitTextEndNodes){
								var txtFilter = function(oNode){
									if (oNode.nodeType == 3 && oNode.nodeValue != "\n" && oNode.nodeValue != ""){
										return true;
									}else{
										return false;
									}
								};

								return this.getNodes(bSplitTextEndNodes, txtFilter);
							},

							surroundContentsWithNewNode : function(sTagName){
								var oNewParent = this._document.createElement(sTagName);
								this.surroundContents(oNewParent);
								return oNewParent;
							},

							isRangeinRange : function(oAnoterRange, bIncludePartlySelected){
								var startToStart = this.compareBoundaryPoints(this.W3CDOMRange.START_TO_START, oAnoterRange);
								var startToEnd = this.compareBoundaryPoints(this.W3CDOMRange.START_TO_END, oAnoterRange);
								var endToStart = this.compareBoundaryPoints(this.W3CDOMRange.ND_TO_START, oAnoterRange);
								var endToEnd = this.compareBoundaryPoints(this.W3CDOMRange.END_TO_END, oAnoterRange);

								if(startToStart <= 0 && endToEnd >= 0){return true;}

								if(bIncludePartlySelected){
									if(startToEnd == 1){return false;}
									if(endToStart == -1){return false;}
									return true;
								}

								return false;
							},

							isNodeInRange : function(oNode, bIncludePartlySelected, bContentOnly){
								var oTmpRange = new nhn.HuskyRange(this._window);

								if(bContentOnly && oNode.firstChild){
									oTmpRange.setStartBefore(oNode.firstChild);
									oTmpRange.setEndAfter(oNode.lastChild);
								}else{
									oTmpRange.selectNode(oNode);
								}

								return this.isRangeInRange(oTmpRange, bIncludePartlySelected);
							},		

							pasteText : function(sText){
								this.pasteHTML(sText.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/ /g, "&nbsp;").replace(/"/g, "&quot;"));
							},

							/**
							 * TODO: 왜 clone 으로 조작할까?
							 * @param {String}	sHTML	삽입할 HTML
							 * @param {Boolean}	bBlock	HTML 삽입시 강제로 block 요소 처리할지 여부(true 이면 P태그 안에 삽입될 경우, P태그를 무조건 쪼개고 그 사이에 DIV태그로 감싸서 삽입한다.)
							 */
							pasteHTML : function(sHTML, bBlock){
								var oTmpDiv = this._document.createElement("DIV");
								oTmpDiv.innerHTML = sHTML;
								
								if(!oTmpDiv.firstChild){
									this.deleteContents();
									return;
								}

								// getLineInfo 전에 북마크를 삽입하지 않으면 IE에서 oLineBreaker가 P태그 바깥으로 잡히는 경우가 있음(P태그에 아무것도 없을때)
								var clone = this.cloneRange();
								var sBM = clone.placeStringBookmark();

								// [SMARTEDITORSUS-1960] PrivateTag, 템플릿삽입등 P태그안에 block 요소 삽입과 관련된 처리 
								// P태그인 경우, block요소가 들어오면 안된다.
								// 때문에 현재 위치의 컨테이너가 P태그이고 컨텐츠 내용이 block 요소인 경우 P태그를 쪼개고 그 사이에 컨텐츠를 DIV로 감싸서 넣도록 처리한다.
								// [SMARTEDITORSUS-2026][SMARTEDITORSUS-2061] bBlock = true 이면 삽입되는 HTML 이 block 요소가 아니더라도 무조건 P태그를 쪼개서 DIV로 감싸도록 한다.
								var oLineInfo = clone.getLineInfo(),
									oStart = oLineInfo.oStart,
									oEnd = oLineInfo.oEnd;
								if(oStart.oLineBreaker && oStart.oLineBreaker.nodeName === "P" && (bBlock || clone.rxHasBlock.test(sHTML))){
									// [SMARTEDITORSUS-2169] 선택영역 삭제시 oStart.oLineBreaker도 DOM 트리에서 제거될 수 있기 때문에 필요한 노드를 미리 참조해둔다.
									var oParentNode = oStart.oLineBreaker.parentNode,
										oNextSibling = oStart.oLineBreaker.nextSibling;

									// 선택영역을 조작해야 하므로 현재 선택된 요소들을 제거한다.
									clone.deleteContents();

									// 동일한 라인에 있으면 뒷부분은 쪼개서 다음 라인으로 삽입한다.
									if(oStart.oLineBreaker === oEnd.oLineBreaker){
										var elBM = clone.getStringBookmark(sBM);
										clone.setEndNodes(elBM, oEnd.oLineBreaker);
										var oNextContents = clone.extractContents(),
											oNextFirst = oNextContents.firstChild;	// oNextSibling 을 교체하기 위해 쪼개진 요소 첫번째 노드를 미리 참조해둔다.

										// 쪼갠 부분을 삽입하고
										if(oNextSibling){
											oParentNode.insertBefore(oNextContents, oNextSibling);
										}else{
											oParentNode.appendChild(oNextContents);
										}
										// [SMARTEDITORSUS-2145] oNextSibling 을 쪼갠 부분의 첫번째 노드로 교체한다. 
										oNextSibling = oNextFirst;
									}

									// 선택영역 앞쪽이 속한 P태그에서 style과 align 정보를 복사한다.
									// 크롬의 경우 div의 style 에 text-align 이 있으면 align 속성은 무시되는데 
									// div 안의 block 요소는 text-align 의 대상이 아니라 정렬되지 않는 문제가 있기 때문에
									// style 복사할 때 text-align 속성은 제외한다.
									oTmpDiv.style.cssText = oStart.oLineBreaker.style.cssText.replace(this._rxTextAlign, '');	// text-align 제외
									oTmpDiv.align = oStart.oLineBreaker.align;	// align 복사

									// 컨텐츠 삽입
									if(oNextSibling){
										oParentNode.insertBefore(oTmpDiv, oNextSibling);
									}else{
										oParentNode.appendChild(oTmpDiv);
									}

									// 컨텐츠 삽입 후에 북마크를 지운다.
									// 컨텐츠 삽입 전에 지우면 컨텐츠 삽입시 oNextSibling 가 북마크로 잡히는 경우 에러가 발생할 수 있음 
									clone.removeStringBookmark(sBM);

									// 컨텐츠 삽입 후 윗라인 P태그에 아무런 내용이 없으면 제거한다.
									this._removeEmptyP(this._getPrevElement(oTmpDiv));
									// 아래 라인 P태그에 아무런 내용이 없는 경우는 그 다음 아래 라인이 있을때만 제거한다.
									// 아래 라인이 아예없으면 IE에서 커서가 들어가지 않기 때문에 라인을 추가해준다.
									var elNextLine = this._getNextElement(oTmpDiv);
									if(elNextLine){
										var elAfterNext = this._getNextElement(elNextLine);
										if(elAfterNext && this._removeEmptyP(elNextLine)){
											elNextLine = elAfterNext;	// 제거되었을 경우만 elNextLine 재할당
										}
									}else{
										// 아래 라인이 없으면 윗 라인 스타일을 복사하여 추가해준다. 
										elNextLine = this._document.createElement("P");
										elNextLine.style.cssText = oStart.oLineBreaker.style.cssText;
										elNextLine.align = oStart.oLineBreaker.align;
										oParentNode.appendChild(elNextLine);
									}

									// 커서를 다음라인으로 앞쪽으로 위치시킨다.
									if(elNextLine.innerHTML === ""){
										// 크롬에서 빈 <p></p> 를 선택해서 collapseToStart 하면 윗라인으로 이동하기 때문에 비어있으면 \uFEFF 를 넣어준다.
										elNextLine.innerHTML = (jindo.$Agent().navigator().ie && jindo.$Agent().navigator().version > 8) ? "\u200B" : "\uFEFF";
									}
									this.selectNodeContents(elNextLine);
									this.collapseToStart();
									
									// IE7에서 커서가 다음라인 p태그 앞쪽이 아닌 div태그 끝쪽으로 자동으로 옮겨가는 경우가 있어서
									// 커서가 멋대로 이동하지 않도록 임시북마크를 넣었다가 바로 빼준다.
									// (주의) 북마크를 넣었다 빼면 IE10은 다음라인 p태그 끝쪽으로 이동되기 때문에 IE7인 경우만 넣어줌 
									// [SMARTEDITORSUS-2043] SE_EditingArea_WYSIWYG.$ON_PASTE_HTML 에서 IE8의 경우만 삽입시 뒤에 \uFEFF가 추가로 붙어서 들어오는데
									// 이로 인해 템플릿과 커서사이가 한줄 벌어지는 문제가 있어서 \uFEFF 추가하는 부분을 삭제하니 커서가 IE7과 동일하게 동작하여 IE8도 임시북마크처리함
									if(jindo.$Agent().navigator().ie && jindo.$Agent().navigator().version < 9){
										sBM = this.placeStringBookmark();
										this.removeStringBookmark(sBM);
									}
								}else{
									var oFirstNode = oTmpDiv.firstChild;
									var oLastNode = oTmpDiv.lastChild;
									
									this.collapseToStart();
									
									while(oTmpDiv.lastChild){this.insertNode(oTmpDiv.lastChild);}
									
									this.setEndNodes(oFirstNode, oLastNode);
									
									// delete the content later as deleting it first may mass up the insertion point
									// eg) <p>[A]BCD</p> ---paste O---> O<p>BCD</p>
									clone.moveToBookmark(sBM);
									clone.deleteContents();
									clone.removeStringBookmark(sBM);
								}
							},

							/**
							 * 비어있는 P태그이면 제거한다.
							 * @param {Element} el 검사할 Element
							 * @returns {Boolean} 제거되었다면 true 를 반환한다.
							 */
							_removeEmptyP : function(el){
								if(el && el.nodeName === "P"){
									var sInner = el.innerHTML;
									if(sInner === "" || this._rxCursorHolder.test(sInner)){
										el.parentNode.removeChild(el);
										return true;
									}
								}
							},

							/**
							 * 인접한 Element 노드를 찾는다.
							 * @param  {Node}	oNode 기준 노드
							 * @param  {Boolean} bPrev 앞뒤여부(true면 앞, false면 뒤)
							 * @return {Element} 인접한 Element, 없으면 null 반환 
							 */
							_getSiblingElement : function(oNode, bPrev){
								if(!oNode){
									return null;
								}
								
								var oSibling = oNode[bPrev ? "previousSibling" : "nextSibling"];
								if(oSibling && oSibling.nodeType === 1){
									return oSibling;
								}else{
									return arguments.callee(oSibling, bPrev);
								}
							},

							/**
							 * 앞쪽 인접한 Element 노드를 찾는다.
							 * @param  {Node}	oNode 기준 노드
							 * @return {Element} 인접한 Element, 없으면 null 반환 
							 */
							_getPrevElement : function(oNode){
								return this._getSiblingElement(oNode, true);
							},

							/**
							 * 뒤쪽 인접한 Element 노드를 찾는다.
							 * @param  {Node}	oNode 기준 노드
							 * @return {Element} 인접한 Element, 없으면 null 반환 
							 */
							_getNextElement : function(oNode){
								return this._getSiblingElement(oNode, false);
							},

							toString : function(){
								this.toString = nhn.W3CDOMRange.prototype.toString;
								return this.toString();
							},
							
							toHTMLString : function(){
								var oTmpContainer = this._document.createElement("DIV");
								oTmpContainer.appendChild(this.cloneContents());

								return oTmpContainer.innerHTML;
							},

							findAncestorByTagName : function(sTagName){
								var oNode = this.commonAncestorContainer;
								while(oNode && oNode.tagName != sTagName){oNode = nhn.DOMFix.parentNode(oNode);}
								
								return oNode;
							},

							selectNodeContents : function(oNode){
								if(!oNode){return;}

								var oFirstNode = oNode.firstChild?oNode.firstChild:oNode;
								var oLastNode = oNode.lastChild?oNode.lastChild:oNode;

								this.reset(this._window);
								if(oFirstNode.nodeType == 3){
									this.setStart(oFirstNode, 0, true);
								}else{
									this.setStartBefore(oFirstNode);
								}
								
								if(oLastNode.nodeType == 3){
									this.setEnd(oLastNode, oLastNode.nodeValue.length, true);
								}else{
									this.setEndAfter(oLastNode);
								}
							},

							/**
							 * 노드의 취소선/밑줄 정보를 확인한다
							 * 관련 BTS [SMARTEDITORSUS-26]
							 * @param {Node} 	oNode	취소선/밑줄을 확인할 노드
							 * @param {String}	sValue 	textDecoration 정보
							 * @see nhn.HuskyRange#_checkTextDecoration
							 */
							_hasTextDecoration : function(oNode, sValue){
								if(!oNode || !oNode.style){
									return false;
								}
								
								if(oNode.style.textDecoration.indexOf(sValue) > -1){
									return true;
								}
								
								if(sValue === "underline" && oNode.tagName === "U"){
									return true;
								}
								
								if(sValue === "line-through" && (oNode.tagName === "S" || oNode.tagName === "STRIKE")){
									return true;
								}
								
								return false;
							},
							
							/**
							 * 노드에 취소선/밑줄을 적용한다
							 * 관련 BTS [SMARTEDITORSUS-26]
							 * [FF] 노드의 Style 에 textDecoration 을 추가한다
							 * [FF 외] U/STRIKE 태그를 추가한다
							 * @param {Node} 	oNode	취소선/밑줄을 적용할 노드
							 * @param {String}	sValue 	textDecoration 정보
							 * @see nhn.HuskyRange#_checkTextDecoration
							 */
							_setTextDecoration : function(oNode, sValue){
								if (jindo.$Agent().navigator().firefox) {	// FF
									oNode.style.textDecoration = (oNode.style.textDecoration) ? oNode.style.textDecoration + " " + sValue : sValue;
								}
								else{
									if(sValue === "underline"){
										oNode.innerHTML = "<U>" + oNode.innerHTML + "</U>"
									}else if(sValue === "line-through"){
										oNode.innerHTML = "<STRIKE>" + oNode.innerHTML + "</STRIKE>"
									}
								}
							},
								
							/**
							 * 인자로 전달받은 노드 상위의 취소선/밑줄 정보를 확인하여 노드에 적용한다
							 * 관련 BTS [SMARTEDITORSUS-26]
							 * @param {Node} oNode 취소선/밑줄을 적용할 노드
							 */
							_checkTextDecoration : function(oNode){
								if(oNode.tagName !== "SPAN"){
									return;	
								}
								
								var bUnderline = false,
									bLineThrough = false,
									oParentNode = null,
									oChildNode = oNode.firstChild;
								
								/* check child */
								while(oChildNode){
									if(oChildNode.nodeType === 1){
										bUnderline = (bUnderline || oChildNode.tagName === "U");
										bLineThrough = (bLineThrough || oChildNode.tagName === "S" || oChildNode.tagName === "STRIKE");
									}
									
									if(bUnderline && bLineThrough){
										return;
									}
									
									oChildNode = oChildNode.nextSibling;
								}
									
								oParentNode = nhn.DOMFix.parentNode(oNode);
								
								/* check parent */
								while(oParentNode && oParentNode.tagName !== "BODY"){
									if(oParentNode.nodeType !== 1){
										oParentNode = nhn.DOMFix.parentNode(oParentNode);
										continue;
									}
									
									if(!bUnderline && this._hasTextDecoration(oParentNode, "underline")){
										bUnderline = true;
										this._setTextDecoration(oNode, "underline");	// set underline
									}
									
									if(!bLineThrough && this._hasTextDecoration(oParentNode, "line-through")){
										bLineThrough = true;
										this._setTextDecoration(oNode, "line-through");	// set line-through
									}

									if(bUnderline && bLineThrough){
										return;
									}
									
									oParentNode = nhn.DOMFix.parentNode(oParentNode);
								}
							},

							/**
							 * Range에 속한 노드들에 스타일을 적용한다
							 * @param {Object} 	oStyle 					적용할 스타일을 가지는 Object (예) 글꼴 색 적용의 경우 { color : "#0075c8" }
							 * @param {Object} 	[oAttribute] 			적용할 속성을 가지는 Object (예) 맞춤범 검사의 경우 { _sm2_spchk: "강남콩", class: "se2_check_spell" }
							 * @param {String} 	[sNewSpanMarker] 		새로 추가된 SPAN 노드를 나중에 따로 처리해야하는 경우 마킹을 위해 사용하는 문자열
							 * @param {Boolean} [bIncludeLI] 			LI 도 스타일 적용에 포함할 것인지의 여부 [COM-1051] _getStyleParentNodes 메서드 참고하기
							 * @param {Boolean} [bCheckTextDecoration] 	취소선/밑줄 처리를 적용할 것인지 여부 [SMARTEDITORSUS-26] _setTextDecoration 메서드 참고하기
							 */
							styleRange : function(oStyle, oAttribute, sNewSpanMarker, bIncludeLI, bCheckTextDecoration){
								var aStyleParents = this.aStyleParents = this._getStyleParentNodes(sNewSpanMarker, bIncludeLI);
								if(aStyleParents.length < 1){return;}

								var sName, sValue, x;

								for(var i=0; i<aStyleParents.length; i++){
									for(x in oStyle){
										sName = x;
										sValue = oStyle[sName];

										if(typeof sValue != "string"){continue;}

										// [SMARTEDITORSUS-26] 글꼴 색을 적용할 때 취소선/밑줄의 색상도 처리되도록 추가
										if(bCheckTextDecoration && oStyle.color){
											this._checkTextDecoration(aStyleParents[i]);
										}
										
										aStyleParents[i].style[sName] = sValue;
									}

									if(!oAttribute){continue;}

									for(x in oAttribute){
										sName = x;
										sValue = oAttribute[sName];

										if(typeof sValue != "string"){continue;}
										
										if(sName == "class"){
											jindo.$Element(aStyleParents[i]).addClass(sValue);
										}else{
											aStyleParents[i].setAttribute(sName, sValue);
										}
									}
								}

								this.reset(this._window);
								this.setStartBefore(aStyleParents[0]);
								this.setEndAfter(aStyleParents[aStyleParents.length-1]);
							},

							expandBothEnds : function(){
								this.expandStart();
								this.expandEnd();
							},
							
							expandStart : function(){
								if(this.startContainer.nodeType == 3 && this.startOffset !== 0){return;}

								var elActualStartNode = this._getActualStartNode(this.startContainer, this.startOffset);
								elActualStartNode = this._getPrevNode(elActualStartNode);
								
								if(elActualStartNode.tagName == "BODY"){
									this.setStartBefore(elActualStartNode);
								}else{
									this.setStartAfter(elActualStartNode);
								}
							},
							
							expandEnd : function(){
								if(this.endContainer.nodeType == 3 && this.endOffset < this.endContainer.nodeValue.length){return;}

								var elActualEndNode = this._getActualEndNode(this.endContainer, this.endOffset);
								elActualEndNode = this._getNextNode(elActualEndNode);
								
								if(elActualEndNode.tagName == "BODY"){
									this.setEndAfter(elActualEndNode);
								}else{
									this.setEndBefore(elActualEndNode);
								}
							},
							
							/**
							 * Style 을 적용할 노드를 가져온다
							 * @param {String}	[sNewSpanMarker]	새로 추가하는 SPAN 노드를 마킹을 위해 사용하는 문자열
							 * @param {Boolean}	[bIncludeLI]		LI 도 스타일 적용에 포함할 것인지의 여부
							 * @return {Array}	Style 을 적용할 노드 배열
							 */
							_getStyleParentNodes : function(sNewSpanMarker, bIncludeLI){
								this._splitTextEndNodesOfTheRange();

								var oSNode = this.getStartNode();
								var oENode = this.getEndNode();

								var aAllNodes = this._getNodesInRange();
								var aResult = [];
								var nResult = 0;

								var oNode, oSpan;
								var nInitialLength = aAllNodes.length;
								var arAllBottomNodes = jindo.$A(aAllNodes).filter(function(v){return (!v.firstChild || (bIncludeLI && v.tagName=="LI"));});

								// [COM-1051] 본문내용을 한 줄만 입력하고 번호 매긴 상태에서 글자크기를 변경하면 번호크기는 변하지 않는 문제
								// 부모 노드 중 LI 가 있고, 해당 LI 의 모든 자식 노드가 선택된 상태라면 LI에도 스타일을 적용하도록 처리함
								// --- Range 에 LI 가 포함되지 않은 경우, LI 를 포함하도록 처리
								var elTmpNode = this.commonAncestorContainer;
								if(bIncludeLI){
									while(elTmpNode){
										if(elTmpNode.tagName == "LI"){
											if(this._isFullyContained(elTmpNode, arAllBottomNodes)){
												aResult[nResult++] = elTmpNode;
											}
											break;
										}
										
										elTmpNode = elTmpNode.parentNode;
									}
								}
								
								for(var i=0; i<nInitialLength; i++){
									oNode = aAllNodes[i];

									if(!oNode){continue;}
									
									// --- Range 에 LI 가 포함된 경우에 대한 LI 확인
									if(bIncludeLI && oNode.tagName == "LI" && this._isFullyContained(oNode, arAllBottomNodes)){
										aResult[nResult++] = oNode;
										continue;
									}

									if(oNode.nodeType != 3){continue;}
									if(oNode.nodeValue == "" || oNode.nodeValue.match(/^(\r|\n)+$/)){continue;}

									var oParentNode = nhn.DOMFix.parentNode(oNode);

									// 부모 노드가 SPAN 인 경우에는 새로운 SPAN 을 생성하지 않고 SPAN 을 리턴 배열에 추가함
									if(oParentNode.tagName == "SPAN"){
										if(this._isFullyContained(oParentNode, arAllBottomNodes, oNode)){
											aResult[nResult++] = oParentNode;
											continue;
										}
									}else{
										// [SMARTEDITORSUS-1513] 선택된 영역을 single node로 감싸는 상위 span 노드가 있으면 리턴 배열에 추가 
										var oParentSingleSpan = this._findParentSingleSpan(oParentNode);
										if(oParentSingleSpan){
											aResult[nResult++] = oParentSingleSpan;
											continue;
										}
									}

									oSpan = this._document.createElement("SPAN");
									oParentNode.insertBefore(oSpan, oNode);
									oSpan.appendChild(oNode);
									aResult[nResult++] = oSpan;
									
									if(sNewSpanMarker){oSpan.setAttribute(sNewSpanMarker, "true");}
								}

								this.setStartBefore(oSNode);
								this.setEndAfter(oENode);

								return aResult;
							},

							/**
							 * [SMARTEDITORSUS-1513][SMARTEDITORSUS-1648] 해당노드가 single child로 묶이는 상위 span 노드가 있는지 찾는다.
							 * @param {Node} oNode 검사할 노드
							 * @return {Element} 상위 span 노드, 없으면 null
							 */
							_findParentSingleSpan : function(oNode){
								if(!oNode){
									return null;
								}
								// ZWNBSP 문자가 같이 있는 경우도 있기 때문에 실제 노드를 카운팅해야 함
								for(var i = 0, nCnt = 0, sValue, oChild, aChildNodes = oNode.childNodes; (oChild = aChildNodes[i]); i++){
									sValue = oChild.nodeValue;
									if(this._rxCursorHolder.test(sValue)){
										continue;
									}else{
										nCnt++;
									}
									if(nCnt > 1){	// 싱글노드가 아니면 더이상 찾지 않고 null 반환
										return null;
									}
								}
								if(oNode.nodeName === "SPAN"){
									return oNode;
								}else{
									return this._findParentSingleSpan(oNode.parentNode);
								}
							},
							
							/**
							 * 컨테이너 엘리먼트(elContainer)의 모든 자식노드가 노드 배열(waAllNodes)에 속하는지 확인한다
							 * 첫 번째 자식 노드와 마지막 자식 노드가 노드 배열에 속하는지를 확인한다
							 * @param {Element}		elContainer	컨테이너 엘리먼트
							 * @param {jindo.$A}	waAllNodes	Node 의 $A 배열
							 * @param {Node}		[oNode] 성능을 위한 옵션 노드로 컨테이너의 첫 번째 혹은 마지막 자식 노드와 같으면 indexOf 함수 사용을 줄일 수 있음
							 * @return {Array}	Style 을 적용할 노드 배열
							 */
							// check if all the child nodes of elContainer are in waAllNodes
							_isFullyContained : function(elContainer, waAllNodes, oNode){
								var nSIdx, nEIdx;
								var oTmpNode = this._getVeryFirstRealChild(elContainer);
								// do quick checks before trying indexOf() because indexOf() function is very slow
								// oNode is optional
								if(oNode && oTmpNode == oNode){
									nSIdx = 1;
								}else{
									nSIdx = waAllNodes.indexOf(oTmpNode);
								}

								if(nSIdx != -1){
									oTmpNode = this._getVeryLastRealChild(elContainer);
									if(oNode && oTmpNode == oNode){
										nEIdx = 1;
									}else{
										nEIdx = waAllNodes.indexOf(oTmpNode);
									}
								}

								return (nSIdx != -1 && nEIdx != -1);
							},
							
							_getVeryFirstChild : function(oNode){
								if(oNode.firstChild){return this._getVeryFirstChild(oNode.firstChild);}
								return oNode;
							},

							_getVeryLastChild : function(oNode){
								if(oNode.lastChild){return this._getVeryLastChild(oNode.lastChild);}
								return oNode;
							},

							_getFirstRealChild : function(oNode){
								var oFirstNode = oNode.firstChild;
								while(oFirstNode && oFirstNode.nodeType == 3 && oFirstNode.nodeValue == ""){oFirstNode = oFirstNode.nextSibling;}

								return oFirstNode;
							},
							
							_getLastRealChild : function(oNode){
								var oLastNode = oNode.lastChild;
								while(oLastNode && oLastNode.nodeType == 3 && oLastNode.nodeValue == ""){oLastNode = oLastNode.previousSibling;}

								return oLastNode;
							},
							
							_getVeryFirstRealChild : function(oNode){
								var oFirstNode = this._getFirstRealChild(oNode);
								if(oFirstNode){return this._getVeryFirstRealChild(oFirstNode);}
								return oNode;
							},
							_getVeryLastRealChild : function(oNode){
								var oLastNode = this._getLastRealChild(oNode);
								if(oLastNode){return this._getVeryLastChild(oLastNode);}
								return oNode;
							},

							_getLineStartInfo : function(node){
								var frontEndFinal = null;
								var frontEnd = node;
								var lineBreaker = node;
								var bParentBreak = false;

								var rxLineBreaker = this.rxLineBreaker;

								// vertical(parent) search
								function getLineStart(node){
									if(!node){return;}
									if(frontEndFinal){return;}

									if(rxLineBreaker.test(node.tagName)){
										lineBreaker = node;
										frontEndFinal = frontEnd;

										bParentBreak = true;

										return;
									}else{
										frontEnd = node;
									}

									getFrontEnd(node.previousSibling);

									if(frontEndFinal){return;}
									getLineStart(nhn.DOMFix.parentNode(node));
								}

								// horizontal(sibling) search			
								function getFrontEnd(node){
									if(!node){return;}
									if(frontEndFinal){return;}

									if(rxLineBreaker.test(node.tagName)){
										lineBreaker = node;
										frontEndFinal = frontEnd;

										bParentBreak = false;
										return;
									}

									// [SMARTEDITORSUS-2339] 인라인요소가 많은 경우 recursive limit를 유발한다.
									// @see https://web.archive.org/web/20110128022845/http://www.javascriptrules.com/2009/06/30/limitation-on-call-stacks/
									// 어짜피 블럭요소가 아니라면 하위요소를 찾을 필요가 있을까? 해당 로직이 있는 히스토리를 몰라서 제거하지 않고 주석처리
									// if(node.firstChild && node.tagName != "TABLE"){
									// 	var curNode = node.lastChild;
									// 	while(curNode && !frontEndFinal){
									// 		getFrontEnd(curNode);
									//
									// 		curNode = curNode.previousSibling;
									// 	}
									// }else{
										frontEnd = node;
									// }
									
									if(!frontEndFinal){
										getFrontEnd(node.previousSibling);
									}
								}

								if(rxLineBreaker.test(node.tagName)){
									frontEndFinal = node;
								}else{
									getLineStart(node);
								}
							
								return {oNode: frontEndFinal, oLineBreaker: lineBreaker, bParentBreak: bParentBreak};
							},

							_getLineEndInfo : function(node){
								var backEndFinal = null;
								var backEnd = node;
								var lineBreaker = node;
								var bParentBreak = false;

								var rxLineBreaker = this.rxLineBreaker;

								// vertical(parent) search
								function getLineEnd(node){
									if(!node){return;}
									if(backEndFinal){return;}
									
									if(rxLineBreaker.test(node.tagName)){
										lineBreaker = node;
										backEndFinal = backEnd;

										bParentBreak = true;

										return;
									}else{
										backEnd = node;
									}
							
									getBackEnd(node.nextSibling);
									if(backEndFinal){return;}
							
									getLineEnd(nhn.DOMFix.parentNode(node));
								}
								
								// horizontal(sibling) search
								function getBackEnd(node){
									if(!node){return;}
									if(backEndFinal){return;}

									if(rxLineBreaker.test(node.tagName)){
										lineBreaker = node;
										backEndFinal = backEnd;

										bParentBreak = false;
										
										return;
									}

									// [SMARTEDITORSUS-2339] 인라인요소가 많은 경우 recursive limit를 유발한다.
									// @see https://web.archive.org/web/20110128022845/http://www.javascriptrules.com/2009/06/30/limitation-on-call-stacks/
									// 어짜피 블럭요소가 아니라면 하위요소를 찾을 필요가 있을까? 해당 로직이 있는 히스토리를 몰라서 제거하지 않고 주석처리
									// if(node.firstChild && node.tagName != "TABLE"){
									// 	var curNode = node.firstChild;
									// 	while(curNode && !backEndFinal){
									// 		getBackEnd(curNode);
									//
									// 		curNode = curNode.nextSibling;
									// 	}
									// }else{
										backEnd = node;
									// }
							
									if(!backEndFinal){
										getBackEnd(node.nextSibling);
									}
								}
							
								if(rxLineBreaker.test(node.tagName)){
									backEndFinal = node;
								}else{
									getLineEnd(node);
								}

								return {oNode: backEndFinal, oLineBreaker: lineBreaker, bParentBreak: bParentBreak};
							},

							getLineInfo : function(bAfter){
								bAfter = bAfter || false;
								
								var oSNode = this.getStartNode();
								var oENode = this.getEndNode();

								// oSNode && oENode will be null if the range is currently collapsed and the cursor is not located in the middle of a text node.
								if(!oSNode){oSNode = this.getNodeAroundRange(!bAfter, true);}
								if(!oENode){oENode = this.getNodeAroundRange(!bAfter, true);}
								
								var oStart = this._getLineStartInfo(oSNode);
								var oStartNode = oStart.oNode;
								var oEnd = this._getLineEndInfo(oENode);
								var oEndNode = oEnd.oNode;

								if(oSNode != oStartNode || oENode != oEndNode){
									// check if the start node is positioned after the range's ending point
									// or
									// if the end node is positioned before the range's starting point
									var iRelativeStartPos = this._compareEndPoint(nhn.DOMFix.parentNode(oStartNode), this._getPosIdx(oStartNode), this.endContainer, this.endOffset);
									var iRelativeEndPos = this._compareEndPoint(nhn.DOMFix.parentNode(oEndNode), this._getPosIdx(oEndNode)+1, this.startContainer, this.startOffset);

									if(!(iRelativeStartPos <= 0 && iRelativeEndPos >= 0)){
										oSNode = this.getNodeAroundRange(false, true);
										oENode = this.getNodeAroundRange(false, true);
										oStart = this._getLineStartInfo(oSNode);
										oEnd = this._getLineEndInfo(oENode);
									}
								}

								return {oStart: oStart, oEnd: oEnd};
							},

							/**
							 * 커서홀더나 공백을 제외한 child 노드가 하나만 있는 경우만 node 를 반환한다.  
							 * @param {Node} oNode 확인할 노드
							 * @return {Node} single child node를 반환한다. 없거나 두개 이상이면 null 을 반환  
							 */
							_findSingleChild : function(oNode){
								if(!oNode){
									return null;
								}
								var oSingleChild = null;
								// ZWNBSP 문자가 같이 있는 경우도 있기 때문에 실제 노드를 카운팅해야 함
								for(var i = 0, nCnt = 0, sValue, oChild, aChildNodes = oNode.childNodes; (oChild = aChildNodes[i]); i++){
									sValue = oChild.nodeValue;
									if(this._rxCursorHolder.test(sValue)){
										continue;
									}else{
										oSingleChild = oChild;
										nCnt++;
									}
									if(nCnt > 1){	// 싱글노드가 아니면 더이상 찾지 않고 null 반환
										return null;
									}
								}
								return oSingleChild;
							},

							/**
							 * 해당요소의 최하위까지 검색해 커서홀더만 감싸고 있는지 여부를 반환
							 * @param {Node} oNode 확인할 노드
							 * @return {Boolean} 커서홀더만 있는 경우 true 반환
							 */
							_hasCursorHolderOnly : function(oNode){
								if(!oNode || oNode.nodeType !== 1){
									return false;
								}
								if(this._rxCursorHolder.test(oNode.innerHTML)){
									return true;
								}else{
									return this._hasCursorHolderOnly(this._findSingleChild(oNode));
								}
							}
						}).extend(nhn.W3CDOMRange);

						/**
						 * @fileOverview This file contains cross-browser selection function
						 * @name BrowserSelection.js
						 */
						nhn.BrowserSelection = function(win){
							this.init = function(win){
								this._window = win || window;
								this._document = this._window.document;
							};

							this.init(win);

							// [SMARTEDITORSUS-888] IE9 이후로 document.createRange 를 지원
						/*	var oAgentInfo = jindo.$Agent().navigator();
							if(oAgentInfo.ie){
								nhn.BrowserSelectionImpl_IE.apply(this);
							}else{
								nhn.BrowserSelectionImpl_FF.apply(this);
							}*/

							if(this._document.createRange){
								nhn.BrowserSelectionImpl_FF.apply(this);
							}else{
								nhn.BrowserSelectionImpl_IE.apply(this);
							}
							
							this.selectRange = function(oRng){
								this.selectNone();
								this.addRange(oRng);
							};

							this.selectionLoaded = true;
							if(!this._oSelection){this.selectionLoaded = false;}
						};

						nhn.BrowserSelectionImpl_FF = function(){
							this._oSelection = this._window.getSelection();

							this.getRangeAt = function(iNum){
								iNum = iNum || 0;

								try{
									var oFFRange = this._oSelection.getRangeAt(iNum);
								}catch(e){return new nhn.W3CDOMRange(this._window);}

								return this._FFRange2W3CRange(oFFRange);
							};
									
							this.addRange = function(oW3CRange){
								var oFFRange = this._W3CRange2FFRange(oW3CRange);
								this._oSelection.addRange(oFFRange);
							};

							this.selectNone = function(){
								this._oSelection.removeAllRanges();
							};
							
							this.getCommonAncestorContainer = function(oW3CRange){
								var oFFRange = this._W3CRange2FFRange(oW3CRange);
								return oFFRange.commonAncestorContainer;
							};
							
							this.isCollapsed = function(oW3CRange){
								var oFFRange = this._W3CRange2FFRange(oW3CRange);
								return oFFRange.collapsed;
							};
							
							this.compareEndPoints = function(elContainerA, nOffsetA, elContainerB, nOffsetB){
								var oFFRangeA = this._document.createRange();
								var oFFRangeB = this._document.createRange();
								oFFRangeA.setStart(elContainerA, nOffsetA);
								oFFRangeB.setStart(elContainerB, nOffsetB);
								oFFRangeA.collapse(true);
								oFFRangeB.collapse(true);

								try{
									return oFFRangeA.compareBoundaryPoints(1, oFFRangeB);
								}catch(e){
									return 1;
								}
							};

							this._FFRange2W3CRange = function(oFFRange){
								var oW3CRange = new nhn.W3CDOMRange(this._window);

								oW3CRange.setStart(oFFRange.startContainer, oFFRange.startOffset, true);
								oW3CRange.setEnd(oFFRange.endContainer, oFFRange.endOffset, true);
								
								return oW3CRange;
							};

							this._W3CRange2FFRange = function(oW3CRange){
								var oFFRange = this._document.createRange();
								oFFRange.setStart(oW3CRange.startContainer, oW3CRange.startOffset);
								oFFRange.setEnd(oW3CRange.endContainer, oW3CRange.endOffset);

								return oFFRange;
							};
						};

						nhn.BrowserSelectionImpl_IE = function(){
							this._oSelection = this._document.selection;
							this.oLastRange = {
								oBrowserRange : null,
								elStartContainer : null,
								nStartOffset : -1,
								elEndContainer : null,
								nEndOffset : -1
							};

							this._updateLastRange = function(oBrowserRange, oW3CRange){
								this.oLastRange.oBrowserRange = oBrowserRange;
								this.oLastRange.elStartContainer = oW3CRange.startContainer;
								this.oLastRange.nStartOffset = oW3CRange.startOffset;
								this.oLastRange.elEndContainer = oW3CRange.endContainer;
								this.oLastRange.nEndOffset = oW3CRange.endOffset;
							};
							
							this.getRangeAt = function(iNum){
								iNum = iNum || 0;

								var oW3CRange, oBrowserRange, oSelectedNode;
								if(this._oSelection.type == "Control"){
									oW3CRange = new nhn.W3CDOMRange(this._window);

									oSelectedNode = this._oSelection.createRange().item(iNum);

									// if the selction occurs in a different document, ignore
									if(!oSelectedNode || oSelectedNode.ownerDocument != this._document){return oW3CRange;}

									oW3CRange.selectNode(oSelectedNode);
									
									return oW3CRange;
								}else{
									//oBrowserRange = this._oSelection.createRangeCollection().item(iNum);
									oBrowserRange = this._oSelection.createRange();

									oSelectedNode = oBrowserRange.parentElement();

									// if the selction occurs in a different document, ignore
									if(!oSelectedNode || oSelectedNode.ownerDocument != this._document){
										oW3CRange = new nhn.W3CDOMRange(this._window);
										return oW3CRange;
									}
									oW3CRange = this._IERange2W3CRange(oBrowserRange);
									
									return oW3CRange;
								}
							};

							this.addRange = function(oW3CRange){
								var oIERange = this._W3CRange2IERange(oW3CRange);
								oIERange.select();
							};

							this.selectNone = function(){
								this._oSelection.empty();
							};

							this.getCommonAncestorContainer = function(oW3CRange){
								return this._W3CRange2IERange(oW3CRange).parentElement();
							};
							
							this.isCollapsed = function(oW3CRange){
								var oRange = this._W3CRange2IERange(oW3CRange);
								var oRange2 = oRange.duplicate();

								oRange2.collapse();

								return oRange.isEqual(oRange2);
							};
							
							this.compareEndPoints = function(elContainerA, nOffsetA, elContainerB, nOffsetB){
								var oIERangeA, oIERangeB;

								if(elContainerA === this.oLastRange.elStartContainer && nOffsetA === this.oLastRange.nStartOffset){
									oIERangeA = this.oLastRange.oBrowserRange.duplicate();
									oIERangeA.collapse(true);
								}else{
									if(elContainerA === this.oLastRange.elEndContainer && nOffsetA === this.oLastRange.nEndOffset){
										oIERangeA = this.oLastRange.oBrowserRange.duplicate();
										oIERangeA.collapse(false);
									}else{
										oIERangeA = this._getIERangeAt(elContainerA, nOffsetA);
									}
								}

								if(elContainerB === this.oLastRange.elStartContainer && nOffsetB === this.oLastRange.nStartOffset){
									oIERangeB = this.oLastRange.oBrowserRange.duplicate();
									oIERangeB.collapse(true);
								}else{
									if(elContainerB === this.oLastRange.elEndContainer && nOffsetB === this.oLastRange.nEndOffset){
										oIERangeB = this.oLastRange.oBrowserRange.duplicate();
										oIERangeB.collapse(false);
									}else{
										oIERangeB = this._getIERangeAt(elContainerB, nOffsetB);
									}
								}

								return oIERangeA.compareEndPoints("StartToStart", oIERangeB);
							};
							
							this._W3CRange2IERange = function(oW3CRange){
								if(this.oLastRange.elStartContainer === oW3CRange.startContainer &&
									this.oLastRange.nStartOffset === oW3CRange.startOffset &&
									this.oLastRange.elEndContainer === oW3CRange.endContainer &&
									this.oLastRange.nEndOffset === oW3CRange.endOffset){
									return this.oLastRange.oBrowserRange;
								}

								var oStartIERange = this._getIERangeAt(oW3CRange.startContainer, oW3CRange.startOffset);
								var oEndIERange = this._getIERangeAt(oW3CRange.endContainer, oW3CRange.endOffset);
								oStartIERange.setEndPoint("EndToEnd", oEndIERange);

								this._updateLastRange(oStartIERange, oW3CRange);

								return oStartIERange;
							};

							this._getIERangeAt = function(oW3CContainer, iW3COffset){
								var oIERange = this._document.body.createTextRange();

								var oEndPointInfoForIERange = this._getSelectableNodeAndOffsetForIE(oW3CContainer, iW3COffset);

								var oSelectableNode = oEndPointInfoForIERange.oSelectableNodeForIE;
								var iIEOffset = oEndPointInfoForIERange.iOffsetForIE;

								oIERange.moveToElementText(oSelectableNode);

								oIERange.collapse(oEndPointInfoForIERange.bCollapseToStart);
								oIERange.moveStart("character", iIEOffset);

								return oIERange;
							};

							this._getSelectableNodeAndOffsetForIE = function(oW3CContainer, iW3COffset){
						//		var oIERange = this._document.body.createTextRange();

								var oNonTextNode = null;
								var aChildNodes =  null;
								var iNumOfLeftNodesToCount = 0;

								if(oW3CContainer.nodeType == 3){
									oNonTextNode = nhn.DOMFix.parentNode(oW3CContainer);
									aChildNodes = nhn.DOMFix.childNodes(oNonTextNode);
									iNumOfLeftNodesToCount = aChildNodes.length;
								}else{
									oNonTextNode = oW3CContainer;
									aChildNodes = nhn.DOMFix.childNodes(oNonTextNode);
									//iNumOfLeftNodesToCount = iW3COffset;
									iNumOfLeftNodesToCount = (iW3COffset<aChildNodes.length)?iW3COffset:aChildNodes.length;
								}
						//@ room 4 improvement
								var oNodeTester = null;
								var iResultOffset = 0;
								var bCollapseToStart = true;

								for(var i=0; i<iNumOfLeftNodesToCount; i++){
									oNodeTester = aChildNodes[i];

									if(oNodeTester.nodeType == 3){
										if(oNodeTester == oW3CContainer){break;}

										iResultOffset += oNodeTester.nodeValue.length;
									}else{
						//				oIERange.moveToElementText(oNodeTester);
										oNonTextNode = oNodeTester;
										iResultOffset = 0;

										bCollapseToStart = false;
									}
								}

								if(oW3CContainer.nodeType == 3){iResultOffset += iW3COffset;}

								return {oSelectableNodeForIE:oNonTextNode, iOffsetForIE: iResultOffset, bCollapseToStart: bCollapseToStart};
							};

							this._IERange2W3CRange = function(oIERange){
								var oW3CRange = new nhn.W3CDOMRange(this._window);

								var oIEPointRange = null;
								var oPosition = null;

								oIEPointRange = oIERange.duplicate();
								oIEPointRange.collapse(true);

								oPosition = this._getW3CContainerAndOffset(oIEPointRange, true);

								oW3CRange.setStart(oPosition.oContainer, oPosition.iOffset, true, true);

								var oCollapsedChecker = oIERange.duplicate();
								oCollapsedChecker.collapse(true);
								if(oCollapsedChecker.isEqual(oIERange)){
									oW3CRange.collapse(true);
								}else{
									oIEPointRange = oIERange.duplicate();
									oIEPointRange.collapse(false);
									oPosition = this._getW3CContainerAndOffset(oIEPointRange);
									oW3CRange.setEnd(oPosition.oContainer, oPosition.iOffset, true);
								}

								this._updateLastRange(oIERange, oW3CRange);

								return oW3CRange;
							};

							this._getW3CContainerAndOffset = function(oIEPointRange, bStartPt){
								var oRgOrigPoint = oIEPointRange;

								var oContainer = oRgOrigPoint.parentElement();
								var offset = -1;

								var oRgTester = this._document.body.createTextRange();
								var aChildNodes = nhn.DOMFix.childNodes(oContainer);
								var oPrevNonTextNode = null;
								var pointRangeIdx = 0;

								for(var i=0;i<aChildNodes.length;i++){
									if(aChildNodes[i].nodeType == 3){continue;}

									oRgTester.moveToElementText(aChildNodes[i]);

									if(oRgTester.compareEndPoints("StartToStart", oIEPointRange)>=0){break;}

									oPrevNonTextNode = aChildNodes[i];
								}

								pointRangeIdx = i;

								if(pointRangeIdx !== 0 && aChildNodes[pointRangeIdx-1].nodeType == 3){
									var oRgTextStart = this._document.body.createTextRange();
									var oCurTextNode = null;
									if(oPrevNonTextNode){
										oRgTextStart.moveToElementText(oPrevNonTextNode);
										oRgTextStart.collapse(false);
										oCurTextNode = oPrevNonTextNode.nextSibling;
									}else{
										oRgTextStart.moveToElementText(oContainer);
										oRgTextStart.collapse(true);
										oCurTextNode = oContainer.firstChild;
									}

									var oRgTextsUpToThePoint = oRgOrigPoint.duplicate();
									oRgTextsUpToThePoint.setEndPoint("StartToStart", oRgTextStart);

									var textCount = oRgTextsUpToThePoint.text.replace(/[\r\n]/g,"").length;

									while(textCount > oCurTextNode.nodeValue.length && oCurTextNode.nextSibling){
										textCount -= oCurTextNode.nodeValue.length;
										oCurTextNode = oCurTextNode.nextSibling;
									}

									// this will enforce IE to re-reference oCurTextNode
									oCurTextNode.nodeValue;
									
									if(bStartPt && oCurTextNode.nextSibling && oCurTextNode.nextSibling.nodeType == 3 && textCount == oCurTextNode.nodeValue.length){
										textCount -= oCurTextNode.nodeValue.length;
										oCurTextNode = oCurTextNode.nextSibling;
									}

									oContainer = oCurTextNode;
									offset = textCount;
								}else{
									oContainer = oRgOrigPoint.parentElement();
									offset = pointRangeIdx;
								}
								return {"oContainer" : oContainer, "iOffset" : offset};
							};
						};

						nhn.DOMFix = new (jindo.$Class({
							$init : function(){
								if(jindo.$Agent().navigator().ie || jindo.$Agent().navigator().opera){
									this.childNodes = this._childNodes_Fix;
									this.parentNode = this._parentNode_Fix;
								}else{
									this.childNodes = this._childNodes_Native;
									this.parentNode = this._parentNode_Native;
								}
							},

							_parentNode_Native : function(elNode){
								return elNode.parentNode;
							},
							
							_parentNode_Fix : function(elNode){
								if(!elNode){return elNode;}

								while(elNode.previousSibling){elNode = elNode.previousSibling;}

								return elNode.parentNode;
							},
							
							_childNodes_Native : function(elNode){
								return elNode.childNodes;
							},
							
							_childNodes_Fix : function(elNode){
								var aResult = null;
								var nCount = 0;

								if(elNode){
									aResult = [];
									elNode = elNode.firstChild;
									while(elNode){
										aResult[nCount++] = elNode;
										elNode=elNode.nextSibling;
									}
								}
								
								return aResult;
							}
						}))();
					},
					"hp_CorePlugin.js": function (exports, module, require) {
						/*
						Copyright (C) NAVER corp.  

						This library is free software; you can redistribute it and/or  
						modify it under the terms of the GNU Lesser General Public  
						License as published by the Free Software Foundation; either  
						version 2.1 of the License, or (at your option) any later version.  

						This library is distributed in the hope that it will be useful,  
						but WITHOUT ANY WARRANTY; without even the implied warranty of  
						MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  
						Lesser General Public License for more details.  

						You should have received a copy of the GNU Lesser General Public  
						License along with this library; if not, write to the Free Software  
						Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA  
						*/
						/*[
						 * ADD_APP_PROPERTY
						 *
						 * 주요 오브젝트를 모든 플러그인에서 this.oApp를 통해서 직접 접근 가능 하도록 등록한다.
						 *
						 * sPropertyName string 등록명
						 * oProperty object 등록시킬 오브젝트
						 *
						---------------------------------------------------------------------------]*/
						/*[
						 * REGISTER_BROWSER_EVENT
						 *
						 * 특정 브라우저 이벤트가 발생 했을때 Husky 메시지를 발생 시킨다.
						 *
						 * obj HTMLElement 브라우저 이벤트를 발생 시킬 HTML 엘리먼트
						 * sEvent string 발생 대기 할 브라우저 이벤트
						 * sMsg string 발생 할 Husky 메시지
						 * aParams array 메시지에 넘길 파라미터
						 * nDelay number 브라우저 이벤트 발생 후 Husky 메시지 발생 사이에 딜레이를 주고 싶을 경우 설정. (1/1000초 단위)
						 *
						---------------------------------------------------------------------------]*/
						/*[
						 * DISABLE_MESSAGE
						 *
						 * 특정 메시지를 코어에서 무시하고 라우팅 하지 않도록 비활성화 한다.
						 *
						 * sMsg string 비활성화 시킬 메시지
						 *
						---------------------------------------------------------------------------]*/
						/*[
						 * ENABLE_MESSAGE
						 *
						 * 무시하도록 설정된 메시지를 무시하지 않도록 활성화 한다.
						 *
						 * sMsg string 활성화 시킬 메시지
						 *
						---------------------------------------------------------------------------]*/
						/*[
						 * EXEC_ON_READY_FUNCTION
						 *
						 * oApp.run({fnOnAppReady:fnOnAppReady})와 같이 run 호출 시점에 지정된 함수가 있을 경우 이를 MSG_APP_READY 시점에 실행 시킨다.
						 * 코어에서 자동으로 발생시키는 메시지로 직접 발생시키지는 않도록 한다.
						 *
						 * none
						 *
						---------------------------------------------------------------------------]*/
						/**
						 * @pluginDesc Husky Framework에서 자주 사용되는 메시지를 처리하는 플러그인
						 */
						nhn.husky.CorePlugin = jindo.$Class({
							name : "CorePlugin",

							$AFTER_MSG_APP_READY : function(){
								this.oApp.exec("EXEC_ON_READY_FUNCTION", []);
							},

							$ON_ADD_APP_PROPERTY : function(sPropertyName, oProperty){
								this.oApp[sPropertyName] = oProperty;
							},

							$ON_REGISTER_BROWSER_EVENT : function(obj, sEvent, sMsg, aParams, nDelay){
								this.oApp.registerBrowserEvent(obj, sEvent, sMsg, aParams, nDelay);
							},
							
							$ON_DISABLE_MESSAGE : function(sMsg){
								this.oApp.disableMessage(sMsg, true);
							},

							$ON_ENABLE_MESSAGE : function(sMsg){
								this.oApp.disableMessage(sMsg, false);
							},

							$ON_EXEC_ON_READY_FUNCTION : function(){
								if(typeof this.oApp.htRunOptions.fnOnAppReady == "function"){this.oApp.htRunOptions.fnOnAppReady();}
							}
						});
					},
					"hp_HuskyRangeManager.js": function (exports, module, require) {
						/*
						Copyright (C) NAVER corp.  

						This library is free software; you can redistribute it and/or  
						modify it under the terms of the GNU Lesser General Public  
						License as published by the Free Software Foundation; either  
						version 2.1 of the License, or (at your option) any later version.  

						This library is distributed in the hope that it will be useful,  
						but WITHOUT ANY WARRANTY; without even the implied warranty of  
						MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  
						Lesser General Public License for more details.  

						You should have received a copy of the GNU Lesser General Public  
						License along with this library; if not, write to the Free Software  
						Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA  
						*/
						//{
						/**
						 * @fileOverview This file contains Husky plugin that bridges the HuskyRange function
						 * @name hp_HuskyRangeManager.js
						 */
						nhn.husky.HuskyRangeManager = jindo.$Class({
							name : "HuskyRangeManager",

							oWindow : null,

							$init : function(win){
								this.oWindow = win || window;
							},

							$BEFORE_MSG_APP_READY : function(){
								if(this.oWindow && this.oWindow.tagName == "IFRAME"){
									this.oWindow = this.oWindow.contentWindow;
									nhn.CurrentSelection.setWindow(this.oWindow);
								}

								this.oApp.exec("ADD_APP_PROPERTY", ["getSelection", jindo.$Fn(this.getSelection, this).bind()]);
								this.oApp.exec("ADD_APP_PROPERTY", ["getEmptySelection", jindo.$Fn(this.getEmptySelection, this).bind()]);
							},

							$ON_SET_EDITING_WINDOW : function(oWindow){
								this.oWindow = oWindow;
							},

							getEmptySelection : function(oWindow){
								var oHuskyRange = new nhn.HuskyRange(oWindow || this.oWindow);
								return oHuskyRange;
							},

							getSelection : function(oWindow){
								this.oApp.exec("RESTORE_IE_SELECTION", []);

								var oHuskyRange = this.getEmptySelection(oWindow);

								// this may throw an exception if the selected is area is not yet shown
								try{
									oHuskyRange.setFromSelection();
								}catch(e){
									// console.warn(e);
								}

								return oHuskyRange;
							}
						});
						//}
					}
				},
				"hwp": {
					"doc.js": function (exports, module, require) {
						var node = require('./node');

						var prototype = node.derive({
							load: function(runs, takeFocus) {
								var self = this;
								//this.words = [];
								this._paragraphs = [];
								this.layout();
							},
							layout: function(left, top, width, height) {
								this.frame = null;
								try {
									this._left = left || 0;
									this._top = top || 0;
									this._width = width || 0;
									this._paragraphs = [];
								} catch (x) {
									console.error(x);
								}
							},
							children: function() {
								return this._paragraphs;
							},
						});

						exports = module.exports = function() {
							var doc = Object.create(prototype);
							doc._left = 0;
							doc._top = 0;
							doc._width = 0;
							doc._paragraphs = [];
							doc.load([]);
							return doc;
						};
					},
					"frame.js": function (exports, module, require) {
						var node = require('./node');

						var prototype = node.derive({
							children: function() {
								return this._paragraphs;
							},
							draw: function(ctx, viewPort) {
								this.children().forEach(function(child) {
									child.draw(ctx, viewPort);
								});
							}
						});

						exports = module.exports = function(left, top, width, parent) {
							var paragraphs = [];
							var frame = Object.create(prototype, {
								_paragraphs: { value: paragraphs },
								_parent: { value: parent }
							});
							return frame;
						};
					},
					"hwp.js": function (exports, module, require) {
						
						var docInfo = [];
						var faceNames = [];
						var borderFills = [];
						var charShapes = [];

						exports.load = function(stream) {

						}

						/* exports.init = function() {}
						var head = [];
						exports.head = function() {}
						exports.body = function() {}
						exports.load = function() {} */

						exports.parse = function(body) {
							var root = body;

						};
					},
					"node.js": function (exports, module, require) {
						//var per = require('per');
						//var runs = require('./runs');
						var rect = require('./rect');
						var util = require('./util');

						exports.prototype = {
							children: function() {
								return [];
							},
							parent: function() {
								return null;
							},
							first: function() {
								return this.children()[0];
							},
							last: function() {
								return this.children()[this.children().length - 1];
							},
							next: function() {
								var self = this;
								for (;;) {
									var parent = self.parent();
									if (!parent) {
										return null;
									}
									var siblings = parent.children();
									var next = siblings[siblings.indexOf(self) + 1];
									if (next) {
										for (;;)  {
											var first = next.first();
											if (!first) {
												break;
											}
											next = first;
										}
										return next;
									}
									self = parent;
								}
							},
							previous: function() {
								var parent = this.parent();
								if (!parent) {
									return null;
								}
								var siblings = parent.children();
								var prev = siblings[siblings.indexOf(this) - 1];
								if (prev) {
									return prev;
								}
								var prevParent = parent.previous();
								return !prevParent ? null : prevParent.last();
							},
							byOrdinal: function(index) {
								var found = null;
								if (this.children().some(function(child) {
									if (index >= child.ordinal && index < child.ordinal + child.length) {
										found = child.byOrdinal(index);
										if (found) {
											return true;
										}
									}
								})) {
									return found;
								}
								return this;
							},
							byCoordinate: function(x, y) {
								var found;
								this.children().some(function(child) {
									var b = child.bounds();
									if (b.contains(x, y)) {
										found = child.byCoordinate(x, y);
										if (found) {
											return true;
										}
									}
								});
								if (!found) {
									found = this.last();
									while (found) {
										var next = found.last();
										if (!next) {
											break;
										}
										found = next;
									}
									var foundNext = found.next();
									if (foundNext && foundNext.block) {
										found = foundNext;
									}
								}
								return found;
							},
							draw: function(ctx, viewPort) {
								this.children().forEach(function(child) {
									child.draw(ctx, viewPort);
								});
							},
							parentOfType: function(type) {
								var p = this.parent();
								return p && (p.type === type ? p : p.parentOfType(type));
							},
							bounds: function() {
								var l = this._left, t = this._top, r = 0, b = 0;
								this.children().forEach(function(child) {
									var cb = child.bounds();
									l = Math.min(l, cb.l);
									t = Math.min(t, cb.t);
									r = Math.max(r, cb.l + cb.w);
									b = Math.max(b, cb.t + cb.h);
								});
								return rect(l, t, r - l, b - t);
							}
						};

						exports.derive = function(methods) {
							return util.derive(exports.prototype, methods);
						};

						var generic = exports.derive({
							children: function() {
								return this._children;
							},
							parent: function() {
								return this._parent;
							},
							finalize: function(startDecrement, lengthIncrement) {
								var start = Number.MAX_VALUE, end = 0;
								this._children.forEach(function(child) {
									start = Math.min(start, child.ordinal);
									end = Math.max(end, child.ordinal + child.length);
								});
								Object.defineProperty(this, 'ordinal', { value: start - (startDecrement || 0) });
								Object.defineProperty(this, 'length', { value: (lengthIncrement || 0) + end - start });
							}
						});

						exports.generic = function(type, parent, left, top) {
							return Object.create(generic, {
								type: { value: type },
								_children: { value: [] },
								_parent: { value: parent },
								_left: { value: typeof left === 'number' ? left : Number.MAX_VALUE },
								_top: { value: typeof top === 'number' ? top : Number.MAX_VALUE }
							});
						};
					},
					"rect.js": function (exports, module, require) {
						
						var prototype = {
							contains: function(x, y) {
								return x >= this.l && x < (this.l + this.w) &&
									y >= this.t && y < (this.t + this.h);

							},
							stroke: function(ctx) {
								ctx.strokeRect(this.l, this.t, this.w, this.h);
							},
							fill: function(ctx) {
								ctx.fillRect(this.l, this.t, this.w, this.h);
							},
							offset: function(x, y) {
								return rect(this.l + x, this.t + y, this.w, this.h);
							},
							equals: function(other) {
								return this.l === other.l && this.t === other.t &&
									   this.w === other.w && this.h === other.h;
							},
							center: function() {
								return { x: this.l + this.w/2, y: this.t + this.h/2 };
							}
						};

						var rect = module.exports = function(l, t, w, h) {
							return Object.create(prototype, {
								l: { value: l },
								t: { value: t },
								w: { value: w },
								h: { value: h },
								r: { value: l + w },
								b: { value: t + h }
							});
						};
					},
					"util.js": function (exports, module, require) {
						exports.event = function() {
							var handlers = [];

							var subscribe = function(handler) {
								handlers.push(handler);
							};

							subscribe.fire = function() {
								var args = Array.prototype.slice.call(arguments, 0);
								handlers.forEach(function(handler) {
									handler.apply(null, args);
								});
							};

							return subscribe;
						};

						exports.derive = function(prototype, methods) {
							var properties = {};
							Object.keys(methods).forEach(function(name) {
								properties[name] = { value: methods[name] };
							});
							return Object.create(prototype, properties);
						};
					}
				},
				"util": {
					"hp_SE2M_Utils.js": function (exports, module, require) {
						/*
						Copyright (C) NAVER corp.  

						This library is free software; you can redistribute it and/or  
						modify it under the terms of the GNU Lesser General Public  
						License as published by the Free Software Foundation; either  
						version 2.1 of the License, or (at your option) any later version.  

						This library is distributed in the hope that it will be useful,  
						but WITHOUT ANY WARRANTY; without even the implied warranty of  
						MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  
						Lesser General Public License for more details.  

						You should have received a copy of the GNU Lesser General Public  
						License along with this library; if not, write to the Free Software  
						Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA  
						*/
						if(typeof window.nhn == 'undefined') { window.nhn = {}; }
						if(!nhn.husky) { nhn.husky = {}; }

						(function(){
							// 구버전 jindo.$Agent polyfill
							var ua = navigator.userAgent,
								oAgent = jindo.$Agent(),
								browser = oAgent.navigator(),
								os = oAgent.os();

							// [SMARTEDITORSUS-1795] 갤럭시노트 기본브라우저 구분을 위해 구분필드 추가
							var aMatch = ua.match(/(SHW-|Chrome|Safari)/gi) || "";
							if(aMatch.length === 2 && aMatch[0] === "SHW-" && aMatch[1] === "Safari"){
								// 갤럭시노트 기본브라우저
								browser.bGalaxyBrowser = true;
							}else if(ua.indexOf("LG-V500") > -1 && ua.indexOf("Version/4.0") > -1){
								// [SMARTEDITORSUS-1802] G패드 기본브라우저
								browser.bGPadBrowser = true;
							}
							// [SMARTEDITORSUS-1860] iOS 버전 확인용 
							// os 에서 ios 여부 및 version 정보는 jindo2.3.0 부터 추가되었음
							if(typeof os.ios === 'undefined'){
								os.ios = ua.indexOf("iPad") > -1 || ua.indexOf("iPhone") > -1;
								if(os.ios){
									aMatch = ua.match(/(iPhone )?OS ([\d|_]+)/);
									if(aMatch != null && aMatch[2] != undefined){
										os.version = String(aMatch[2]).split("_").join(".");
									}
								}
							}
						})();

						nhn.husky.SE2M_UtilPlugin = jindo.$Class({
							name : "SE2M_UtilPlugin",

							$BEFORE_MSG_APP_READY : function(){
								this.oApp.exec("ADD_APP_PROPERTY", ["oAgent", jindo.$Agent()]);
								this.oApp.exec("ADD_APP_PROPERTY", ["oNavigator", jindo.$Agent().navigator()]);
								this.oApp.exec("ADD_APP_PROPERTY", ["oUtils", this]);
							},
							
							$ON_REGISTER_HOTKEY : function(sHotkey, sCMD, aArgs, elTarget) {
								this.oApp.exec("ADD_HOTKEY", [sHotkey, sCMD, aArgs, (elTarget || this.oApp.getWYSIWYGDocument())]);
							},

							$ON_SE2_ATTACH_HOVER_EVENTS : function(aElms){
								this.oApp.exec("ATTACH_HOVER_EVENTS", [aElms, {fnElmToSrc: this._elm2Src, fnElmToTarget: this._elm2Target}]);
							},
							
							_elm2Src : function(el){
								if(el.tagName == "LI" && el.firstChild && el.firstChild.tagName == "BUTTON"){
									return el.firstChild;
								}else{
									return el;
								}
							},
							
							_elm2Target : function(el){
								if(el.tagName == "BUTTON" && el.parentNode.tagName == "LI"){
									return el.parentNode;
								}else{
									return el;
								}
							},
							
							getScrollXY : function(){
								var scrollX,scrollY;
								var oAppWindow = this.oApp.getWYSIWYGWindow();
								if(typeof oAppWindow.scrollX == "undefined"){
									scrollX = oAppWindow.document.documentElement.scrollLeft;
									scrollY = oAppWindow.document.documentElement.scrollTop;
								}else{
									scrollX = oAppWindow.scrollX;
									scrollY = oAppWindow.scrollY;
								}
								
								return {x:scrollX, y:scrollY};
							}
						});

						nhn.husky.SE2M_Utils = {
							sURLPattern : '(http|https|ftp|mailto):(?:\\/\\/)?((:?\\w|-)+(:?\\.(:?\\w|-)+)+)([^ <>]+)?',
							rxDateFormat : /^(?:\d{4}\.)?\d{1,2}\.\d{1,2}$/,
							_rxTable : /^(?:CAPTION|TBODY|THEAD|TFOOT|TR|TD|TH|COLGROUP|COL)$/i,
							_rxSpaceOnly : /^\s+$/,
							_rxFontStart : /<font(?:\s+[^>]*)?>/i,
							_rxFontStrip : /<\/?font(?:\s+[^>]*)?>/gi,
							_bUnderIE8 : jindo.$Agent().navigator().ie && (jindo.$Agent().navigator().version < 9),
							// @see http://jerekdain.com/fontconversion.html
							// @see https://www.w3.org/TR/html401/present/graphics.html#h-15.2.2
							_htFontSize : {
								"1" : "7pt",
								"2" : "10pt",
								"3" : "12pt",
								"4" : "13.5pt",
								"5" : "18pt",
								"6" : "24pt",
								"7" : "36pt"
							},

							/**
							 * 유효하지 않은 노드가 TBODY, TR, TD 등등 사이에 있는지 판별한다.
							 * @param oNode {Node} 검사할 노드
							 * @return {Boolean} TBODY, TR, TD 등등 사이에 있는 유효하지 않은 노드인지 여부
							 */
							isInvalidNodeInTable : function(oNode){
								// 해당노드가 table 관련노드들이 아닌데 table 관련노드들 사이에 있는지 검사한다.
								// TODO: 좀 더 정확하게 검사할 필요가 있을까?
								if(oNode && !this._rxTable.test(oNode.nodeName)){
									var oTmpNode;
									if((oTmpNode = oNode.previousSibling) && this._rxTable.test(oTmpNode.nodeName)){
										return true;
									}
									if((oTmpNode = oNode.nextSibling) && this._rxTable.test(oTmpNode.nodeName)){
										return true;
									}
								}
								return false;
							},

							/**
							 * [SMARTEDITORSUS-1584][SMARTEDITORSUS-2237]
							 * TBODY, TR, TD 사이에 있는 유효하지 않은 노드이면 제거한다. 
							 * @param oNode {Node} 검사할 노드
							 */
							removeInvalidNodeInTable : function(oNode){
								if(this.isInvalidNodeInTable(oNode) && oNode.parentNode){
									oNode.parentNode.removeChild(oNode);
								}
							},

							/**
							 * [SMARTEDITORSUS-2315] 유효하지 않은 폰트태그를 제거한다.
							 * @param {Element} el 태그정제를 제한할 상위 요소
							 */
							removeInvalidFont : function(el){
								if(!el){
									return;
								}

								this._removeInvalidFontInTable(el);
								this._removeEmptyFont(el);
							},

							/**
							 * [SMARTEDITORSUS-2237] IE11 에서 엑셀을 복사붙여넣기하면 유효하지 않은 위치(tbody, tr, td 사이)에 font 태그가 삽입되므로 제거
							 * @param {Element} el 태그제거를 제한할 상위 요소
							 */
							_removeInvalidFontInTable : function(el){
								var aelFonts = jindo.$$("table font", el);
								for(var i = 0, elFont; (elFont = aelFonts[i]); i++){
									this.removeInvalidNodeInTable(elFont);
								}
							},

							/**
							 * 빈 폰트태그를 제거한다.
							 * @param {Element} el 태그제거를 제한할 상위 요소
							 */
							_removeEmptyFont : function(el){
								var aelFonts = jindo.$$("font", el);
								for(var i = 0, elFont, sInner; (elFont = aelFonts[i]); i++){
									sInner = elFont.innerHTML || "";
									sInner = sInner.replace(this._rxSpaceOnly, "");
									if (!sInner) {
										elFont.parentNode.removeChild(elFont);
									}
								}
							},

							/**
							 * [SMARTEDITORSUS-2315] font 태그를 span 으로 변환
							 * 포스트이슈[MUG-7757] 처리 로직 참고
							 * @param {Element} el 태그변환을 제한할 상위 요소
							 */
							convertFontToSpan : function(el){
								if(!el){
									return;
								}

								var oDoc = el.ownerDocument || document;
								var aelTarget = jindo.$$("font", el);

								for(var i = 0, elTarget, elSpan, sAttrValue; (elTarget = aelTarget[i]); i++){
									elSpan = elTarget.parentNode;
									if(elSpan.tagName !== "SPAN" || elSpan.childNodes.length > 1){
										elSpan = oDoc.createElement("SPAN");
										elTarget.parentNode.insertBefore(elSpan, elTarget);
									}

									sAttrValue = elTarget.getAttribute("face");
									if(sAttrValue){
										elSpan.style.fontFamily = sAttrValue;
									}
									sAttrValue = this._htFontSize[elTarget.getAttribute("size")];
									if(sAttrValue){
										elSpan.style.fontSize = sAttrValue;
									}
									sAttrValue = elTarget.getAttribute("color");
									if(sAttrValue){
										elSpan.style.color = sAttrValue; 
									}

									// font태그 안쪽 내용을 span에 넣는다.
									this._switchFontInnerToSpan(elTarget, elSpan);

									if(elTarget.parentNode){
										elTarget.parentNode.removeChild(elTarget);
									}
								}

								// [SMARTEDITORSUS-2337] IE8이하에서 태그가 역전되어 있으면 font태그가 지워지지 않는 경우가 있어서 정규식으로 확실히 제
								if(i > 0 && this._bUnderIE8){
									el.innerHTML = el.innerHTML.replace(this._rxFontStrip, "");
								}
							},

							/**
							 * font태그 안쪽 내용을 span에 넣는다.
							 * @param {Element} elFont 대상FONT태그
							 * @param {Element} elSpan 빈SPAN태그
							 */
							_switchFontInnerToSpan : function(elFont, elSpan){
								var sInnerHTML = elFont.innerHTML;
								/**
								 * 폰트태그안에 폰트태그가 있을때 innerHTML으로 넣으면 안쪽 폰트태그는 span변환작업에서 누락될 수 있기 때문에
								 * 폰트태그가 중첩해서 있으면 appendChild를 이용하고 그렇지 않으면 innerHTML을 이용
								 * [SMARTEDITORSUS-2337] IE8이하에서 태그가 역전되어 있으면 elSpan.innerHTML시 오류가 나는 경우가 있어서 appendChild 방식 사용
								 */
								if(this._rxFontStart.test(sInnerHTML) || this._bUnderIE8){
									for(var elChild; (elChild = elFont.firstChild);){
										elSpan.appendChild(elChild);
									}
								}else{
									elSpan.innerHTML = sInnerHTML;
								}
							},

							/**
							 * 대상요소의 하위 요소들을 모두 밖으로 빼내고 대상요소를 제거한다.
							 * @param {Element}	el			제거 대상 요소
							 */
							stripTag : function(el){
								for(var elChild; (elChild = el.firstChild);){
									el.parentNode.insertBefore(elChild, el);
								}
								el.parentNode.removeChild(el);
							},

							/**
							 * 노드 하위의 특정태그를 모두 제거한다.
							 * @param {Element}	el			확인 대상 요소
							 * @param {String}	sTagName	제거 대상 태그명 (대문자)
							 */
							stripTags :function(el, sTagName){
								var aelTarget = jindo.$$(sTagName, el);
								for(var i = 0, elTarget; (elTarget = aelTarget[i]); i++){
									this.stripTag(elTarget);
								}
							},

							/**
							 * [SMARTEDITORSUS-2203] 날짜표기를 바로 잡는다. ex) 2015.10.13 -> 2015.10.13. 
							 * @param {String} sDate 확인할 문자열
							 * @returns {String} 올바른 표기로 변환한 문자열
							 */
							reviseDateFormat : function(sDate){
								if(sDate && sDate.replace){
									sDate = sDate.replace(this.rxDateFormat, "$&.");
								}
								return sDate;
							},

							/**
							 * 사용자 클래스 정보를 추출한다.
							 * @param {String} sStr	추출 String
							 * @param {rx} rxValue	rx type 형식의 값
							 * @param {String} sDivision	value의 split 형식
							 * @return {Array}
							 */
							getCustomCSS : function(sStr, rxValue, sDivision) {
								var ret = [];
								if('undefined' == typeof(sStr) || 'undefined' == typeof(rxValue) || !sStr || !rxValue) {
									return ret;
								}
								
								var aMatch = sStr.match(rxValue);		
								if(aMatch && aMatch[0]&&aMatch[1]) {
									if(sDivision) {
										ret = aMatch[1].split(sDivision);
									} else {
										ret[0] = aMatch[1];
									}	
								}
								
								return ret;
							},
							/**
							 * HashTable로 구성된 Array의 같은 프로퍼티를 sSeperator 로 구분된 String 값으로 변환
							 * @param {Object} v
							 * @param {Object} sKey
							 * @author senxation
							 * @example 
						a = [{ b : "1" }, { b : "2" }]

						toStringSamePropertiesOfArray(a, "b", ", ");
						==> "1, 2"
							 */
							toStringSamePropertiesOfArray : function(v, sKey, sSeperator) {
								if(!v){
									return "";
								}
								if (v instanceof Array) {
									var a = [];
									for (var i = 0; i < v.length; i++) {
										a.push(v[i][sKey]);
									}
									return a.join(",").replace(/,/g, sSeperator);
								}
								else {
									if (typeof v[sKey] == "undefined") {
										return "";
									}
									if (typeof v[sKey] == "string") {
										return v[sKey];
									}
								}
							},
							
							/**
							 * 단일 객체를 배열로 만들어줌
							 * @param {Object} v
							 * @return {Array}
							 * @author senxation
							 * @example
						makeArray("test"); ==> ["test"]
							 */	
							makeArray : function(v) {
								if (v === null || typeof v === "undefined"){
									return [];
								}
								if (v instanceof Array) {
									return v;
								}
								var a = [];
								a.push(v);
								return a;
							},
							
							/**
							 * 말줄임을 할때 줄일 내용과 컨테이너가 다를 경우 처리
							 * 컨테이너의 css white-space값이 "normal"이어야한다. (컨테이너보다 텍스트가 길면 여러행으로 표현되는 상태)
							 * @param {HTMLElement} elText 말줄임할 엘리먼트
							 * @param {HTMLElement} elContainer 말줄임할 엘리먼트를 감싸는 컨테이너
							 * @param {String} sStringTail 말줄임을 표현할 문자열 (미지정시 ...)
							 * @param {Number} nLine 최대 라인수 (미지정시 1)
							 * @author senxation
							 * @example
						//div가 2줄 이하가 되도록 strong 내부의 내용을 줄임 
						<div>
							<strong id="a">말줄임을적용할내용말줄임을적용할내용말줄임을적용할내용</strong><span>상세보기</span>
						<div>
						ellipsis(jindo.$("a"), jindo.$("a").parentNode, "...", 2);
							 */
							ellipsis : function(elText, elContainer, sStringTail, nLine) {
								sStringTail = sStringTail || "...";
								if (typeof nLine == "undefined") {
									nLine = 1;
								}
								var welText = jindo.$Element(elText);
								var welContainer = jindo.$Element(elContainer);
								
								var sText = welText.html();
								var nLength = sText.length;
								var nCurrentHeight = welContainer.height();
								var nIndex = 0;
								welText.html('A');
								var nHeight = welContainer.height();

								if (nCurrentHeight < nHeight * (nLine + 0.5)) {
									return welText.html(sText);
								}
							
								/**
								 * 지정된 라인보다 커질때까지 전체 남은 문자열의 절반을 더해나감
								 */
								nCurrentHeight = nHeight;
								while(nCurrentHeight < nHeight * (nLine + 0.5)) {
									nIndex += Math.max(Math.ceil((nLength - nIndex)/2), 1);
									welText.html(sText.substring(0, nIndex) + sStringTail);
									nCurrentHeight = welContainer.height();
								}
							
								/**
								 * 지정된 라인이 될때까지 한글자씩 잘라냄
								 */
								while(nCurrentHeight > nHeight * (nLine + 0.5)) {
									nIndex--;
									welText.html(sText.substring(0, nIndex) + sStringTail);
									nCurrentHeight = welContainer.height();
								}
							},
							
							/**
							 * 최대 가로사이즈를 지정하여 말줄임한다.
							 * elText의 css white-space값이 "nowrap"이어야한다. (컨테이너보다 텍스트가 길면 행변환되지않고 가로로 길게 표현되는 상태)
							 * @param {HTMLElement} elText 말줄임할 엘리먼트
							 * @param {String} sStringTail 말줄임을 표현할 문자열 (미지정시 ...)
							 * @param {Function} fCondition 조건 함수. 내부에서 true를 리턴하는 동안에만 말줄임을 진행한다.
							 * @author senxation
							 * @example
						//150픽셀 이하가 되도록 strong 내부의 내용을 줄임 
						<strong id="a">말줄임을적용할내용말줄임을적용할내용말줄임을적용할내용</strong>>
						ellipsisByPixel(jindo.$("a"), "...", 150);
							 */
							ellipsisByPixel : function(elText, sStringTail, nPixel, fCondition) {
								sStringTail = sStringTail || "...";
								var welText = jindo.$Element(elText);
								var nCurrentWidth = welText.width();
								if (nCurrentWidth < nPixel) {
									return;
								}
								
								var sText = welText.html();
								var nLength = sText.length;

								var nIndex = 0;
								if (typeof fCondition == "undefined") {
									var nWidth = welText.html('A').width();
									nCurrentWidth = nWidth;
									
									while(nCurrentWidth < nPixel) {
										nIndex += Math.max(Math.ceil((nLength - nIndex)/2), 1);
										welText.html(sText.substring(0, nIndex) + sStringTail);
										nCurrentWidth = welText.width();
									}
									
									fCondition = function() {
										return true;
									};
								}
								
								nIndex = welText.html().length - sStringTail.length;
								
								while(nCurrentWidth > nPixel) {
									if (!fCondition()) {
										break;
									}
									nIndex--;
									welText.html(sText.substring(0, nIndex) + sStringTail);
									nCurrentWidth = welText.width();
								}
							},
							
							/**
							 * 여러개의 엘리먼트를 각각의 지정된 최대너비로 말줄임한다.
							 * 말줄임할 엘리먼트의 css white-space값이 "nowrap"이어야한다. (컨테이너보다 텍스트가 길면 행변환되지않고 가로로 길게 표현되는 상태)
							 * @param {Array} aElement 말줄임할 엘리먼트의 배열. 지정된 순서대로 말줄임한다.
							 * @param {String} sStringTail 말줄임을 표현할 문자열 (미지정시 ...)
							 * @param {Array} aMinWidth 말줄임할 너비의 배열.
							 * @param {Function} fCondition 조건 함수. 내부에서 true를 리턴하는 동안에만 말줄임을 진행한다.
							 * @example
						//#a #b #c의 너비를 각각 100, 50, 50픽셀로 줄임 (div#parent 가 200픽셀 이하이면 중단)
						//#c의 너비를 줄이는 동안 fCondition에서 false를 리턴하면 b, a는 말줄임 되지 않는다.  
						<div id="parent">
							<strong id="a">말줄임을적용할내용</strong>
							<strong id="b">말줄임을적용할내용</strong>
							<strong id="c">말줄임을적용할내용</strong>
						<div>
						ellipsisElementsToDesinatedWidth([jindo.$("c"), jindo.$("b"), jindo.$("a")], "...", [100, 50, 50], function(){
							if (jindo.$Element("parent").width() > 200) {
								return true;
							} 
							return false;
						});
							 */
							ellipsisElementsToDesinatedWidth : function(aElement, sStringTail, aMinWidth, fCondition) {
								jindo.$A(aElement).forEach(function(el, i){
									if (!el) {
										jindo.$A.Continue();
									}
									nhn.husky.SE2M_Utils.ellipsisByPixel(el, sStringTail, aMinWidth[i], fCondition);
								});
							},
							
							/**
							 * 숫자를 입력받아 정해진 길이만큼 앞에 "0"이 추가된 문자열을 구한다.
							 * @param {Number} nNumber
							 * @param {Number} nLength
							 * @return {String}
							 * @example
						paddingZero(10, 5); ==> "00010" (String)
							 */
							paddingZero : function(nNumber, nLength) {
								var sResult = nNumber.toString();
								while (sResult.length < nLength) {
									sResult = ("0" + sResult);
								}
								return sResult;
							},
							
							/**
							 * string을 byte 단위로 짤라서 tail를 붙힌다.
							 * @param {String} sString
							 * @param {Number} nByte
							 * @param {String} sTail
							 * @example
							 cutStringToByte('일이삼사오육', 6, '...') ==> '일이삼...' (string)	 
							 */
							cutStringToByte : function(sString, nByte, sTail){
								if(sString === null || sString.length === 0) {
									return sString;
								}	
								
								sString = sString.replace(/  +/g, " ");
								if (!sTail && sTail != "") {
									sTail = "...";
								}
								
								var maxByte = nByte;
								var n=0;
								var nLen = sString.length;
								for(var i=0; i<nLen;i++){
									n += this.getCharByte(sString.charAt(i));			
									if(n == maxByte){ 
										if(i == nLen-1) {
											return sString;
										} else { 
											return sString.substring(0,i)+sTail;
										}	
									} else if( n > maxByte ) { 
										return sString.substring(0, i)+sTail; 
									} 		
								}		
								return sString;
							},
							
							/**
							 * 입력받은 문자의 byte 구한다.
							 * @param {String} ch
							 * 
							 */
							getCharByte : function(ch){
								if (ch === null || ch.length < 1) {
									return 0;
								}	
									 
								var byteSize = 0;
								var str = escape(ch);
								
								if ( str.length == 1 ) {   // when English then 1byte
									 byteSize ++;
								} else if ( str.indexOf("%u") != -1 ) {  // when Korean then 2byte
									 byteSize += 2;
								} else if ( str.indexOf("%") != -1 ) {  // else 3byte
									 byteSize += str.length/3;
								}		   
								return byteSize;
							},
							
							/**
							 * Hash Table에서 원하는 키값만을 가지는 필터된 새로운 Hash Table을 구한다. 
							 * @param {HashTable} htUnfiltered
							 * @param {Array} aKey
							 * @return {HashTable}
							 * @author senxation
							 * @example
						getFilteredHashTable({
							a : 1,
							b : 2,
							c : 3,
							d : 4
						}, ["a", "c"]);
						==> { a : 1, c : 3 }
							 */
							getFilteredHashTable : function(htUnfiltered, vKey) {
								if (!(vKey instanceof Array)) {
									return arguments.callee.call(this, htUnfiltered, [ vKey ]);
								}
								
								var waKey = jindo.$A(vKey);
								return jindo.$H(htUnfiltered).filter(function(vValue, sKey){
									if (waKey.has(sKey) && vValue) {
										return true;
									} else {
										return false;
									}
								}).$value();
							},
							
							isBlankNode : function(elNode){
								var isBlankTextNode = this.isBlankTextNode;
								
								var bEmptyContent = function(elNode){
									if(!elNode) {
										return true;
									}
									
									if(isBlankTextNode(elNode)){
										return true;
									}

									if(elNode.tagName == "BR") {
										return true;
									}
									
									if(elNode.innerHTML == "&nbsp;" || elNode.innerHTML == "") {
										return true;
									}
									
									return false;
								};
								var bEmptyP = function(elNode){
									if(elNode.tagName == "IMG" || elNode.tagName == "IFRAME"){
										return false;
									}
									
									if(bEmptyContent(elNode)){
										return true;
									}
									
									if(elNode.tagName == "P"){
										for(var i=elNode.childNodes.length-1; i>=0; i--){
											var elTmp = elNode.childNodes[i];
											if(isBlankTextNode(elTmp)){
												elTmp.parentNode.removeChild(elTmp);
											}
										}
										
										if(elNode.childNodes.length == 1){
											if(elNode.firstChild.tagName == "IMG" || elNode.firstChild.tagName == "IFRAME"){
												return false;
											}
											if(bEmptyContent(elNode.firstChild)){
												return true;
											}
										}
									}
									
									return false;
								};

								if(bEmptyP(elNode)){
									return true;
								}

								for(var i=0, nLen=elNode.childNodes.length; i<nLen; i++){
									var elTmp = elNode.childNodes[i];
									if(!bEmptyP(elTmp)){
										return false;
									}
								}

								return true;
							},
							
							isBlankTextNode : function(oNode){
								var sText;
								
								if(oNode.nodeType == 3){
									sText = oNode.nodeValue;
									sText = sText.replace(unescape("%uFEFF"), '');
								
									if(sText == "") {
										return true;
									}
								}
								
								return false;
							},
							
							isFirstChildOfNode : function(sTagName, sParentTagName, elNode){
								if(!elNode){
									return false;
								}
								
								if(elNode.tagName == sParentTagName && elNode.firstChild.tagName == sTagName){
									return true;
								}
								
								return false;
							},
							
							/**
							 * elNode의 상위 노드 중 태그명이 sTagName과 일치하는 것이 있다면 반환.
							 * @param {String} sTagName 검색 할 태그명(반드시 대문자를 사용할 것)
							 * @param {HTMLElement} elNode 검색 시작점으로 사용 할 노드
							 * @return {HTMLElement} 부모 노드 중 태그명이 sTagName과 일치하는 노드. 없을 경우 null 반환 
							 */
							findAncestorByTagName : function(sTagName, elNode){
								while(elNode && elNode.tagName != sTagName) {
									elNode = elNode.parentNode;
								}
								
								return elNode;
							},
							
							/**
							 * [SMARTEDITORSUS-1735] 
							 * elNode의 상위 노드 중 태그명이 sTagName과 일치하는 것이 있다면
							 * 해당 노드와 재귀 탐색 횟수가 담긴 객체를 반환.
							 * @param {String} sTagName 검색 할 태그명(반드시 대문자를 사용할 것)
							 * @param {HTMLElement} elNode 검색 시작점으로 사용 할 노드
							 * @return {Object}
							 * {HTMLElement} Object.elNode 부모 노드 중 태그명이 sTagName과 일치하는 노드. 없을 경우 null 반환
							 * {Number} Object.nRecursiveCount 재귀 탐색 횟수
							 */
							findAncestorByTagNameWithCount : function(sTagName, elNode){
								var nRecursiveCount = 0;
								var htResult = {};

								while(elNode && elNode.tagName != sTagName) {
									elNode = elNode.parentNode;
									nRecursiveCount += 1;
								}
								
								htResult = {
										elNode : elNode,
										nRecursiveCount : nRecursiveCount
								}
								
								return htResult;
							},
							
							/**
							 * [SMARTEDITORSUS-1672] elNode의 상위 노드 중 태그명이 aTagName 의 요소 중 하나와 일치하는 것이 있다면 반환.
							 * @param {String} aTagName 검색 할 태그명이 담긴 배열
							 * @param {HTMLElement} elNode 검색 시작점으로 사용 할 노드
							 * @return {HTMLElement} 부모 노드 중 태그명이 aTagName의 요소 중 하나와 일치하는 노드. 없을 경우 null 반환 
							 */
							findClosestAncestorAmongTagNames : function(aTagName, elNode){
								var rxTagNames = new RegExp("^(" + aTagName.join("|") + ")$", "i");
								
								while(elNode && !rxTagNames.test(elNode.tagName)){
									elNode = elNode.parentNode;
								}
								
								return elNode;
							},
							
							/**
							 * [SMARTEDITORSUS-1735] 
							 * elNode의 상위 노드 중 태그명이 aTagName 의 요소 중 하나와 일치하는 것이 있다면
							 * 해당 노드와 재귀 탐색 횟수가 담긴 객체를 반환.
							 * @param {String} aTagName 검색 할 태그명이 담긴 배열
							 * @param {HTMLElement} elNode 검색 시작점으로 사용 할 노드
							 * @return {Object}
							 * {HTMLElement} Object.elNode 부모 노드 중 태그명이 aTagName의 요소 중 하나와 일치하는 노드. 없을 경우 null 반환
							 * {Number} Object.nRecursiveCount 재귀 탐색 횟수
							 */
							findClosestAncestorAmongTagNamesWithCount : function(aTagName, elNode){
								var nRecursiveCount = 0;
								var htResult = {};
								
								var rxTagNames = new RegExp("^(" + aTagName.join("|") + ")$", "i");
								
								while(elNode && !rxTagNames.test(elNode.tagName)){
									elNode = elNode.parentNode;
									nRecursiveCount += 1;
								}
								
								htResult = {
										elNode : elNode,
										nRecursiveCount : nRecursiveCount
								}
								
								return htResult;
							},
							
							/**
							 * [SMARTEDITORSUS-2136] 대상이 Number인지 확인한다.
							 * 
							 * @param {Number} n 판별 대상
							 * @return {Boolean} 대상이 Number이다.
							 * @see http://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric/1830844#1830844
							 * */
							isNumber : function(n){
								return !isNaN(parseFloat(n)) && isFinite(n);
							},
							
							/**
							 * [SMARTEDITORSUS-2136] 객체의 property를 delete 연산자로 제거하는 polyfill
							 * 
							 * @param {Object} oTarget 대상 객체
							 * @param {String} sProp property 명
							 * 
							 * @example nhn.husky.SE2M_Utils.deleteProperty(elTable, 'propA'); // elTable.propA를 delete
							 * 
							 * @see http://stackoverflow.com/questions/1073414/deleting-a-window-property-in-ie
							 * */
							deleteProperty : function(oTarget, sProp){
								if((typeof(oTarget) !== 'object') || (typeof(sProp) !== 'string') || (typeof(oTarget[sProp]) === 'undefined')){
									return;
								}
								
								oTarget[sProp] = undefined;
								try{
									delete oTarget[sProp];
								}catch(e){
									// [IE 8-]
								}
							},
							
							loadCSS : function(url, fnCallback){
								var oDoc = document;
								var elHead = oDoc.getElementsByTagName("HEAD")[0]; 
								var elStyle = oDoc.createElement ("LINK"); 
								elStyle.setAttribute("type", "text/css");
								elStyle.setAttribute("rel", "stylesheet");
								elStyle.setAttribute("href", url);
								if(fnCallback){
									if ('onload' in elStyle) {
										elStyle.onload = function(){
											fnCallback();
											// [SMARTEDITORSUS-2032] IE10호환성보기(IE7) 에서 onload 이벤트가 2번 발생할 수 있는 가능성이 있기 때문에
											// 콜백실행 후 onload 이벤트 핸들러를 제거
											this.onload = null;	
										};
									} else {
										elStyle.onreadystatechange = function(){
											if(elStyle.readyState != "complete"){
												return;
											}
											
											// [SMARTEDITORSUS-308] [IE9] 응답이 304인 경우
											//	onreadystatechage 핸들러에서 readyState 가 complete 인 경우가 두 번 발생
											//	LINK 엘리먼트의 속성으로 콜백 실행 여부를 플래그로 남겨놓아 처리함
											if(elStyle.getAttribute("_complete")){
												return;
											}
											
											elStyle.setAttribute("_complete", true);
											
											fnCallback();
										};
									}
								}
								elHead.appendChild (elStyle); 
							},

							getUniqueId : function(sPrefix) {
								return (sPrefix || '') + jindo.$Date().time() + (Math.random() * 100000).toFixed();
							},
							
							/**
							 * @param {Object} oSrc value copy할 object
							 * @return {Object}
							 * @example
							 *  var oSource = [1, 3, 4, { a:1, b:2, c: { a:1 }}];
								var oTarget = oSource; // call by reference	
								oTarget = nhn.husky.SE2M_Utils.clone(oSource);
								
								oTarget[1] = 2;
								oTarget[3].a = 100;
								console.log(oSource); // check for deep copy 
								console.log(oTarget, oTarget instanceof Object); // check instance type!
							 */
							clone : function(oSrc, oChange) {
								if ('undefined' != typeof(oSrc) && !!oSrc && (oSrc.constructor == Array || oSrc.constructor == Object)) {
									var oCopy = (oSrc.constructor == Array ? [] : {} );
									for (var property in oSrc) {
										if ('undefined' != typeof(oChange) && !!oChange[property]) {		
											oCopy[property] = arguments.callee(oChange[property]);
										} else {
											oCopy[property] = arguments.callee(oSrc[property]);
										}
									}
									
									return oCopy;
								}
								
								return oSrc;
							},
								
							getHtmlTagAttr : function(sHtmlTag, sAttr) {
								var rx = new RegExp('\\s' + sAttr + "=('([^']*)'|\"([^\"]*)\"|([^\"' >]*))", 'i');
								var aResult = rx.exec(sHtmlTag);
								
								if (!aResult) {
									return '';
								}
								
								var sAttrTmp = (aResult[1] || aResult[2] || aResult[3]); // for chrome 5.x bug!
								if (sAttrTmp) {
									sAttrTmp = sAttrTmp.replace(/["]/g, '');
								}
								
								return sAttrTmp;
							},
							
							
							/**
							 * iframe 영역의 aling 정보를 다시 세팅하는 부분.
							 * iframe 형태의 산출물을 에디터에 삽입 이후에 에디터 정렬기능을 추가 하였을때 ir_to_db 이전 시점에서 div태그에 정렬을 넣어주는 로직임.
							 * 브라우저 형태에 따라 정렬 태그가 iframe을 감싸는 div 혹은 p 태그에 정렬이 추가된다.
							 * @param {HTMLElement} el iframe의 parentNode
							 * @param {Document} oDoc  document
							 */
							// [COM-1151] SE2M_PreStringConverter 에서 수정하도록 변경
							iframeAlignConverter : function(el, oDoc){
								var sTagName = el.tagName.toUpperCase();
								
								if(sTagName == "DIV" || sTagName == 'P'){
									//irToDbDOM 에서 최상위 노드가 div 엘리먼트 이므로 parentNode가 없으면 최상의 div 노드 이므로 리턴한다.
									if(el.parentNode === null ){ 
										return;
									}
									var elWYSIWYGDoc = oDoc;
									var wel = jindo.$Element(el);
									var sHtml = wel.html();
									//현재 align을 얻어오기.
									var sAlign = jindo.$Element(el).attr('align') || jindo.$Element(el).css('text-align');
									//if(!sAlign){ //  P > DIV의 경우 문제 발생, 수정 화면에 들어 왔을 때 태그 깨짐
									//	return;
									//}
									//새로운 div 노드 생성한다.
									var welAfter = jindo.$Element(jindo.$('<div></div>', elWYSIWYGDoc));
									welAfter.html(sHtml).attr('align', sAlign);			
									wel.replace(welAfter);		
								}		
							},	
							
							/**
							 * jindo.$JSON.fromXML을 변환한 메서드.
							 * 소숫점이 있는 경우의 처리 시에 숫자로 변환하지 않도록 함(parseFloat 사용 안하도록 수정)
							 * 관련 BTS : [COM-1093]
							 * @param {String} sXML  XML 형태의 문자열
							 * @return {jindo.$JSON}
							 */
							getJsonDatafromXML : function(sXML) {
								var o  = {};
								var re = /\s*<(\/?[\w:-]+)((?:\s+[\w:-]+\s*=\s*(?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'))*)\s*((?:\/>)|(?:><\/\1>|\s*))|\s*<!\[CDATA\[([\w\W]*?)\]\]>\s*|\s*>?([^<]*)/ig;
								var re2= /^[0-9]+(?:\.[0-9]+)?$/;
								var re3= /^\s+$/g;
								var ec = {"&amp;":"&","&nbsp;":" ","&quot;":"\"","&lt;":"<","&gt;":">"};
								var fg = {tags:["/"],stack:[o]};
								var es = function(s){ 
									if (typeof s == "undefined") {
										return "";
									}	
									return s.replace(/&[a-z]+;/g, function(m){ return (typeof ec[m] == "string")?ec[m]:m; });
								};
								var at = function(s,c) {
									s.replace(/([\w:-]+)\s*=\s*(?:"((?:\\"|[^"])*)"|'((?:\\'|[^'])*)')/g, function($0,$1,$2,$3) {
										c[$1] = es(($2?$2.replace(/\\"/g,'"'):undefined)||($3?$3.replace(/\\'/g,"'"):undefined));
									}); 
								};
								
								var em = function(o) {
									for(var x in o){
										if (Object.prototype.hasOwnProperty.call(o, x)) {
											if(Object.prototype[x]) {
												continue;
											}	
											return false;
										}
									}
									return true;
								};
								
								// $0 : 전체 
								// $1 : 태그명
								// $2 : 속성문자열
								// $3 : 닫는태그
								// $4 : CDATA바디값
								// $5 : 그냥 바디값 
								var cb = function($0,$1,$2,$3,$4,$5) {
									var cur, cdata = "";
									var idx = fg.stack.length - 1;
									
									if (typeof $1 == "string" && $1) {
										if ($1.substr(0,1) != "/") {
											var has_attr = (typeof $2 == "string" && $2);
											var closed   = (typeof $3 == "string" && $3);
											var newobj   = (!has_attr && closed)?"":{};

											cur = fg.stack[idx];
											
											if (typeof cur[$1] == "undefined") {
												cur[$1] = newobj; 
												cur = fg.stack[idx+1] = cur[$1];
											} else if (cur[$1] instanceof Array) {
												var len = cur[$1].length;
												cur[$1][len] = newobj;
												cur = fg.stack[idx+1] = cur[$1][len];  
											} else {
												cur[$1] = [cur[$1], newobj];
												cur = fg.stack[idx+1] = cur[$1][1];
											}
											
											if (has_attr) {
												at($2,cur);
											}	

											fg.tags[idx+1] = $1;

											if (closed) {
												fg.tags.length--;
												fg.stack.length--;
											}
										} else {
											fg.tags.length--;
											fg.stack.length--;
										}
									} else if (typeof $4 == "string" && $4) {
										cdata = $4;
									} else if (typeof $5 == "string" && $5.replace(re3, "")) { // [SMARTEDITORSUS-1525] 닫는 태그인데 공백문자가 들어있어 cdata 값을 덮어쓰는 경우 방지 
										cdata = es($5);
									}
									
									if (cdata.length > 0) {
										var par = fg.stack[idx-1];
										var tag = fg.tags[idx];

										if (re2.test(cdata)) {
											//cdata = parseFloat(cdata);
										}else if (cdata == "true" || cdata == "false"){
											cdata = new Boolean(cdata);
										}

										if(typeof par =='undefined') {
											return;
										}	
										
										if (par[tag] instanceof Array) {
											var o = par[tag];
											if (typeof o[o.length-1] == "object" && !em(o[o.length-1])) {
												o[o.length-1].$cdata = cdata;
												o[o.length-1].toString = function(){ return cdata; };
											} else {
												o[o.length-1] = cdata;
											}
										} else {
											if (typeof par[tag] == "object" && !em(par[tag])) {
												par[tag].$cdata = cdata;
												par[tag].toString = function() { return cdata; };
											} else {
												par[tag] = cdata;
											}
										}
									}
								};
								
								sXML = sXML.replace(/<(\?|!-)[^>]*>/g, "");
								sXML.replace(re, cb);
								
								return jindo.$Json(o);
							},
							/**
							 * 문자열내 자주 사용되는 특수문자 5개 (", ', &, <, >)를 HTML Entity Code 로 변경하여 반환
							 * @see http://www.w3.org/TR/html4/charset.html#entities
							 * @param {String} sString 원본 문자열
							 * @returns {String} 변경된 문자열
							 * @example
							 * replaceSpecialChar() or replaceSpecialChar(123)
							 * // 결과: ""
							 *
							 * replaceSpecialChar("&quot;, ', &, <, >")
							 * // 결과: &amp;quot;, &amp;#39;, &amp;amp;, &amp;lt;, &amp;gt;
							 */
							replaceSpecialChar : function(sString){
								return (typeof(sString) == "string") ? (sString.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;")) : "";
							},
							/**
							 * 문자열내 자주 사용되는 HTML Entity Code 5개를 원래 문자로 (", ', &, <, >)로 변경하여 반환
							 * @see http://www.w3.org/TR/html4/charset.html#entities
							 * @param {String} sString 원본 문자열
							 * @returns {String} 변경된 문자열
							 * @example
							 * restoreSpecialChar() or restoreSpecialChar(123)
							 * // 결과: ""
							 *
							 * restoreSpecialChar("&amp;quot;, &amp;#39;, &amp;amp;, &amp;lt;, &amp;gt;")
							 * // 결과: ", ', &, <, >
							 */
							restoreSpecialChar : function(sString){
								return (typeof(sString) == "string") ? (sString.replace(/&quot;/g, "\"").replace(/&#39;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&")) : "";
							}
						};

						/**
						 * nhn.husky.AutoResizer
						 * 	HTML모드와 TEXT 모드의 편집 영역인 TEXTAREA에 대한 자동확장 처리
						 */
						nhn.husky.AutoResizer = jindo.$Class({
							welHiddenDiv : null,
							welCloneDiv : null,
							elContainer : null,
							$init : function(el, htOption){
								var aCopyStyle = [
										'lineHeight', 'textDecoration', 'letterSpacing',
										'fontSize', 'fontFamily', 'fontStyle', 'fontWeight',
										'textTransform', 'textAlign', 'direction', 'wordSpacing', 'fontSizeAdjust',
										'paddingTop', 'paddingLeft', 'paddingBottom', 'paddingRight', 'width'
									],
									i = aCopyStyle.length,
									oCss = {
										"position" : "absolute",
										"top" : -9999,
										"left" : -9999,
										"opacity": 0,
										"overflow": "hidden",
										"wordWrap" : "break-word"
									};
								
								this.nMinHeight = htOption.nMinHeight;
								this.wfnCallback = htOption.wfnCallback;
								
								this.elContainer = el.parentNode;
								this.welTextArea = jindo.$Element(el);	// autoresize를 적용할 TextArea
								this.welHiddenDiv = jindo.$Element('<div>');

								this.wfnResize = jindo.$Fn(this._resize, this);

								this.sOverflow = this.welTextArea.css("overflow");
								this.welTextArea.css("overflow", "hidden");

								while(i--){
									oCss[aCopyStyle[i]] = this.welTextArea.css(aCopyStyle[i]);
								}
								
								this.welHiddenDiv.css(oCss);
								
								this.nLastHeight = this.welTextArea.height();
							},
							bind : function(){
								this.welCloneDiv = jindo.$Element(this.welHiddenDiv.$value().cloneNode(false));
								
								this.wfnResize.attach(this.welTextArea, "keyup");
								this.welCloneDiv.appendTo(this.elContainer);
								
								this._resize();
							},
							unbind : function(){
								this.wfnResize.detach(this.welTextArea, "keyup");
								this.welTextArea.css("overflow", this.sOverflow);
								
								if(this.welCloneDiv){
									this.welCloneDiv.leave();
								}
							},
							_resize : function(){
								var sContents = this.welTextArea.$value().value,
									bExpand = false,
									nHeight;

								if(sContents === this.sContents){
									return;
								}
								
								this.sContents = sContents.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/ /g, '&nbsp;').replace(/\n/g, '<br>');
								this.sContents += "<br>";	// 마지막 개행 뒤에 <br>을 더 붙여주어야 늘어나는 높이가 동일함
								
								this.welCloneDiv.html(this.sContents);
								nHeight = this.welCloneDiv.height();
								
								if(nHeight < this.nMinHeight){
									nHeight = this.nMinHeight;
								}

								this.welTextArea.css("height", nHeight + "px");
								this.elContainer.style.height = nHeight + "px";
								
								if(this.nLastHeight < nHeight){
									bExpand = true;
								}

								this.wfnCallback(bExpand);
							}
						});

						/**
						 * 문자를 연결하는 '+' 대신에 java와 유사하게 처리하도록 문자열 처리하도록 만드는 object
						 * @author nox
						 * @example
						 var sTmp1 = new StringBuffer();
						 sTmp1.append('1').append('2').append('3');
						 
						 var sTmp2 = new StringBuffer('1');
						 sTmp2.append('2').append('3');
						 
						 var sTmp3 = new StringBuffer('1').append('2').append('3');
						 */
						if(typeof window.StringBuffer == 'undefined') { window.StringBuffer = {}; }

						StringBuffer = function(str) {
							this._aString = [];
							if ('undefined' != typeof(str)) {
								this.append(str);
							}
						};

						StringBuffer.prototype.append = function(str) {
							this._aString.push(str);
							return this;
						};

						StringBuffer.prototype.toString = function() {
							return this._aString.join('');
						};

						StringBuffer.prototype.setLength = function(nLen) {
							if('undefined' == typeof(nLen) || 0 >= nLen) {
								this._aString.length = 0;
							} else {
								this._aString.length = nLen;
							}
						};

						/**
						 * Installed Font Detector
						 * @author hooriza
						 *
						 * @see http://remysharp.com/2008/07/08/how-to-detect-if-a-font-is-installed-only-using-javascript/
						 */

						(function() {

							var oDummy = null, rx = /,/gi;

							window.IsInstalledFont = function(sFont) {

								var sDefFont = sFont == 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';
								if (!oDummy) {
									oDummy = document.createElement('div');
								}	
								
								var sStyle = 'position:absolute !important; font-size:200px !important; left:-9999px !important; top:-9999px !important;';
								oDummy.innerHTML = 'mmmmiiiii'+unescape('%uD55C%uAE00');
								oDummy.style.cssText = sStyle + 'font-family:"' + sDefFont + '" !important';
								
								var elBody = document.body || document.documentElement;
								if(elBody.firstChild){
									elBody.insertBefore(oDummy, elBody.firstChild);
								}else{
									document.body.appendChild(oDummy);
								}
								
								var sOrg = oDummy.offsetWidth + '-' + oDummy.offsetHeight;

								oDummy.style.cssText = sStyle + 'font-family:"' + sFont.replace(rx, '","') + '", "' + sDefFont + '" !important';

								var bInstalled = sOrg != (oDummy.offsetWidth + '-' + oDummy.offsetHeight);
								
								document.body.removeChild(oDummy);
								
								return bInstalled;
											
							};	
						})();
					},
					"hp_StringConverterManager.js": function (exports, module, require) {
						/*
						Copyright (C) NAVER corp.  

						This library is free software; you can redistribute it and/or  
						modify it under the terms of the GNU Lesser General Public  
						License as published by the Free Software Foundation; either  
						version 2.1 of the License, or (at your option) any later version.  

						This library is distributed in the hope that it will be useful,  
						but WITHOUT ANY WARRANTY; without even the implied warranty of  
						MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  
						Lesser General Public License for more details.  

						You should have received a copy of the GNU Lesser General Public  
						License along with this library; if not, write to the Free Software  
						Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA  
						*/
						//{
						/**
						 * @fileOverview This file contains Husky plugin that takes care of the operations related to string conversion. Ususally used to convert the IR value.
						 * @name hp_StringConverterManager.js
						 */
						nhn.husky.StringConverterManager = jindo.$Class({
							name : "StringConverterManager",

							oConverters : null,

							$init : function(){
								this.oConverters = {};
								this.oConverters_DOM = {};
								this.oAgent = jindo.$Agent().navigator(); 
							},
							
							$BEFORE_MSG_APP_READY : function(){
								this.oApp.exec("ADD_APP_PROPERTY", ["applyConverter", jindo.$Fn(this.applyConverter, this).bind()]);
								this.oApp.exec("ADD_APP_PROPERTY", ["addConverter", jindo.$Fn(this.addConverter, this).bind()]);
								this.oApp.exec("ADD_APP_PROPERTY", ["addConverter_DOM", jindo.$Fn(this.addConverter_DOM, this).bind()]);
							},
							
							applyConverter : function(sRuleName, sContents, oDocument){
								//string을 넣는 이유:IE의 경우,본문 앞에 있는 html 주석이 삭제되는 경우가 있기때문에 임시 string을 추가해준것임.
								var sTmpStr =  "@"+(new Date()).getTime()+"@";
								var rxTmpStr = new RegExp(sTmpStr, "g");
								
								var oRes = {sContents:sTmpStr+sContents};
								
								oDocument = oDocument || document;
								
								this.oApp.exec("MSG_STRING_CONVERTER_STARTED", [sRuleName, oRes]);
						//		this.oApp.exec("MSG_STRING_CONVERTER_STARTED_"+sRuleName, [oRes]);

								var aConverters;
								sContents = oRes.sContents;
								aConverters = this.oConverters_DOM[sRuleName];
								if(aConverters){
									var elContentsHolder = oDocument.createElement("div");
									elContentsHolder.innerHTML = sContents;
									
									for(var i=0; i<aConverters.length; i++){
										aConverters[i](elContentsHolder);
									}
									sContents = elContentsHolder.innerHTML; 
									// 내용물에 EMBED등이 있을 경우 IE에서 페이지 나갈 때 권한 오류 발생 할 수 있어 명시적으로 노드 삭제.
									
									if(elContentsHolder.parentNode){
										elContentsHolder.parentNode.removeChild(elContentsHolder);
									}
									elContentsHolder = null;
									
									
									//IE의 경우, sContents를 innerHTML로 넣는 경우 string과 <p>tag 사이에 '\n\'개행문자를 넣어준다. 
									if( jindo.$Agent().navigator().ie ){
										sTmpStr = sTmpStr +'(\r\n)?'; //ie+win에서는 개행이 \r\n로 들어감.
										rxTmpStr = new RegExp(sTmpStr , "g");
									}
								}
								
								aConverters = this.oConverters[sRuleName];
								if(aConverters){
									for(i=0; i<aConverters.length; i++){
										var sTmpContents = aConverters[i](sContents);
										if(typeof sTmpContents != "undefined"){
											sContents = sTmpContents;
										}
									}
								}

								oRes = {sContents:sContents};
								this.oApp.exec("MSG_STRING_CONVERTER_ENDED", [sRuleName, oRes]);
								
								oRes.sContents = oRes.sContents.replace(rxTmpStr, "");
								return oRes.sContents;
							},

							$ON_ADD_CONVERTER : function(sRuleName, funcConverter){
								var aCallerStack = this.oApp.aCallerStack;
								funcConverter.sPluginName = aCallerStack[aCallerStack.length-2].name;
								this.addConverter(sRuleName, funcConverter);
							},

							$ON_ADD_CONVERTER_DOM : function(sRuleName, funcConverter){
								var aCallerStack = this.oApp.aCallerStack;
								funcConverter.sPluginName = aCallerStack[aCallerStack.length-2].name;
								this.addConverter_DOM(sRuleName, funcConverter);
							},

							addConverter : function(sRuleName, funcConverter){
								var aConverters = this.oConverters[sRuleName];
								if(!aConverters){
									this.oConverters[sRuleName] = [];
								}

								this.oConverters[sRuleName][this.oConverters[sRuleName].length] = funcConverter;
							},

							addConverter_DOM : function(sRuleName, funcConverter){
								var aConverters = this.oConverters_DOM[sRuleName];
								if(!aConverters){
									this.oConverters_DOM[sRuleName] = [];
								}

								this.oConverters_DOM[sRuleName][this.oConverters_DOM[sRuleName].length] = funcConverter;
							}
						});
						//}
					},
					"hp_Utils.js": function (exports, module, require) {
						/*
						Copyright (C) NAVER corp.  

						This library is free software; you can redistribute it and/or  
						modify it under the terms of the GNU Lesser General Public  
						License as published by the Free Software Foundation; either  
						version 2.1 of the License, or (at your option) any later version.  

						This library is distributed in the hope that it will be useful,  
						but WITHOUT ANY WARRANTY; without even the implied warranty of  
						MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  
						Lesser General Public License for more details.  

						You should have received a copy of the GNU Lesser General Public  
						License along with this library; if not, write to the Free Software  
						Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA  
						*/
						/*[
						 * ATTACH_HOVER_EVENTS
						 *
						 * 주어진 HTML엘리먼트에 Hover 이벤트 발생시 특정 클래스가 할당 되도록 설정
						 *
						 * aElms array Hover 이벤트를 걸 HTML Element 목록
						 * sHoverClass string Hover 시에 할당 할 클래스
						 *
						---------------------------------------------------------------------------]*/
						/**
						 * @pluginDesc Husky Framework에서 자주 사용되는 유틸성 메시지를 처리하는 플러그인
						 */
						 nhn.husky.Utils = jindo.$Class({
							name : "Utils",

							$init : function(){
								var oAgentInfo = jindo.$Agent();
								var oNavigatorInfo = oAgentInfo.navigator();

								if(oNavigatorInfo.ie && oNavigatorInfo.version == 6){
									try{
										document.execCommand('BackgroundImageCache', false, true);
									}catch(e){/**/}
								}
							},
							
							$BEFORE_MSG_APP_READY : function(){
								this.oApp.exec("ADD_APP_PROPERTY", ["htBrowser", jindo.$Agent().navigator()]);
							},
							
							$ON_ATTACH_HOVER_EVENTS : function(aElms, htOptions){
								htOptions = htOptions || [];
								var sHoverClass = htOptions.sHoverClass || "hover";
								var fnElmToSrc = htOptions.fnElmToSrc || function(el){return el};
								var fnElmToTarget = htOptions.fnElmToTarget || function(el){return el};
								
								if(!aElms) return;
								
								var wfAddClass = jindo.$Fn(function(wev){
									jindo.$Element(fnElmToTarget(wev.currentElement)).addClass(sHoverClass);
								}, this);
								
								var wfRemoveClass = jindo.$Fn(function(wev){
									jindo.$Element(fnElmToTarget(wev.currentElement)).removeClass(sHoverClass);
								}, this);
								
								for(var i=0, len = aElms.length; i<len; i++){
									var elSource = fnElmToSrc(aElms[i]);
									
									wfAddClass.attach(elSource, "mouseover");
									wfRemoveClass.attach(elSource, "mouseout");
									
									wfAddClass.attach(elSource, "focus");
									wfRemoveClass.attach(elSource, "blur");
								}
							}
						});
					}
				}
			}
		}
	}
})("webhwp/workspace/src/bundle/index");
